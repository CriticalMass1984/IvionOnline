// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Types.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Types_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Types_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3014000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3014000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Types_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Types_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[13]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Types_2eproto;
namespace Types {
class CardRef;
class CardRefDefaultTypeInternal;
extern CardRefDefaultTypeInternal _CardRef_default_instance_;
class EntityRef;
class EntityRefDefaultTypeInternal;
extern EntityRefDefaultTypeInternal _EntityRef_default_instance_;
class EntityValue;
class EntityValueDefaultTypeInternal;
extern EntityValueDefaultTypeInternal _EntityValue_default_instance_;
class Integer;
class IntegerDefaultTypeInternal;
extern IntegerDefaultTypeInternal _Integer_default_instance_;
class IntegerRef;
class IntegerRefDefaultTypeInternal;
extern IntegerRefDefaultTypeInternal _IntegerRef_default_instance_;
class IntegerValue;
class IntegerValueDefaultTypeInternal;
extern IntegerValueDefaultTypeInternal _IntegerValue_default_instance_;
class Path;
class PathDefaultTypeInternal;
extern PathDefaultTypeInternal _Path_default_instance_;
class Path_FieldIndecies;
class Path_FieldIndeciesDefaultTypeInternal;
extern Path_FieldIndeciesDefaultTypeInternal _Path_FieldIndecies_default_instance_;
class PlayerRef;
class PlayerRefDefaultTypeInternal;
extern PlayerRefDefaultTypeInternal _PlayerRef_default_instance_;
class TileRef;
class TileRefDefaultTypeInternal;
extern TileRefDefaultTypeInternal _TileRef_default_instance_;
class Vec2i;
class Vec2iDefaultTypeInternal;
extern Vec2iDefaultTypeInternal _Vec2i_default_instance_;
class Vec2iRef;
class Vec2iRefDefaultTypeInternal;
extern Vec2iRefDefaultTypeInternal _Vec2iRef_default_instance_;
class Vec2iValue;
class Vec2iValueDefaultTypeInternal;
extern Vec2iValueDefaultTypeInternal _Vec2iValue_default_instance_;
}  // namespace Types
PROTOBUF_NAMESPACE_OPEN
template<> ::Types::CardRef* Arena::CreateMaybeMessage<::Types::CardRef>(Arena*);
template<> ::Types::EntityRef* Arena::CreateMaybeMessage<::Types::EntityRef>(Arena*);
template<> ::Types::EntityValue* Arena::CreateMaybeMessage<::Types::EntityValue>(Arena*);
template<> ::Types::Integer* Arena::CreateMaybeMessage<::Types::Integer>(Arena*);
template<> ::Types::IntegerRef* Arena::CreateMaybeMessage<::Types::IntegerRef>(Arena*);
template<> ::Types::IntegerValue* Arena::CreateMaybeMessage<::Types::IntegerValue>(Arena*);
template<> ::Types::Path* Arena::CreateMaybeMessage<::Types::Path>(Arena*);
template<> ::Types::Path_FieldIndecies* Arena::CreateMaybeMessage<::Types::Path_FieldIndecies>(Arena*);
template<> ::Types::PlayerRef* Arena::CreateMaybeMessage<::Types::PlayerRef>(Arena*);
template<> ::Types::TileRef* Arena::CreateMaybeMessage<::Types::TileRef>(Arena*);
template<> ::Types::Vec2i* Arena::CreateMaybeMessage<::Types::Vec2i>(Arena*);
template<> ::Types::Vec2iRef* Arena::CreateMaybeMessage<::Types::Vec2iRef>(Arena*);
template<> ::Types::Vec2iValue* Arena::CreateMaybeMessage<::Types::Vec2iValue>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Types {

enum TerrainType : int {
  TERRAIN_NONE = 0,
  TERRAIN_DIFFICULT = 1,
  TERRAIN_ENCHANTED = 2,
  TerrainType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TerrainType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TerrainType_IsValid(int value);
constexpr TerrainType TerrainType_MIN = TERRAIN_NONE;
constexpr TerrainType TerrainType_MAX = TERRAIN_ENCHANTED;
constexpr int TerrainType_ARRAYSIZE = TerrainType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TerrainType_descriptor();
template<typename T>
inline const std::string& TerrainType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TerrainType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TerrainType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TerrainType_descriptor(), enum_t_value);
}
inline bool TerrainType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TerrainType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TerrainType>(
    TerrainType_descriptor(), name, value);
}
// ===================================================================

class Path_FieldIndecies PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Types.Path.FieldIndecies) */ {
 public:
  inline Path_FieldIndecies() : Path_FieldIndecies(nullptr) {}
  virtual ~Path_FieldIndecies();

  Path_FieldIndecies(const Path_FieldIndecies& from);
  Path_FieldIndecies(Path_FieldIndecies&& from) noexcept
    : Path_FieldIndecies() {
    *this = ::std::move(from);
  }

  inline Path_FieldIndecies& operator=(const Path_FieldIndecies& from) {
    CopyFrom(from);
    return *this;
  }
  inline Path_FieldIndecies& operator=(Path_FieldIndecies&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Path_FieldIndecies& default_instance();

  static inline const Path_FieldIndecies* internal_default_instance() {
    return reinterpret_cast<const Path_FieldIndecies*>(
               &_Path_FieldIndecies_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Path_FieldIndecies& a, Path_FieldIndecies& b) {
    a.Swap(&b);
  }
  inline void Swap(Path_FieldIndecies* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Path_FieldIndecies* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Path_FieldIndecies* New() const final {
    return CreateMaybeMessage<Path_FieldIndecies>(nullptr);
  }

  Path_FieldIndecies* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Path_FieldIndecies>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Path_FieldIndecies& from);
  void MergeFrom(const Path_FieldIndecies& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Path_FieldIndecies* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Types.Path.FieldIndecies";
  }
  protected:
  explicit Path_FieldIndecies(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Types_2eproto);
    return ::descriptor_table_Types_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIndeciesFieldNumber = 1,
  };
  // repeated int32 Indecies = 1;
  int indecies_size() const;
  private:
  int _internal_indecies_size() const;
  public:
  void clear_indecies();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_indecies(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_indecies() const;
  void _internal_add_indecies(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_indecies();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 indecies(int index) const;
  void set_indecies(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_indecies(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      indecies() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_indecies();

  // @@protoc_insertion_point(class_scope:Types.Path.FieldIndecies)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > indecies_;
  mutable std::atomic<int> _indecies_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Types_2eproto;
};
// -------------------------------------------------------------------

class Path PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Types.Path) */ {
 public:
  inline Path() : Path(nullptr) {}
  virtual ~Path();

  Path(const Path& from);
  Path(Path&& from) noexcept
    : Path() {
    *this = ::std::move(from);
  }

  inline Path& operator=(const Path& from) {
    CopyFrom(from);
    return *this;
  }
  inline Path& operator=(Path&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Path& default_instance();

  static inline const Path* internal_default_instance() {
    return reinterpret_cast<const Path*>(
               &_Path_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Path& a, Path& b) {
    a.Swap(&b);
  }
  inline void Swap(Path* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Path* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Path* New() const final {
    return CreateMaybeMessage<Path>(nullptr);
  }

  Path* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Path>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Path& from);
  void MergeFrom(const Path& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Path* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Types.Path";
  }
  protected:
  explicit Path(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Types_2eproto);
    return ::descriptor_table_Types_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Path_FieldIndecies FieldIndecies;

  // accessors -------------------------------------------------------

  enum : int {
    kFullPathFieldNumber = 2,
    kFieldsFieldNumber = 1,
  };
  // string FullPath = 2;
  void clear_fullpath();
  const std::string& fullpath() const;
  void set_fullpath(const std::string& value);
  void set_fullpath(std::string&& value);
  void set_fullpath(const char* value);
  void set_fullpath(const char* value, size_t size);
  std::string* mutable_fullpath();
  std::string* release_fullpath();
  void set_allocated_fullpath(std::string* fullpath);
  private:
  const std::string& _internal_fullpath() const;
  void _internal_set_fullpath(const std::string& value);
  std::string* _internal_mutable_fullpath();
  public:

  // .Types.Path.FieldIndecies Fields = 1;
  bool has_fields() const;
  private:
  bool _internal_has_fields() const;
  public:
  void clear_fields();
  const ::Types::Path_FieldIndecies& fields() const;
  ::Types::Path_FieldIndecies* release_fields();
  ::Types::Path_FieldIndecies* mutable_fields();
  void set_allocated_fields(::Types::Path_FieldIndecies* fields);
  private:
  const ::Types::Path_FieldIndecies& _internal_fields() const;
  ::Types::Path_FieldIndecies* _internal_mutable_fields();
  public:
  void unsafe_arena_set_allocated_fields(
      ::Types::Path_FieldIndecies* fields);
  ::Types::Path_FieldIndecies* unsafe_arena_release_fields();

  // @@protoc_insertion_point(class_scope:Types.Path)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fullpath_;
  ::Types::Path_FieldIndecies* fields_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Types_2eproto;
};
// -------------------------------------------------------------------

class Integer PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Types.Integer) */ {
 public:
  inline Integer() : Integer(nullptr) {}
  virtual ~Integer();

  Integer(const Integer& from);
  Integer(Integer&& from) noexcept
    : Integer() {
    *this = ::std::move(from);
  }

  inline Integer& operator=(const Integer& from) {
    CopyFrom(from);
    return *this;
  }
  inline Integer& operator=(Integer&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Integer& default_instance();

  static inline const Integer* internal_default_instance() {
    return reinterpret_cast<const Integer*>(
               &_Integer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Integer& a, Integer& b) {
    a.Swap(&b);
  }
  inline void Swap(Integer* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Integer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Integer* New() const final {
    return CreateMaybeMessage<Integer>(nullptr);
  }

  Integer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Integer>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Integer& from);
  void MergeFrom(const Integer& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Integer* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Types.Integer";
  }
  protected:
  explicit Integer(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Types_2eproto);
    return ::descriptor_table_Types_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // int32 Value = 1;
  void clear_value();
  ::PROTOBUF_NAMESPACE_ID::int32 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_value() const;
  void _internal_set_value(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:Types.Integer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Types_2eproto;
};
// -------------------------------------------------------------------

class Vec2i PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Types.Vec2i) */ {
 public:
  inline Vec2i() : Vec2i(nullptr) {}
  virtual ~Vec2i();

  Vec2i(const Vec2i& from);
  Vec2i(Vec2i&& from) noexcept
    : Vec2i() {
    *this = ::std::move(from);
  }

  inline Vec2i& operator=(const Vec2i& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vec2i& operator=(Vec2i&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Vec2i& default_instance();

  static inline const Vec2i* internal_default_instance() {
    return reinterpret_cast<const Vec2i*>(
               &_Vec2i_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Vec2i& a, Vec2i& b) {
    a.Swap(&b);
  }
  inline void Swap(Vec2i* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vec2i* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Vec2i* New() const final {
    return CreateMaybeMessage<Vec2i>(nullptr);
  }

  Vec2i* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Vec2i>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Vec2i& from);
  void MergeFrom(const Vec2i& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vec2i* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Types.Vec2i";
  }
  protected:
  explicit Vec2i(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Types_2eproto);
    return ::descriptor_table_Types_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // int32 X = 1;
  void clear_x();
  ::PROTOBUF_NAMESPACE_ID::int32 x() const;
  void set_x(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_x() const;
  void _internal_set_x(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 Y = 2;
  void clear_y();
  ::PROTOBUF_NAMESPACE_ID::int32 y() const;
  void set_y(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_y() const;
  void _internal_set_y(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:Types.Vec2i)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 x_;
  ::PROTOBUF_NAMESPACE_ID::int32 y_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Types_2eproto;
};
// -------------------------------------------------------------------

class PlayerRef PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Types.PlayerRef) */ {
 public:
  inline PlayerRef() : PlayerRef(nullptr) {}
  virtual ~PlayerRef();

  PlayerRef(const PlayerRef& from);
  PlayerRef(PlayerRef&& from) noexcept
    : PlayerRef() {
    *this = ::std::move(from);
  }

  inline PlayerRef& operator=(const PlayerRef& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerRef& operator=(PlayerRef&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PlayerRef& default_instance();

  static inline const PlayerRef* internal_default_instance() {
    return reinterpret_cast<const PlayerRef*>(
               &_PlayerRef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(PlayerRef& a, PlayerRef& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerRef* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerRef* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PlayerRef* New() const final {
    return CreateMaybeMessage<PlayerRef>(nullptr);
  }

  PlayerRef* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PlayerRef>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PlayerRef& from);
  void MergeFrom(const PlayerRef& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerRef* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Types.PlayerRef";
  }
  protected:
  explicit PlayerRef(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Types_2eproto);
    return ::descriptor_table_Types_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectPathFieldNumber = 1,
  };
  // .Types.Path ObjectPath = 1;
  bool has_objectpath() const;
  private:
  bool _internal_has_objectpath() const;
  public:
  void clear_objectpath();
  const ::Types::Path& objectpath() const;
  ::Types::Path* release_objectpath();
  ::Types::Path* mutable_objectpath();
  void set_allocated_objectpath(::Types::Path* objectpath);
  private:
  const ::Types::Path& _internal_objectpath() const;
  ::Types::Path* _internal_mutable_objectpath();
  public:
  void unsafe_arena_set_allocated_objectpath(
      ::Types::Path* objectpath);
  ::Types::Path* unsafe_arena_release_objectpath();

  // @@protoc_insertion_point(class_scope:Types.PlayerRef)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Types::Path* objectpath_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Types_2eproto;
};
// -------------------------------------------------------------------

class CardRef PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Types.CardRef) */ {
 public:
  inline CardRef() : CardRef(nullptr) {}
  virtual ~CardRef();

  CardRef(const CardRef& from);
  CardRef(CardRef&& from) noexcept
    : CardRef() {
    *this = ::std::move(from);
  }

  inline CardRef& operator=(const CardRef& from) {
    CopyFrom(from);
    return *this;
  }
  inline CardRef& operator=(CardRef&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CardRef& default_instance();

  static inline const CardRef* internal_default_instance() {
    return reinterpret_cast<const CardRef*>(
               &_CardRef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CardRef& a, CardRef& b) {
    a.Swap(&b);
  }
  inline void Swap(CardRef* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CardRef* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CardRef* New() const final {
    return CreateMaybeMessage<CardRef>(nullptr);
  }

  CardRef* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CardRef>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CardRef& from);
  void MergeFrom(const CardRef& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CardRef* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Types.CardRef";
  }
  protected:
  explicit CardRef(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Types_2eproto);
    return ::descriptor_table_Types_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectPathFieldNumber = 1,
  };
  // .Types.Path ObjectPath = 1;
  bool has_objectpath() const;
  private:
  bool _internal_has_objectpath() const;
  public:
  void clear_objectpath();
  const ::Types::Path& objectpath() const;
  ::Types::Path* release_objectpath();
  ::Types::Path* mutable_objectpath();
  void set_allocated_objectpath(::Types::Path* objectpath);
  private:
  const ::Types::Path& _internal_objectpath() const;
  ::Types::Path* _internal_mutable_objectpath();
  public:
  void unsafe_arena_set_allocated_objectpath(
      ::Types::Path* objectpath);
  ::Types::Path* unsafe_arena_release_objectpath();

  // @@protoc_insertion_point(class_scope:Types.CardRef)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Types::Path* objectpath_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Types_2eproto;
};
// -------------------------------------------------------------------

class TileRef PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Types.TileRef) */ {
 public:
  inline TileRef() : TileRef(nullptr) {}
  virtual ~TileRef();

  TileRef(const TileRef& from);
  TileRef(TileRef&& from) noexcept
    : TileRef() {
    *this = ::std::move(from);
  }

  inline TileRef& operator=(const TileRef& from) {
    CopyFrom(from);
    return *this;
  }
  inline TileRef& operator=(TileRef&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TileRef& default_instance();

  static inline const TileRef* internal_default_instance() {
    return reinterpret_cast<const TileRef*>(
               &_TileRef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(TileRef& a, TileRef& b) {
    a.Swap(&b);
  }
  inline void Swap(TileRef* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TileRef* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TileRef* New() const final {
    return CreateMaybeMessage<TileRef>(nullptr);
  }

  TileRef* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TileRef>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TileRef& from);
  void MergeFrom(const TileRef& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TileRef* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Types.TileRef";
  }
  protected:
  explicit TileRef(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Types_2eproto);
    return ::descriptor_table_Types_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectPathFieldNumber = 1,
  };
  // .Types.Path ObjectPath = 1;
  bool has_objectpath() const;
  private:
  bool _internal_has_objectpath() const;
  public:
  void clear_objectpath();
  const ::Types::Path& objectpath() const;
  ::Types::Path* release_objectpath();
  ::Types::Path* mutable_objectpath();
  void set_allocated_objectpath(::Types::Path* objectpath);
  private:
  const ::Types::Path& _internal_objectpath() const;
  ::Types::Path* _internal_mutable_objectpath();
  public:
  void unsafe_arena_set_allocated_objectpath(
      ::Types::Path* objectpath);
  ::Types::Path* unsafe_arena_release_objectpath();

  // @@protoc_insertion_point(class_scope:Types.TileRef)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Types::Path* objectpath_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Types_2eproto;
};
// -------------------------------------------------------------------

class IntegerRef PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Types.IntegerRef) */ {
 public:
  inline IntegerRef() : IntegerRef(nullptr) {}
  virtual ~IntegerRef();

  IntegerRef(const IntegerRef& from);
  IntegerRef(IntegerRef&& from) noexcept
    : IntegerRef() {
    *this = ::std::move(from);
  }

  inline IntegerRef& operator=(const IntegerRef& from) {
    CopyFrom(from);
    return *this;
  }
  inline IntegerRef& operator=(IntegerRef&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const IntegerRef& default_instance();

  static inline const IntegerRef* internal_default_instance() {
    return reinterpret_cast<const IntegerRef*>(
               &_IntegerRef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(IntegerRef& a, IntegerRef& b) {
    a.Swap(&b);
  }
  inline void Swap(IntegerRef* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IntegerRef* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IntegerRef* New() const final {
    return CreateMaybeMessage<IntegerRef>(nullptr);
  }

  IntegerRef* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IntegerRef>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const IntegerRef& from);
  void MergeFrom(const IntegerRef& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IntegerRef* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Types.IntegerRef";
  }
  protected:
  explicit IntegerRef(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Types_2eproto);
    return ::descriptor_table_Types_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectPathFieldNumber = 1,
  };
  // .Types.Path ObjectPath = 1;
  bool has_objectpath() const;
  private:
  bool _internal_has_objectpath() const;
  public:
  void clear_objectpath();
  const ::Types::Path& objectpath() const;
  ::Types::Path* release_objectpath();
  ::Types::Path* mutable_objectpath();
  void set_allocated_objectpath(::Types::Path* objectpath);
  private:
  const ::Types::Path& _internal_objectpath() const;
  ::Types::Path* _internal_mutable_objectpath();
  public:
  void unsafe_arena_set_allocated_objectpath(
      ::Types::Path* objectpath);
  ::Types::Path* unsafe_arena_release_objectpath();

  // @@protoc_insertion_point(class_scope:Types.IntegerRef)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Types::Path* objectpath_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Types_2eproto;
};
// -------------------------------------------------------------------

class Vec2iRef PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Types.Vec2iRef) */ {
 public:
  inline Vec2iRef() : Vec2iRef(nullptr) {}
  virtual ~Vec2iRef();

  Vec2iRef(const Vec2iRef& from);
  Vec2iRef(Vec2iRef&& from) noexcept
    : Vec2iRef() {
    *this = ::std::move(from);
  }

  inline Vec2iRef& operator=(const Vec2iRef& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vec2iRef& operator=(Vec2iRef&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Vec2iRef& default_instance();

  static inline const Vec2iRef* internal_default_instance() {
    return reinterpret_cast<const Vec2iRef*>(
               &_Vec2iRef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Vec2iRef& a, Vec2iRef& b) {
    a.Swap(&b);
  }
  inline void Swap(Vec2iRef* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vec2iRef* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Vec2iRef* New() const final {
    return CreateMaybeMessage<Vec2iRef>(nullptr);
  }

  Vec2iRef* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Vec2iRef>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Vec2iRef& from);
  void MergeFrom(const Vec2iRef& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vec2iRef* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Types.Vec2iRef";
  }
  protected:
  explicit Vec2iRef(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Types_2eproto);
    return ::descriptor_table_Types_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectPathFieldNumber = 1,
  };
  // .Types.Path ObjectPath = 1;
  bool has_objectpath() const;
  private:
  bool _internal_has_objectpath() const;
  public:
  void clear_objectpath();
  const ::Types::Path& objectpath() const;
  ::Types::Path* release_objectpath();
  ::Types::Path* mutable_objectpath();
  void set_allocated_objectpath(::Types::Path* objectpath);
  private:
  const ::Types::Path& _internal_objectpath() const;
  ::Types::Path* _internal_mutable_objectpath();
  public:
  void unsafe_arena_set_allocated_objectpath(
      ::Types::Path* objectpath);
  ::Types::Path* unsafe_arena_release_objectpath();

  // @@protoc_insertion_point(class_scope:Types.Vec2iRef)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Types::Path* objectpath_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Types_2eproto;
};
// -------------------------------------------------------------------

class IntegerValue PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Types.IntegerValue) */ {
 public:
  inline IntegerValue() : IntegerValue(nullptr) {}
  virtual ~IntegerValue();

  IntegerValue(const IntegerValue& from);
  IntegerValue(IntegerValue&& from) noexcept
    : IntegerValue() {
    *this = ::std::move(from);
  }

  inline IntegerValue& operator=(const IntegerValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline IntegerValue& operator=(IntegerValue&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const IntegerValue& default_instance();

  enum IntValueCase {
    kValue = 1,
    kRef = 2,
    INT_VALUE_NOT_SET = 0,
  };

  static inline const IntegerValue* internal_default_instance() {
    return reinterpret_cast<const IntegerValue*>(
               &_IntegerValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(IntegerValue& a, IntegerValue& b) {
    a.Swap(&b);
  }
  inline void Swap(IntegerValue* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IntegerValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IntegerValue* New() const final {
    return CreateMaybeMessage<IntegerValue>(nullptr);
  }

  IntegerValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IntegerValue>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const IntegerValue& from);
  void MergeFrom(const IntegerValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IntegerValue* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Types.IntegerValue";
  }
  protected:
  explicit IntegerValue(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Types_2eproto);
    return ::descriptor_table_Types_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
    kRefFieldNumber = 2,
  };
  // .Types.Integer Value = 1;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::Types::Integer& value() const;
  ::Types::Integer* release_value();
  ::Types::Integer* mutable_value();
  void set_allocated_value(::Types::Integer* value);
  private:
  const ::Types::Integer& _internal_value() const;
  ::Types::Integer* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::Types::Integer* value);
  ::Types::Integer* unsafe_arena_release_value();

  // .Types.IntegerRef Ref = 2;
  bool has_ref() const;
  private:
  bool _internal_has_ref() const;
  public:
  void clear_ref();
  const ::Types::IntegerRef& ref() const;
  ::Types::IntegerRef* release_ref();
  ::Types::IntegerRef* mutable_ref();
  void set_allocated_ref(::Types::IntegerRef* ref);
  private:
  const ::Types::IntegerRef& _internal_ref() const;
  ::Types::IntegerRef* _internal_mutable_ref();
  public:
  void unsafe_arena_set_allocated_ref(
      ::Types::IntegerRef* ref);
  ::Types::IntegerRef* unsafe_arena_release_ref();

  void clear_int_value();
  IntValueCase int_value_case() const;
  // @@protoc_insertion_point(class_scope:Types.IntegerValue)
 private:
  class _Internal;
  void set_has_value();
  void set_has_ref();

  inline bool has_int_value() const;
  inline void clear_has_int_value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union IntValueUnion {
    IntValueUnion() {}
    ::Types::Integer* value_;
    ::Types::IntegerRef* ref_;
  } int_value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_Types_2eproto;
};
// -------------------------------------------------------------------

class Vec2iValue PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Types.Vec2iValue) */ {
 public:
  inline Vec2iValue() : Vec2iValue(nullptr) {}
  virtual ~Vec2iValue();

  Vec2iValue(const Vec2iValue& from);
  Vec2iValue(Vec2iValue&& from) noexcept
    : Vec2iValue() {
    *this = ::std::move(from);
  }

  inline Vec2iValue& operator=(const Vec2iValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vec2iValue& operator=(Vec2iValue&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Vec2iValue& default_instance();

  enum Vec2IValueCase {
    kValue = 1,
    kRef = 2,
    VEC2I_VALUE_NOT_SET = 0,
  };

  static inline const Vec2iValue* internal_default_instance() {
    return reinterpret_cast<const Vec2iValue*>(
               &_Vec2iValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Vec2iValue& a, Vec2iValue& b) {
    a.Swap(&b);
  }
  inline void Swap(Vec2iValue* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vec2iValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Vec2iValue* New() const final {
    return CreateMaybeMessage<Vec2iValue>(nullptr);
  }

  Vec2iValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Vec2iValue>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Vec2iValue& from);
  void MergeFrom(const Vec2iValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vec2iValue* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Types.Vec2iValue";
  }
  protected:
  explicit Vec2iValue(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Types_2eproto);
    return ::descriptor_table_Types_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
    kRefFieldNumber = 2,
  };
  // .Types.Vec2i Value = 1;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::Types::Vec2i& value() const;
  ::Types::Vec2i* release_value();
  ::Types::Vec2i* mutable_value();
  void set_allocated_value(::Types::Vec2i* value);
  private:
  const ::Types::Vec2i& _internal_value() const;
  ::Types::Vec2i* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::Types::Vec2i* value);
  ::Types::Vec2i* unsafe_arena_release_value();

  // .Types.Vec2iRef Ref = 2;
  bool has_ref() const;
  private:
  bool _internal_has_ref() const;
  public:
  void clear_ref();
  const ::Types::Vec2iRef& ref() const;
  ::Types::Vec2iRef* release_ref();
  ::Types::Vec2iRef* mutable_ref();
  void set_allocated_ref(::Types::Vec2iRef* ref);
  private:
  const ::Types::Vec2iRef& _internal_ref() const;
  ::Types::Vec2iRef* _internal_mutable_ref();
  public:
  void unsafe_arena_set_allocated_ref(
      ::Types::Vec2iRef* ref);
  ::Types::Vec2iRef* unsafe_arena_release_ref();

  void clear_vec2i_value();
  Vec2IValueCase vec2i_value_case() const;
  // @@protoc_insertion_point(class_scope:Types.Vec2iValue)
 private:
  class _Internal;
  void set_has_value();
  void set_has_ref();

  inline bool has_vec2i_value() const;
  inline void clear_has_vec2i_value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union Vec2IValueUnion {
    Vec2IValueUnion() {}
    ::Types::Vec2i* value_;
    ::Types::Vec2iRef* ref_;
  } vec2i_value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_Types_2eproto;
};
// -------------------------------------------------------------------

class EntityRef PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Types.EntityRef) */ {
 public:
  inline EntityRef() : EntityRef(nullptr) {}
  virtual ~EntityRef();

  EntityRef(const EntityRef& from);
  EntityRef(EntityRef&& from) noexcept
    : EntityRef() {
    *this = ::std::move(from);
  }

  inline EntityRef& operator=(const EntityRef& from) {
    CopyFrom(from);
    return *this;
  }
  inline EntityRef& operator=(EntityRef&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EntityRef& default_instance();

  enum EntityRefCase {
    kInteger = 1,
    kVec2I = 2,
    kPlayer = 3,
    kCard = 4,
    kTile = 5,
    ENTITY_REF_NOT_SET = 0,
  };

  static inline const EntityRef* internal_default_instance() {
    return reinterpret_cast<const EntityRef*>(
               &_EntityRef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(EntityRef& a, EntityRef& b) {
    a.Swap(&b);
  }
  inline void Swap(EntityRef* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EntityRef* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EntityRef* New() const final {
    return CreateMaybeMessage<EntityRef>(nullptr);
  }

  EntityRef* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EntityRef>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EntityRef& from);
  void MergeFrom(const EntityRef& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EntityRef* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Types.EntityRef";
  }
  protected:
  explicit EntityRef(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Types_2eproto);
    return ::descriptor_table_Types_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIntegerFieldNumber = 1,
    kVec2IFieldNumber = 2,
    kPlayerFieldNumber = 3,
    kCardFieldNumber = 4,
    kTileFieldNumber = 5,
  };
  // .Types.IntegerRef Integer = 1;
  bool has_integer() const;
  private:
  bool _internal_has_integer() const;
  public:
  void clear_integer();
  const ::Types::IntegerRef& integer() const;
  ::Types::IntegerRef* release_integer();
  ::Types::IntegerRef* mutable_integer();
  void set_allocated_integer(::Types::IntegerRef* integer);
  private:
  const ::Types::IntegerRef& _internal_integer() const;
  ::Types::IntegerRef* _internal_mutable_integer();
  public:
  void unsafe_arena_set_allocated_integer(
      ::Types::IntegerRef* integer);
  ::Types::IntegerRef* unsafe_arena_release_integer();

  // .Types.Vec2iRef Vec2i = 2;
  bool has_vec2i() const;
  private:
  bool _internal_has_vec2i() const;
  public:
  void clear_vec2i();
  const ::Types::Vec2iRef& vec2i() const;
  ::Types::Vec2iRef* release_vec2i();
  ::Types::Vec2iRef* mutable_vec2i();
  void set_allocated_vec2i(::Types::Vec2iRef* vec2i);
  private:
  const ::Types::Vec2iRef& _internal_vec2i() const;
  ::Types::Vec2iRef* _internal_mutable_vec2i();
  public:
  void unsafe_arena_set_allocated_vec2i(
      ::Types::Vec2iRef* vec2i);
  ::Types::Vec2iRef* unsafe_arena_release_vec2i();

  // .Types.PlayerRef Player = 3;
  bool has_player() const;
  private:
  bool _internal_has_player() const;
  public:
  void clear_player();
  const ::Types::PlayerRef& player() const;
  ::Types::PlayerRef* release_player();
  ::Types::PlayerRef* mutable_player();
  void set_allocated_player(::Types::PlayerRef* player);
  private:
  const ::Types::PlayerRef& _internal_player() const;
  ::Types::PlayerRef* _internal_mutable_player();
  public:
  void unsafe_arena_set_allocated_player(
      ::Types::PlayerRef* player);
  ::Types::PlayerRef* unsafe_arena_release_player();

  // .Types.CardRef Card = 4;
  bool has_card() const;
  private:
  bool _internal_has_card() const;
  public:
  void clear_card();
  const ::Types::CardRef& card() const;
  ::Types::CardRef* release_card();
  ::Types::CardRef* mutable_card();
  void set_allocated_card(::Types::CardRef* card);
  private:
  const ::Types::CardRef& _internal_card() const;
  ::Types::CardRef* _internal_mutable_card();
  public:
  void unsafe_arena_set_allocated_card(
      ::Types::CardRef* card);
  ::Types::CardRef* unsafe_arena_release_card();

  // .Types.TileRef Tile = 5;
  bool has_tile() const;
  private:
  bool _internal_has_tile() const;
  public:
  void clear_tile();
  const ::Types::TileRef& tile() const;
  ::Types::TileRef* release_tile();
  ::Types::TileRef* mutable_tile();
  void set_allocated_tile(::Types::TileRef* tile);
  private:
  const ::Types::TileRef& _internal_tile() const;
  ::Types::TileRef* _internal_mutable_tile();
  public:
  void unsafe_arena_set_allocated_tile(
      ::Types::TileRef* tile);
  ::Types::TileRef* unsafe_arena_release_tile();

  void clear_entity_ref();
  EntityRefCase entity_ref_case() const;
  // @@protoc_insertion_point(class_scope:Types.EntityRef)
 private:
  class _Internal;
  void set_has_integer();
  void set_has_vec2i();
  void set_has_player();
  void set_has_card();
  void set_has_tile();

  inline bool has_entity_ref() const;
  inline void clear_has_entity_ref();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union EntityRefUnion {
    EntityRefUnion() {}
    ::Types::IntegerRef* integer_;
    ::Types::Vec2iRef* vec2i_;
    ::Types::PlayerRef* player_;
    ::Types::CardRef* card_;
    ::Types::TileRef* tile_;
  } entity_ref_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_Types_2eproto;
};
// -------------------------------------------------------------------

class EntityValue PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Types.EntityValue) */ {
 public:
  inline EntityValue() : EntityValue(nullptr) {}
  virtual ~EntityValue();

  EntityValue(const EntityValue& from);
  EntityValue(EntityValue&& from) noexcept
    : EntityValue() {
    *this = ::std::move(from);
  }

  inline EntityValue& operator=(const EntityValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline EntityValue& operator=(EntityValue&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EntityValue& default_instance();

  enum EntityValCase {
    kInteger = 1,
    kVec2I = 2,
    kPlayer = 3,
    kCard = 4,
    kTile = 5,
    kTerrainValue = 6,
    ENTITY_VAL_NOT_SET = 0,
  };

  static inline const EntityValue* internal_default_instance() {
    return reinterpret_cast<const EntityValue*>(
               &_EntityValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(EntityValue& a, EntityValue& b) {
    a.Swap(&b);
  }
  inline void Swap(EntityValue* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EntityValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EntityValue* New() const final {
    return CreateMaybeMessage<EntityValue>(nullptr);
  }

  EntityValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EntityValue>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EntityValue& from);
  void MergeFrom(const EntityValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EntityValue* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Types.EntityValue";
  }
  protected:
  explicit EntityValue(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Types_2eproto);
    return ::descriptor_table_Types_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIntegerFieldNumber = 1,
    kVec2IFieldNumber = 2,
    kPlayerFieldNumber = 3,
    kCardFieldNumber = 4,
    kTileFieldNumber = 5,
    kTerrainValueFieldNumber = 6,
  };
  // .Types.IntegerValue Integer = 1;
  bool has_integer() const;
  private:
  bool _internal_has_integer() const;
  public:
  void clear_integer();
  const ::Types::IntegerValue& integer() const;
  ::Types::IntegerValue* release_integer();
  ::Types::IntegerValue* mutable_integer();
  void set_allocated_integer(::Types::IntegerValue* integer);
  private:
  const ::Types::IntegerValue& _internal_integer() const;
  ::Types::IntegerValue* _internal_mutable_integer();
  public:
  void unsafe_arena_set_allocated_integer(
      ::Types::IntegerValue* integer);
  ::Types::IntegerValue* unsafe_arena_release_integer();

  // .Types.Vec2iValue Vec2i = 2;
  bool has_vec2i() const;
  private:
  bool _internal_has_vec2i() const;
  public:
  void clear_vec2i();
  const ::Types::Vec2iValue& vec2i() const;
  ::Types::Vec2iValue* release_vec2i();
  ::Types::Vec2iValue* mutable_vec2i();
  void set_allocated_vec2i(::Types::Vec2iValue* vec2i);
  private:
  const ::Types::Vec2iValue& _internal_vec2i() const;
  ::Types::Vec2iValue* _internal_mutable_vec2i();
  public:
  void unsafe_arena_set_allocated_vec2i(
      ::Types::Vec2iValue* vec2i);
  ::Types::Vec2iValue* unsafe_arena_release_vec2i();

  // .Types.PlayerRef Player = 3;
  bool has_player() const;
  private:
  bool _internal_has_player() const;
  public:
  void clear_player();
  const ::Types::PlayerRef& player() const;
  ::Types::PlayerRef* release_player();
  ::Types::PlayerRef* mutable_player();
  void set_allocated_player(::Types::PlayerRef* player);
  private:
  const ::Types::PlayerRef& _internal_player() const;
  ::Types::PlayerRef* _internal_mutable_player();
  public:
  void unsafe_arena_set_allocated_player(
      ::Types::PlayerRef* player);
  ::Types::PlayerRef* unsafe_arena_release_player();

  // .Types.CardRef Card = 4;
  bool has_card() const;
  private:
  bool _internal_has_card() const;
  public:
  void clear_card();
  const ::Types::CardRef& card() const;
  ::Types::CardRef* release_card();
  ::Types::CardRef* mutable_card();
  void set_allocated_card(::Types::CardRef* card);
  private:
  const ::Types::CardRef& _internal_card() const;
  ::Types::CardRef* _internal_mutable_card();
  public:
  void unsafe_arena_set_allocated_card(
      ::Types::CardRef* card);
  ::Types::CardRef* unsafe_arena_release_card();

  // .Types.TileRef Tile = 5;
  bool has_tile() const;
  private:
  bool _internal_has_tile() const;
  public:
  void clear_tile();
  const ::Types::TileRef& tile() const;
  ::Types::TileRef* release_tile();
  ::Types::TileRef* mutable_tile();
  void set_allocated_tile(::Types::TileRef* tile);
  private:
  const ::Types::TileRef& _internal_tile() const;
  ::Types::TileRef* _internal_mutable_tile();
  public:
  void unsafe_arena_set_allocated_tile(
      ::Types::TileRef* tile);
  ::Types::TileRef* unsafe_arena_release_tile();

  // .Types.TerrainType TerrainValue = 6;
  private:
  bool _internal_has_terrainvalue() const;
  public:
  void clear_terrainvalue();
  ::Types::TerrainType terrainvalue() const;
  void set_terrainvalue(::Types::TerrainType value);
  private:
  ::Types::TerrainType _internal_terrainvalue() const;
  void _internal_set_terrainvalue(::Types::TerrainType value);
  public:

  void clear_entity_val();
  EntityValCase entity_val_case() const;
  // @@protoc_insertion_point(class_scope:Types.EntityValue)
 private:
  class _Internal;
  void set_has_integer();
  void set_has_vec2i();
  void set_has_player();
  void set_has_card();
  void set_has_tile();
  void set_has_terrainvalue();

  inline bool has_entity_val() const;
  inline void clear_has_entity_val();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union EntityValUnion {
    EntityValUnion() {}
    ::Types::IntegerValue* integer_;
    ::Types::Vec2iValue* vec2i_;
    ::Types::PlayerRef* player_;
    ::Types::CardRef* card_;
    ::Types::TileRef* tile_;
    int terrainvalue_;
  } entity_val_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_Types_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Path_FieldIndecies

// repeated int32 Indecies = 1;
inline int Path_FieldIndecies::_internal_indecies_size() const {
  return indecies_.size();
}
inline int Path_FieldIndecies::indecies_size() const {
  return _internal_indecies_size();
}
inline void Path_FieldIndecies::clear_indecies() {
  indecies_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Path_FieldIndecies::_internal_indecies(int index) const {
  return indecies_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Path_FieldIndecies::indecies(int index) const {
  // @@protoc_insertion_point(field_get:Types.Path.FieldIndecies.Indecies)
  return _internal_indecies(index);
}
inline void Path_FieldIndecies::set_indecies(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  indecies_.Set(index, value);
  // @@protoc_insertion_point(field_set:Types.Path.FieldIndecies.Indecies)
}
inline void Path_FieldIndecies::_internal_add_indecies(::PROTOBUF_NAMESPACE_ID::int32 value) {
  indecies_.Add(value);
}
inline void Path_FieldIndecies::add_indecies(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_indecies(value);
  // @@protoc_insertion_point(field_add:Types.Path.FieldIndecies.Indecies)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
Path_FieldIndecies::_internal_indecies() const {
  return indecies_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
Path_FieldIndecies::indecies() const {
  // @@protoc_insertion_point(field_list:Types.Path.FieldIndecies.Indecies)
  return _internal_indecies();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
Path_FieldIndecies::_internal_mutable_indecies() {
  return &indecies_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
Path_FieldIndecies::mutable_indecies() {
  // @@protoc_insertion_point(field_mutable_list:Types.Path.FieldIndecies.Indecies)
  return _internal_mutable_indecies();
}

// -------------------------------------------------------------------

// Path

// .Types.Path.FieldIndecies Fields = 1;
inline bool Path::_internal_has_fields() const {
  return this != internal_default_instance() && fields_ != nullptr;
}
inline bool Path::has_fields() const {
  return _internal_has_fields();
}
inline void Path::clear_fields() {
  if (GetArena() == nullptr && fields_ != nullptr) {
    delete fields_;
  }
  fields_ = nullptr;
}
inline const ::Types::Path_FieldIndecies& Path::_internal_fields() const {
  const ::Types::Path_FieldIndecies* p = fields_;
  return p != nullptr ? *p : reinterpret_cast<const ::Types::Path_FieldIndecies&>(
      ::Types::_Path_FieldIndecies_default_instance_);
}
inline const ::Types::Path_FieldIndecies& Path::fields() const {
  // @@protoc_insertion_point(field_get:Types.Path.Fields)
  return _internal_fields();
}
inline void Path::unsafe_arena_set_allocated_fields(
    ::Types::Path_FieldIndecies* fields) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fields_);
  }
  fields_ = fields;
  if (fields) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Types.Path.Fields)
}
inline ::Types::Path_FieldIndecies* Path::release_fields() {
  
  ::Types::Path_FieldIndecies* temp = fields_;
  fields_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Types::Path_FieldIndecies* Path::unsafe_arena_release_fields() {
  // @@protoc_insertion_point(field_release:Types.Path.Fields)
  
  ::Types::Path_FieldIndecies* temp = fields_;
  fields_ = nullptr;
  return temp;
}
inline ::Types::Path_FieldIndecies* Path::_internal_mutable_fields() {
  
  if (fields_ == nullptr) {
    auto* p = CreateMaybeMessage<::Types::Path_FieldIndecies>(GetArena());
    fields_ = p;
  }
  return fields_;
}
inline ::Types::Path_FieldIndecies* Path::mutable_fields() {
  // @@protoc_insertion_point(field_mutable:Types.Path.Fields)
  return _internal_mutable_fields();
}
inline void Path::set_allocated_fields(::Types::Path_FieldIndecies* fields) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete fields_;
  }
  if (fields) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(fields);
    if (message_arena != submessage_arena) {
      fields = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fields, submessage_arena);
    }
    
  } else {
    
  }
  fields_ = fields;
  // @@protoc_insertion_point(field_set_allocated:Types.Path.Fields)
}

// string FullPath = 2;
inline void Path::clear_fullpath() {
  fullpath_.ClearToEmpty();
}
inline const std::string& Path::fullpath() const {
  // @@protoc_insertion_point(field_get:Types.Path.FullPath)
  return _internal_fullpath();
}
inline void Path::set_fullpath(const std::string& value) {
  _internal_set_fullpath(value);
  // @@protoc_insertion_point(field_set:Types.Path.FullPath)
}
inline std::string* Path::mutable_fullpath() {
  // @@protoc_insertion_point(field_mutable:Types.Path.FullPath)
  return _internal_mutable_fullpath();
}
inline const std::string& Path::_internal_fullpath() const {
  return fullpath_.Get();
}
inline void Path::_internal_set_fullpath(const std::string& value) {
  
  fullpath_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Path::set_fullpath(std::string&& value) {
  
  fullpath_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:Types.Path.FullPath)
}
inline void Path::set_fullpath(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  fullpath_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:Types.Path.FullPath)
}
inline void Path::set_fullpath(const char* value,
    size_t size) {
  
  fullpath_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:Types.Path.FullPath)
}
inline std::string* Path::_internal_mutable_fullpath() {
  
  return fullpath_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Path::release_fullpath() {
  // @@protoc_insertion_point(field_release:Types.Path.FullPath)
  return fullpath_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Path::set_allocated_fullpath(std::string* fullpath) {
  if (fullpath != nullptr) {
    
  } else {
    
  }
  fullpath_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), fullpath,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:Types.Path.FullPath)
}

// -------------------------------------------------------------------

// Integer

// int32 Value = 1;
inline void Integer::clear_value() {
  value_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Integer::_internal_value() const {
  return value_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Integer::value() const {
  // @@protoc_insertion_point(field_get:Types.Integer.Value)
  return _internal_value();
}
inline void Integer::_internal_set_value(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  value_ = value;
}
inline void Integer::set_value(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:Types.Integer.Value)
}

// -------------------------------------------------------------------

// Vec2i

// int32 X = 1;
inline void Vec2i::clear_x() {
  x_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Vec2i::_internal_x() const {
  return x_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Vec2i::x() const {
  // @@protoc_insertion_point(field_get:Types.Vec2i.X)
  return _internal_x();
}
inline void Vec2i::_internal_set_x(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  x_ = value;
}
inline void Vec2i::set_x(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:Types.Vec2i.X)
}

// int32 Y = 2;
inline void Vec2i::clear_y() {
  y_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Vec2i::_internal_y() const {
  return y_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Vec2i::y() const {
  // @@protoc_insertion_point(field_get:Types.Vec2i.Y)
  return _internal_y();
}
inline void Vec2i::_internal_set_y(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  y_ = value;
}
inline void Vec2i::set_y(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:Types.Vec2i.Y)
}

// -------------------------------------------------------------------

// PlayerRef

// .Types.Path ObjectPath = 1;
inline bool PlayerRef::_internal_has_objectpath() const {
  return this != internal_default_instance() && objectpath_ != nullptr;
}
inline bool PlayerRef::has_objectpath() const {
  return _internal_has_objectpath();
}
inline void PlayerRef::clear_objectpath() {
  if (GetArena() == nullptr && objectpath_ != nullptr) {
    delete objectpath_;
  }
  objectpath_ = nullptr;
}
inline const ::Types::Path& PlayerRef::_internal_objectpath() const {
  const ::Types::Path* p = objectpath_;
  return p != nullptr ? *p : reinterpret_cast<const ::Types::Path&>(
      ::Types::_Path_default_instance_);
}
inline const ::Types::Path& PlayerRef::objectpath() const {
  // @@protoc_insertion_point(field_get:Types.PlayerRef.ObjectPath)
  return _internal_objectpath();
}
inline void PlayerRef::unsafe_arena_set_allocated_objectpath(
    ::Types::Path* objectpath) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(objectpath_);
  }
  objectpath_ = objectpath;
  if (objectpath) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Types.PlayerRef.ObjectPath)
}
inline ::Types::Path* PlayerRef::release_objectpath() {
  
  ::Types::Path* temp = objectpath_;
  objectpath_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Types::Path* PlayerRef::unsafe_arena_release_objectpath() {
  // @@protoc_insertion_point(field_release:Types.PlayerRef.ObjectPath)
  
  ::Types::Path* temp = objectpath_;
  objectpath_ = nullptr;
  return temp;
}
inline ::Types::Path* PlayerRef::_internal_mutable_objectpath() {
  
  if (objectpath_ == nullptr) {
    auto* p = CreateMaybeMessage<::Types::Path>(GetArena());
    objectpath_ = p;
  }
  return objectpath_;
}
inline ::Types::Path* PlayerRef::mutable_objectpath() {
  // @@protoc_insertion_point(field_mutable:Types.PlayerRef.ObjectPath)
  return _internal_mutable_objectpath();
}
inline void PlayerRef::set_allocated_objectpath(::Types::Path* objectpath) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete objectpath_;
  }
  if (objectpath) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(objectpath);
    if (message_arena != submessage_arena) {
      objectpath = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, objectpath, submessage_arena);
    }
    
  } else {
    
  }
  objectpath_ = objectpath;
  // @@protoc_insertion_point(field_set_allocated:Types.PlayerRef.ObjectPath)
}

// -------------------------------------------------------------------

// CardRef

// .Types.Path ObjectPath = 1;
inline bool CardRef::_internal_has_objectpath() const {
  return this != internal_default_instance() && objectpath_ != nullptr;
}
inline bool CardRef::has_objectpath() const {
  return _internal_has_objectpath();
}
inline void CardRef::clear_objectpath() {
  if (GetArena() == nullptr && objectpath_ != nullptr) {
    delete objectpath_;
  }
  objectpath_ = nullptr;
}
inline const ::Types::Path& CardRef::_internal_objectpath() const {
  const ::Types::Path* p = objectpath_;
  return p != nullptr ? *p : reinterpret_cast<const ::Types::Path&>(
      ::Types::_Path_default_instance_);
}
inline const ::Types::Path& CardRef::objectpath() const {
  // @@protoc_insertion_point(field_get:Types.CardRef.ObjectPath)
  return _internal_objectpath();
}
inline void CardRef::unsafe_arena_set_allocated_objectpath(
    ::Types::Path* objectpath) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(objectpath_);
  }
  objectpath_ = objectpath;
  if (objectpath) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Types.CardRef.ObjectPath)
}
inline ::Types::Path* CardRef::release_objectpath() {
  
  ::Types::Path* temp = objectpath_;
  objectpath_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Types::Path* CardRef::unsafe_arena_release_objectpath() {
  // @@protoc_insertion_point(field_release:Types.CardRef.ObjectPath)
  
  ::Types::Path* temp = objectpath_;
  objectpath_ = nullptr;
  return temp;
}
inline ::Types::Path* CardRef::_internal_mutable_objectpath() {
  
  if (objectpath_ == nullptr) {
    auto* p = CreateMaybeMessage<::Types::Path>(GetArena());
    objectpath_ = p;
  }
  return objectpath_;
}
inline ::Types::Path* CardRef::mutable_objectpath() {
  // @@protoc_insertion_point(field_mutable:Types.CardRef.ObjectPath)
  return _internal_mutable_objectpath();
}
inline void CardRef::set_allocated_objectpath(::Types::Path* objectpath) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete objectpath_;
  }
  if (objectpath) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(objectpath);
    if (message_arena != submessage_arena) {
      objectpath = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, objectpath, submessage_arena);
    }
    
  } else {
    
  }
  objectpath_ = objectpath;
  // @@protoc_insertion_point(field_set_allocated:Types.CardRef.ObjectPath)
}

// -------------------------------------------------------------------

// TileRef

// .Types.Path ObjectPath = 1;
inline bool TileRef::_internal_has_objectpath() const {
  return this != internal_default_instance() && objectpath_ != nullptr;
}
inline bool TileRef::has_objectpath() const {
  return _internal_has_objectpath();
}
inline void TileRef::clear_objectpath() {
  if (GetArena() == nullptr && objectpath_ != nullptr) {
    delete objectpath_;
  }
  objectpath_ = nullptr;
}
inline const ::Types::Path& TileRef::_internal_objectpath() const {
  const ::Types::Path* p = objectpath_;
  return p != nullptr ? *p : reinterpret_cast<const ::Types::Path&>(
      ::Types::_Path_default_instance_);
}
inline const ::Types::Path& TileRef::objectpath() const {
  // @@protoc_insertion_point(field_get:Types.TileRef.ObjectPath)
  return _internal_objectpath();
}
inline void TileRef::unsafe_arena_set_allocated_objectpath(
    ::Types::Path* objectpath) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(objectpath_);
  }
  objectpath_ = objectpath;
  if (objectpath) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Types.TileRef.ObjectPath)
}
inline ::Types::Path* TileRef::release_objectpath() {
  
  ::Types::Path* temp = objectpath_;
  objectpath_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Types::Path* TileRef::unsafe_arena_release_objectpath() {
  // @@protoc_insertion_point(field_release:Types.TileRef.ObjectPath)
  
  ::Types::Path* temp = objectpath_;
  objectpath_ = nullptr;
  return temp;
}
inline ::Types::Path* TileRef::_internal_mutable_objectpath() {
  
  if (objectpath_ == nullptr) {
    auto* p = CreateMaybeMessage<::Types::Path>(GetArena());
    objectpath_ = p;
  }
  return objectpath_;
}
inline ::Types::Path* TileRef::mutable_objectpath() {
  // @@protoc_insertion_point(field_mutable:Types.TileRef.ObjectPath)
  return _internal_mutable_objectpath();
}
inline void TileRef::set_allocated_objectpath(::Types::Path* objectpath) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete objectpath_;
  }
  if (objectpath) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(objectpath);
    if (message_arena != submessage_arena) {
      objectpath = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, objectpath, submessage_arena);
    }
    
  } else {
    
  }
  objectpath_ = objectpath;
  // @@protoc_insertion_point(field_set_allocated:Types.TileRef.ObjectPath)
}

// -------------------------------------------------------------------

// IntegerRef

// .Types.Path ObjectPath = 1;
inline bool IntegerRef::_internal_has_objectpath() const {
  return this != internal_default_instance() && objectpath_ != nullptr;
}
inline bool IntegerRef::has_objectpath() const {
  return _internal_has_objectpath();
}
inline void IntegerRef::clear_objectpath() {
  if (GetArena() == nullptr && objectpath_ != nullptr) {
    delete objectpath_;
  }
  objectpath_ = nullptr;
}
inline const ::Types::Path& IntegerRef::_internal_objectpath() const {
  const ::Types::Path* p = objectpath_;
  return p != nullptr ? *p : reinterpret_cast<const ::Types::Path&>(
      ::Types::_Path_default_instance_);
}
inline const ::Types::Path& IntegerRef::objectpath() const {
  // @@protoc_insertion_point(field_get:Types.IntegerRef.ObjectPath)
  return _internal_objectpath();
}
inline void IntegerRef::unsafe_arena_set_allocated_objectpath(
    ::Types::Path* objectpath) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(objectpath_);
  }
  objectpath_ = objectpath;
  if (objectpath) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Types.IntegerRef.ObjectPath)
}
inline ::Types::Path* IntegerRef::release_objectpath() {
  
  ::Types::Path* temp = objectpath_;
  objectpath_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Types::Path* IntegerRef::unsafe_arena_release_objectpath() {
  // @@protoc_insertion_point(field_release:Types.IntegerRef.ObjectPath)
  
  ::Types::Path* temp = objectpath_;
  objectpath_ = nullptr;
  return temp;
}
inline ::Types::Path* IntegerRef::_internal_mutable_objectpath() {
  
  if (objectpath_ == nullptr) {
    auto* p = CreateMaybeMessage<::Types::Path>(GetArena());
    objectpath_ = p;
  }
  return objectpath_;
}
inline ::Types::Path* IntegerRef::mutable_objectpath() {
  // @@protoc_insertion_point(field_mutable:Types.IntegerRef.ObjectPath)
  return _internal_mutable_objectpath();
}
inline void IntegerRef::set_allocated_objectpath(::Types::Path* objectpath) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete objectpath_;
  }
  if (objectpath) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(objectpath);
    if (message_arena != submessage_arena) {
      objectpath = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, objectpath, submessage_arena);
    }
    
  } else {
    
  }
  objectpath_ = objectpath;
  // @@protoc_insertion_point(field_set_allocated:Types.IntegerRef.ObjectPath)
}

// -------------------------------------------------------------------

// Vec2iRef

// .Types.Path ObjectPath = 1;
inline bool Vec2iRef::_internal_has_objectpath() const {
  return this != internal_default_instance() && objectpath_ != nullptr;
}
inline bool Vec2iRef::has_objectpath() const {
  return _internal_has_objectpath();
}
inline void Vec2iRef::clear_objectpath() {
  if (GetArena() == nullptr && objectpath_ != nullptr) {
    delete objectpath_;
  }
  objectpath_ = nullptr;
}
inline const ::Types::Path& Vec2iRef::_internal_objectpath() const {
  const ::Types::Path* p = objectpath_;
  return p != nullptr ? *p : reinterpret_cast<const ::Types::Path&>(
      ::Types::_Path_default_instance_);
}
inline const ::Types::Path& Vec2iRef::objectpath() const {
  // @@protoc_insertion_point(field_get:Types.Vec2iRef.ObjectPath)
  return _internal_objectpath();
}
inline void Vec2iRef::unsafe_arena_set_allocated_objectpath(
    ::Types::Path* objectpath) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(objectpath_);
  }
  objectpath_ = objectpath;
  if (objectpath) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Types.Vec2iRef.ObjectPath)
}
inline ::Types::Path* Vec2iRef::release_objectpath() {
  
  ::Types::Path* temp = objectpath_;
  objectpath_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Types::Path* Vec2iRef::unsafe_arena_release_objectpath() {
  // @@protoc_insertion_point(field_release:Types.Vec2iRef.ObjectPath)
  
  ::Types::Path* temp = objectpath_;
  objectpath_ = nullptr;
  return temp;
}
inline ::Types::Path* Vec2iRef::_internal_mutable_objectpath() {
  
  if (objectpath_ == nullptr) {
    auto* p = CreateMaybeMessage<::Types::Path>(GetArena());
    objectpath_ = p;
  }
  return objectpath_;
}
inline ::Types::Path* Vec2iRef::mutable_objectpath() {
  // @@protoc_insertion_point(field_mutable:Types.Vec2iRef.ObjectPath)
  return _internal_mutable_objectpath();
}
inline void Vec2iRef::set_allocated_objectpath(::Types::Path* objectpath) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete objectpath_;
  }
  if (objectpath) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(objectpath);
    if (message_arena != submessage_arena) {
      objectpath = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, objectpath, submessage_arena);
    }
    
  } else {
    
  }
  objectpath_ = objectpath;
  // @@protoc_insertion_point(field_set_allocated:Types.Vec2iRef.ObjectPath)
}

// -------------------------------------------------------------------

// IntegerValue

// .Types.Integer Value = 1;
inline bool IntegerValue::_internal_has_value() const {
  return int_value_case() == kValue;
}
inline bool IntegerValue::has_value() const {
  return _internal_has_value();
}
inline void IntegerValue::set_has_value() {
  _oneof_case_[0] = kValue;
}
inline void IntegerValue::clear_value() {
  if (_internal_has_value()) {
    if (GetArena() == nullptr) {
      delete int_value_.value_;
    }
    clear_has_int_value();
  }
}
inline ::Types::Integer* IntegerValue::release_value() {
  // @@protoc_insertion_point(field_release:Types.IntegerValue.Value)
  if (_internal_has_value()) {
    clear_has_int_value();
      ::Types::Integer* temp = int_value_.value_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    int_value_.value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Types::Integer& IntegerValue::_internal_value() const {
  return _internal_has_value()
      ? *int_value_.value_
      : reinterpret_cast< ::Types::Integer&>(::Types::_Integer_default_instance_);
}
inline const ::Types::Integer& IntegerValue::value() const {
  // @@protoc_insertion_point(field_get:Types.IntegerValue.Value)
  return _internal_value();
}
inline ::Types::Integer* IntegerValue::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Types.IntegerValue.Value)
  if (_internal_has_value()) {
    clear_has_int_value();
    ::Types::Integer* temp = int_value_.value_;
    int_value_.value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void IntegerValue::unsafe_arena_set_allocated_value(::Types::Integer* value) {
  clear_int_value();
  if (value) {
    set_has_value();
    int_value_.value_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Types.IntegerValue.Value)
}
inline ::Types::Integer* IntegerValue::_internal_mutable_value() {
  if (!_internal_has_value()) {
    clear_int_value();
    set_has_value();
    int_value_.value_ = CreateMaybeMessage< ::Types::Integer >(GetArena());
  }
  return int_value_.value_;
}
inline ::Types::Integer* IntegerValue::mutable_value() {
  // @@protoc_insertion_point(field_mutable:Types.IntegerValue.Value)
  return _internal_mutable_value();
}

// .Types.IntegerRef Ref = 2;
inline bool IntegerValue::_internal_has_ref() const {
  return int_value_case() == kRef;
}
inline bool IntegerValue::has_ref() const {
  return _internal_has_ref();
}
inline void IntegerValue::set_has_ref() {
  _oneof_case_[0] = kRef;
}
inline void IntegerValue::clear_ref() {
  if (_internal_has_ref()) {
    if (GetArena() == nullptr) {
      delete int_value_.ref_;
    }
    clear_has_int_value();
  }
}
inline ::Types::IntegerRef* IntegerValue::release_ref() {
  // @@protoc_insertion_point(field_release:Types.IntegerValue.Ref)
  if (_internal_has_ref()) {
    clear_has_int_value();
      ::Types::IntegerRef* temp = int_value_.ref_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    int_value_.ref_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Types::IntegerRef& IntegerValue::_internal_ref() const {
  return _internal_has_ref()
      ? *int_value_.ref_
      : reinterpret_cast< ::Types::IntegerRef&>(::Types::_IntegerRef_default_instance_);
}
inline const ::Types::IntegerRef& IntegerValue::ref() const {
  // @@protoc_insertion_point(field_get:Types.IntegerValue.Ref)
  return _internal_ref();
}
inline ::Types::IntegerRef* IntegerValue::unsafe_arena_release_ref() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Types.IntegerValue.Ref)
  if (_internal_has_ref()) {
    clear_has_int_value();
    ::Types::IntegerRef* temp = int_value_.ref_;
    int_value_.ref_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void IntegerValue::unsafe_arena_set_allocated_ref(::Types::IntegerRef* ref) {
  clear_int_value();
  if (ref) {
    set_has_ref();
    int_value_.ref_ = ref;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Types.IntegerValue.Ref)
}
inline ::Types::IntegerRef* IntegerValue::_internal_mutable_ref() {
  if (!_internal_has_ref()) {
    clear_int_value();
    set_has_ref();
    int_value_.ref_ = CreateMaybeMessage< ::Types::IntegerRef >(GetArena());
  }
  return int_value_.ref_;
}
inline ::Types::IntegerRef* IntegerValue::mutable_ref() {
  // @@protoc_insertion_point(field_mutable:Types.IntegerValue.Ref)
  return _internal_mutable_ref();
}

inline bool IntegerValue::has_int_value() const {
  return int_value_case() != INT_VALUE_NOT_SET;
}
inline void IntegerValue::clear_has_int_value() {
  _oneof_case_[0] = INT_VALUE_NOT_SET;
}
inline IntegerValue::IntValueCase IntegerValue::int_value_case() const {
  return IntegerValue::IntValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Vec2iValue

// .Types.Vec2i Value = 1;
inline bool Vec2iValue::_internal_has_value() const {
  return vec2i_value_case() == kValue;
}
inline bool Vec2iValue::has_value() const {
  return _internal_has_value();
}
inline void Vec2iValue::set_has_value() {
  _oneof_case_[0] = kValue;
}
inline void Vec2iValue::clear_value() {
  if (_internal_has_value()) {
    if (GetArena() == nullptr) {
      delete vec2i_value_.value_;
    }
    clear_has_vec2i_value();
  }
}
inline ::Types::Vec2i* Vec2iValue::release_value() {
  // @@protoc_insertion_point(field_release:Types.Vec2iValue.Value)
  if (_internal_has_value()) {
    clear_has_vec2i_value();
      ::Types::Vec2i* temp = vec2i_value_.value_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    vec2i_value_.value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Types::Vec2i& Vec2iValue::_internal_value() const {
  return _internal_has_value()
      ? *vec2i_value_.value_
      : reinterpret_cast< ::Types::Vec2i&>(::Types::_Vec2i_default_instance_);
}
inline const ::Types::Vec2i& Vec2iValue::value() const {
  // @@protoc_insertion_point(field_get:Types.Vec2iValue.Value)
  return _internal_value();
}
inline ::Types::Vec2i* Vec2iValue::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Types.Vec2iValue.Value)
  if (_internal_has_value()) {
    clear_has_vec2i_value();
    ::Types::Vec2i* temp = vec2i_value_.value_;
    vec2i_value_.value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Vec2iValue::unsafe_arena_set_allocated_value(::Types::Vec2i* value) {
  clear_vec2i_value();
  if (value) {
    set_has_value();
    vec2i_value_.value_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Types.Vec2iValue.Value)
}
inline ::Types::Vec2i* Vec2iValue::_internal_mutable_value() {
  if (!_internal_has_value()) {
    clear_vec2i_value();
    set_has_value();
    vec2i_value_.value_ = CreateMaybeMessage< ::Types::Vec2i >(GetArena());
  }
  return vec2i_value_.value_;
}
inline ::Types::Vec2i* Vec2iValue::mutable_value() {
  // @@protoc_insertion_point(field_mutable:Types.Vec2iValue.Value)
  return _internal_mutable_value();
}

// .Types.Vec2iRef Ref = 2;
inline bool Vec2iValue::_internal_has_ref() const {
  return vec2i_value_case() == kRef;
}
inline bool Vec2iValue::has_ref() const {
  return _internal_has_ref();
}
inline void Vec2iValue::set_has_ref() {
  _oneof_case_[0] = kRef;
}
inline void Vec2iValue::clear_ref() {
  if (_internal_has_ref()) {
    if (GetArena() == nullptr) {
      delete vec2i_value_.ref_;
    }
    clear_has_vec2i_value();
  }
}
inline ::Types::Vec2iRef* Vec2iValue::release_ref() {
  // @@protoc_insertion_point(field_release:Types.Vec2iValue.Ref)
  if (_internal_has_ref()) {
    clear_has_vec2i_value();
      ::Types::Vec2iRef* temp = vec2i_value_.ref_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    vec2i_value_.ref_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Types::Vec2iRef& Vec2iValue::_internal_ref() const {
  return _internal_has_ref()
      ? *vec2i_value_.ref_
      : reinterpret_cast< ::Types::Vec2iRef&>(::Types::_Vec2iRef_default_instance_);
}
inline const ::Types::Vec2iRef& Vec2iValue::ref() const {
  // @@protoc_insertion_point(field_get:Types.Vec2iValue.Ref)
  return _internal_ref();
}
inline ::Types::Vec2iRef* Vec2iValue::unsafe_arena_release_ref() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Types.Vec2iValue.Ref)
  if (_internal_has_ref()) {
    clear_has_vec2i_value();
    ::Types::Vec2iRef* temp = vec2i_value_.ref_;
    vec2i_value_.ref_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Vec2iValue::unsafe_arena_set_allocated_ref(::Types::Vec2iRef* ref) {
  clear_vec2i_value();
  if (ref) {
    set_has_ref();
    vec2i_value_.ref_ = ref;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Types.Vec2iValue.Ref)
}
inline ::Types::Vec2iRef* Vec2iValue::_internal_mutable_ref() {
  if (!_internal_has_ref()) {
    clear_vec2i_value();
    set_has_ref();
    vec2i_value_.ref_ = CreateMaybeMessage< ::Types::Vec2iRef >(GetArena());
  }
  return vec2i_value_.ref_;
}
inline ::Types::Vec2iRef* Vec2iValue::mutable_ref() {
  // @@protoc_insertion_point(field_mutable:Types.Vec2iValue.Ref)
  return _internal_mutable_ref();
}

inline bool Vec2iValue::has_vec2i_value() const {
  return vec2i_value_case() != VEC2I_VALUE_NOT_SET;
}
inline void Vec2iValue::clear_has_vec2i_value() {
  _oneof_case_[0] = VEC2I_VALUE_NOT_SET;
}
inline Vec2iValue::Vec2IValueCase Vec2iValue::vec2i_value_case() const {
  return Vec2iValue::Vec2IValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// EntityRef

// .Types.IntegerRef Integer = 1;
inline bool EntityRef::_internal_has_integer() const {
  return entity_ref_case() == kInteger;
}
inline bool EntityRef::has_integer() const {
  return _internal_has_integer();
}
inline void EntityRef::set_has_integer() {
  _oneof_case_[0] = kInteger;
}
inline void EntityRef::clear_integer() {
  if (_internal_has_integer()) {
    if (GetArena() == nullptr) {
      delete entity_ref_.integer_;
    }
    clear_has_entity_ref();
  }
}
inline ::Types::IntegerRef* EntityRef::release_integer() {
  // @@protoc_insertion_point(field_release:Types.EntityRef.Integer)
  if (_internal_has_integer()) {
    clear_has_entity_ref();
      ::Types::IntegerRef* temp = entity_ref_.integer_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    entity_ref_.integer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Types::IntegerRef& EntityRef::_internal_integer() const {
  return _internal_has_integer()
      ? *entity_ref_.integer_
      : reinterpret_cast< ::Types::IntegerRef&>(::Types::_IntegerRef_default_instance_);
}
inline const ::Types::IntegerRef& EntityRef::integer() const {
  // @@protoc_insertion_point(field_get:Types.EntityRef.Integer)
  return _internal_integer();
}
inline ::Types::IntegerRef* EntityRef::unsafe_arena_release_integer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Types.EntityRef.Integer)
  if (_internal_has_integer()) {
    clear_has_entity_ref();
    ::Types::IntegerRef* temp = entity_ref_.integer_;
    entity_ref_.integer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EntityRef::unsafe_arena_set_allocated_integer(::Types::IntegerRef* integer) {
  clear_entity_ref();
  if (integer) {
    set_has_integer();
    entity_ref_.integer_ = integer;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Types.EntityRef.Integer)
}
inline ::Types::IntegerRef* EntityRef::_internal_mutable_integer() {
  if (!_internal_has_integer()) {
    clear_entity_ref();
    set_has_integer();
    entity_ref_.integer_ = CreateMaybeMessage< ::Types::IntegerRef >(GetArena());
  }
  return entity_ref_.integer_;
}
inline ::Types::IntegerRef* EntityRef::mutable_integer() {
  // @@protoc_insertion_point(field_mutable:Types.EntityRef.Integer)
  return _internal_mutable_integer();
}

// .Types.Vec2iRef Vec2i = 2;
inline bool EntityRef::_internal_has_vec2i() const {
  return entity_ref_case() == kVec2I;
}
inline bool EntityRef::has_vec2i() const {
  return _internal_has_vec2i();
}
inline void EntityRef::set_has_vec2i() {
  _oneof_case_[0] = kVec2I;
}
inline void EntityRef::clear_vec2i() {
  if (_internal_has_vec2i()) {
    if (GetArena() == nullptr) {
      delete entity_ref_.vec2i_;
    }
    clear_has_entity_ref();
  }
}
inline ::Types::Vec2iRef* EntityRef::release_vec2i() {
  // @@protoc_insertion_point(field_release:Types.EntityRef.Vec2i)
  if (_internal_has_vec2i()) {
    clear_has_entity_ref();
      ::Types::Vec2iRef* temp = entity_ref_.vec2i_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    entity_ref_.vec2i_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Types::Vec2iRef& EntityRef::_internal_vec2i() const {
  return _internal_has_vec2i()
      ? *entity_ref_.vec2i_
      : reinterpret_cast< ::Types::Vec2iRef&>(::Types::_Vec2iRef_default_instance_);
}
inline const ::Types::Vec2iRef& EntityRef::vec2i() const {
  // @@protoc_insertion_point(field_get:Types.EntityRef.Vec2i)
  return _internal_vec2i();
}
inline ::Types::Vec2iRef* EntityRef::unsafe_arena_release_vec2i() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Types.EntityRef.Vec2i)
  if (_internal_has_vec2i()) {
    clear_has_entity_ref();
    ::Types::Vec2iRef* temp = entity_ref_.vec2i_;
    entity_ref_.vec2i_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EntityRef::unsafe_arena_set_allocated_vec2i(::Types::Vec2iRef* vec2i) {
  clear_entity_ref();
  if (vec2i) {
    set_has_vec2i();
    entity_ref_.vec2i_ = vec2i;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Types.EntityRef.Vec2i)
}
inline ::Types::Vec2iRef* EntityRef::_internal_mutable_vec2i() {
  if (!_internal_has_vec2i()) {
    clear_entity_ref();
    set_has_vec2i();
    entity_ref_.vec2i_ = CreateMaybeMessage< ::Types::Vec2iRef >(GetArena());
  }
  return entity_ref_.vec2i_;
}
inline ::Types::Vec2iRef* EntityRef::mutable_vec2i() {
  // @@protoc_insertion_point(field_mutable:Types.EntityRef.Vec2i)
  return _internal_mutable_vec2i();
}

// .Types.PlayerRef Player = 3;
inline bool EntityRef::_internal_has_player() const {
  return entity_ref_case() == kPlayer;
}
inline bool EntityRef::has_player() const {
  return _internal_has_player();
}
inline void EntityRef::set_has_player() {
  _oneof_case_[0] = kPlayer;
}
inline void EntityRef::clear_player() {
  if (_internal_has_player()) {
    if (GetArena() == nullptr) {
      delete entity_ref_.player_;
    }
    clear_has_entity_ref();
  }
}
inline ::Types::PlayerRef* EntityRef::release_player() {
  // @@protoc_insertion_point(field_release:Types.EntityRef.Player)
  if (_internal_has_player()) {
    clear_has_entity_ref();
      ::Types::PlayerRef* temp = entity_ref_.player_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    entity_ref_.player_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Types::PlayerRef& EntityRef::_internal_player() const {
  return _internal_has_player()
      ? *entity_ref_.player_
      : reinterpret_cast< ::Types::PlayerRef&>(::Types::_PlayerRef_default_instance_);
}
inline const ::Types::PlayerRef& EntityRef::player() const {
  // @@protoc_insertion_point(field_get:Types.EntityRef.Player)
  return _internal_player();
}
inline ::Types::PlayerRef* EntityRef::unsafe_arena_release_player() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Types.EntityRef.Player)
  if (_internal_has_player()) {
    clear_has_entity_ref();
    ::Types::PlayerRef* temp = entity_ref_.player_;
    entity_ref_.player_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EntityRef::unsafe_arena_set_allocated_player(::Types::PlayerRef* player) {
  clear_entity_ref();
  if (player) {
    set_has_player();
    entity_ref_.player_ = player;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Types.EntityRef.Player)
}
inline ::Types::PlayerRef* EntityRef::_internal_mutable_player() {
  if (!_internal_has_player()) {
    clear_entity_ref();
    set_has_player();
    entity_ref_.player_ = CreateMaybeMessage< ::Types::PlayerRef >(GetArena());
  }
  return entity_ref_.player_;
}
inline ::Types::PlayerRef* EntityRef::mutable_player() {
  // @@protoc_insertion_point(field_mutable:Types.EntityRef.Player)
  return _internal_mutable_player();
}

// .Types.CardRef Card = 4;
inline bool EntityRef::_internal_has_card() const {
  return entity_ref_case() == kCard;
}
inline bool EntityRef::has_card() const {
  return _internal_has_card();
}
inline void EntityRef::set_has_card() {
  _oneof_case_[0] = kCard;
}
inline void EntityRef::clear_card() {
  if (_internal_has_card()) {
    if (GetArena() == nullptr) {
      delete entity_ref_.card_;
    }
    clear_has_entity_ref();
  }
}
inline ::Types::CardRef* EntityRef::release_card() {
  // @@protoc_insertion_point(field_release:Types.EntityRef.Card)
  if (_internal_has_card()) {
    clear_has_entity_ref();
      ::Types::CardRef* temp = entity_ref_.card_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    entity_ref_.card_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Types::CardRef& EntityRef::_internal_card() const {
  return _internal_has_card()
      ? *entity_ref_.card_
      : reinterpret_cast< ::Types::CardRef&>(::Types::_CardRef_default_instance_);
}
inline const ::Types::CardRef& EntityRef::card() const {
  // @@protoc_insertion_point(field_get:Types.EntityRef.Card)
  return _internal_card();
}
inline ::Types::CardRef* EntityRef::unsafe_arena_release_card() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Types.EntityRef.Card)
  if (_internal_has_card()) {
    clear_has_entity_ref();
    ::Types::CardRef* temp = entity_ref_.card_;
    entity_ref_.card_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EntityRef::unsafe_arena_set_allocated_card(::Types::CardRef* card) {
  clear_entity_ref();
  if (card) {
    set_has_card();
    entity_ref_.card_ = card;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Types.EntityRef.Card)
}
inline ::Types::CardRef* EntityRef::_internal_mutable_card() {
  if (!_internal_has_card()) {
    clear_entity_ref();
    set_has_card();
    entity_ref_.card_ = CreateMaybeMessage< ::Types::CardRef >(GetArena());
  }
  return entity_ref_.card_;
}
inline ::Types::CardRef* EntityRef::mutable_card() {
  // @@protoc_insertion_point(field_mutable:Types.EntityRef.Card)
  return _internal_mutable_card();
}

// .Types.TileRef Tile = 5;
inline bool EntityRef::_internal_has_tile() const {
  return entity_ref_case() == kTile;
}
inline bool EntityRef::has_tile() const {
  return _internal_has_tile();
}
inline void EntityRef::set_has_tile() {
  _oneof_case_[0] = kTile;
}
inline void EntityRef::clear_tile() {
  if (_internal_has_tile()) {
    if (GetArena() == nullptr) {
      delete entity_ref_.tile_;
    }
    clear_has_entity_ref();
  }
}
inline ::Types::TileRef* EntityRef::release_tile() {
  // @@protoc_insertion_point(field_release:Types.EntityRef.Tile)
  if (_internal_has_tile()) {
    clear_has_entity_ref();
      ::Types::TileRef* temp = entity_ref_.tile_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    entity_ref_.tile_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Types::TileRef& EntityRef::_internal_tile() const {
  return _internal_has_tile()
      ? *entity_ref_.tile_
      : reinterpret_cast< ::Types::TileRef&>(::Types::_TileRef_default_instance_);
}
inline const ::Types::TileRef& EntityRef::tile() const {
  // @@protoc_insertion_point(field_get:Types.EntityRef.Tile)
  return _internal_tile();
}
inline ::Types::TileRef* EntityRef::unsafe_arena_release_tile() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Types.EntityRef.Tile)
  if (_internal_has_tile()) {
    clear_has_entity_ref();
    ::Types::TileRef* temp = entity_ref_.tile_;
    entity_ref_.tile_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EntityRef::unsafe_arena_set_allocated_tile(::Types::TileRef* tile) {
  clear_entity_ref();
  if (tile) {
    set_has_tile();
    entity_ref_.tile_ = tile;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Types.EntityRef.Tile)
}
inline ::Types::TileRef* EntityRef::_internal_mutable_tile() {
  if (!_internal_has_tile()) {
    clear_entity_ref();
    set_has_tile();
    entity_ref_.tile_ = CreateMaybeMessage< ::Types::TileRef >(GetArena());
  }
  return entity_ref_.tile_;
}
inline ::Types::TileRef* EntityRef::mutable_tile() {
  // @@protoc_insertion_point(field_mutable:Types.EntityRef.Tile)
  return _internal_mutable_tile();
}

inline bool EntityRef::has_entity_ref() const {
  return entity_ref_case() != ENTITY_REF_NOT_SET;
}
inline void EntityRef::clear_has_entity_ref() {
  _oneof_case_[0] = ENTITY_REF_NOT_SET;
}
inline EntityRef::EntityRefCase EntityRef::entity_ref_case() const {
  return EntityRef::EntityRefCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// EntityValue

// .Types.IntegerValue Integer = 1;
inline bool EntityValue::_internal_has_integer() const {
  return entity_val_case() == kInteger;
}
inline bool EntityValue::has_integer() const {
  return _internal_has_integer();
}
inline void EntityValue::set_has_integer() {
  _oneof_case_[0] = kInteger;
}
inline void EntityValue::clear_integer() {
  if (_internal_has_integer()) {
    if (GetArena() == nullptr) {
      delete entity_val_.integer_;
    }
    clear_has_entity_val();
  }
}
inline ::Types::IntegerValue* EntityValue::release_integer() {
  // @@protoc_insertion_point(field_release:Types.EntityValue.Integer)
  if (_internal_has_integer()) {
    clear_has_entity_val();
      ::Types::IntegerValue* temp = entity_val_.integer_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    entity_val_.integer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Types::IntegerValue& EntityValue::_internal_integer() const {
  return _internal_has_integer()
      ? *entity_val_.integer_
      : reinterpret_cast< ::Types::IntegerValue&>(::Types::_IntegerValue_default_instance_);
}
inline const ::Types::IntegerValue& EntityValue::integer() const {
  // @@protoc_insertion_point(field_get:Types.EntityValue.Integer)
  return _internal_integer();
}
inline ::Types::IntegerValue* EntityValue::unsafe_arena_release_integer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Types.EntityValue.Integer)
  if (_internal_has_integer()) {
    clear_has_entity_val();
    ::Types::IntegerValue* temp = entity_val_.integer_;
    entity_val_.integer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EntityValue::unsafe_arena_set_allocated_integer(::Types::IntegerValue* integer) {
  clear_entity_val();
  if (integer) {
    set_has_integer();
    entity_val_.integer_ = integer;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Types.EntityValue.Integer)
}
inline ::Types::IntegerValue* EntityValue::_internal_mutable_integer() {
  if (!_internal_has_integer()) {
    clear_entity_val();
    set_has_integer();
    entity_val_.integer_ = CreateMaybeMessage< ::Types::IntegerValue >(GetArena());
  }
  return entity_val_.integer_;
}
inline ::Types::IntegerValue* EntityValue::mutable_integer() {
  // @@protoc_insertion_point(field_mutable:Types.EntityValue.Integer)
  return _internal_mutable_integer();
}

// .Types.Vec2iValue Vec2i = 2;
inline bool EntityValue::_internal_has_vec2i() const {
  return entity_val_case() == kVec2I;
}
inline bool EntityValue::has_vec2i() const {
  return _internal_has_vec2i();
}
inline void EntityValue::set_has_vec2i() {
  _oneof_case_[0] = kVec2I;
}
inline void EntityValue::clear_vec2i() {
  if (_internal_has_vec2i()) {
    if (GetArena() == nullptr) {
      delete entity_val_.vec2i_;
    }
    clear_has_entity_val();
  }
}
inline ::Types::Vec2iValue* EntityValue::release_vec2i() {
  // @@protoc_insertion_point(field_release:Types.EntityValue.Vec2i)
  if (_internal_has_vec2i()) {
    clear_has_entity_val();
      ::Types::Vec2iValue* temp = entity_val_.vec2i_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    entity_val_.vec2i_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Types::Vec2iValue& EntityValue::_internal_vec2i() const {
  return _internal_has_vec2i()
      ? *entity_val_.vec2i_
      : reinterpret_cast< ::Types::Vec2iValue&>(::Types::_Vec2iValue_default_instance_);
}
inline const ::Types::Vec2iValue& EntityValue::vec2i() const {
  // @@protoc_insertion_point(field_get:Types.EntityValue.Vec2i)
  return _internal_vec2i();
}
inline ::Types::Vec2iValue* EntityValue::unsafe_arena_release_vec2i() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Types.EntityValue.Vec2i)
  if (_internal_has_vec2i()) {
    clear_has_entity_val();
    ::Types::Vec2iValue* temp = entity_val_.vec2i_;
    entity_val_.vec2i_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EntityValue::unsafe_arena_set_allocated_vec2i(::Types::Vec2iValue* vec2i) {
  clear_entity_val();
  if (vec2i) {
    set_has_vec2i();
    entity_val_.vec2i_ = vec2i;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Types.EntityValue.Vec2i)
}
inline ::Types::Vec2iValue* EntityValue::_internal_mutable_vec2i() {
  if (!_internal_has_vec2i()) {
    clear_entity_val();
    set_has_vec2i();
    entity_val_.vec2i_ = CreateMaybeMessage< ::Types::Vec2iValue >(GetArena());
  }
  return entity_val_.vec2i_;
}
inline ::Types::Vec2iValue* EntityValue::mutable_vec2i() {
  // @@protoc_insertion_point(field_mutable:Types.EntityValue.Vec2i)
  return _internal_mutable_vec2i();
}

// .Types.PlayerRef Player = 3;
inline bool EntityValue::_internal_has_player() const {
  return entity_val_case() == kPlayer;
}
inline bool EntityValue::has_player() const {
  return _internal_has_player();
}
inline void EntityValue::set_has_player() {
  _oneof_case_[0] = kPlayer;
}
inline void EntityValue::clear_player() {
  if (_internal_has_player()) {
    if (GetArena() == nullptr) {
      delete entity_val_.player_;
    }
    clear_has_entity_val();
  }
}
inline ::Types::PlayerRef* EntityValue::release_player() {
  // @@protoc_insertion_point(field_release:Types.EntityValue.Player)
  if (_internal_has_player()) {
    clear_has_entity_val();
      ::Types::PlayerRef* temp = entity_val_.player_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    entity_val_.player_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Types::PlayerRef& EntityValue::_internal_player() const {
  return _internal_has_player()
      ? *entity_val_.player_
      : reinterpret_cast< ::Types::PlayerRef&>(::Types::_PlayerRef_default_instance_);
}
inline const ::Types::PlayerRef& EntityValue::player() const {
  // @@protoc_insertion_point(field_get:Types.EntityValue.Player)
  return _internal_player();
}
inline ::Types::PlayerRef* EntityValue::unsafe_arena_release_player() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Types.EntityValue.Player)
  if (_internal_has_player()) {
    clear_has_entity_val();
    ::Types::PlayerRef* temp = entity_val_.player_;
    entity_val_.player_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EntityValue::unsafe_arena_set_allocated_player(::Types::PlayerRef* player) {
  clear_entity_val();
  if (player) {
    set_has_player();
    entity_val_.player_ = player;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Types.EntityValue.Player)
}
inline ::Types::PlayerRef* EntityValue::_internal_mutable_player() {
  if (!_internal_has_player()) {
    clear_entity_val();
    set_has_player();
    entity_val_.player_ = CreateMaybeMessage< ::Types::PlayerRef >(GetArena());
  }
  return entity_val_.player_;
}
inline ::Types::PlayerRef* EntityValue::mutable_player() {
  // @@protoc_insertion_point(field_mutable:Types.EntityValue.Player)
  return _internal_mutable_player();
}

// .Types.CardRef Card = 4;
inline bool EntityValue::_internal_has_card() const {
  return entity_val_case() == kCard;
}
inline bool EntityValue::has_card() const {
  return _internal_has_card();
}
inline void EntityValue::set_has_card() {
  _oneof_case_[0] = kCard;
}
inline void EntityValue::clear_card() {
  if (_internal_has_card()) {
    if (GetArena() == nullptr) {
      delete entity_val_.card_;
    }
    clear_has_entity_val();
  }
}
inline ::Types::CardRef* EntityValue::release_card() {
  // @@protoc_insertion_point(field_release:Types.EntityValue.Card)
  if (_internal_has_card()) {
    clear_has_entity_val();
      ::Types::CardRef* temp = entity_val_.card_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    entity_val_.card_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Types::CardRef& EntityValue::_internal_card() const {
  return _internal_has_card()
      ? *entity_val_.card_
      : reinterpret_cast< ::Types::CardRef&>(::Types::_CardRef_default_instance_);
}
inline const ::Types::CardRef& EntityValue::card() const {
  // @@protoc_insertion_point(field_get:Types.EntityValue.Card)
  return _internal_card();
}
inline ::Types::CardRef* EntityValue::unsafe_arena_release_card() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Types.EntityValue.Card)
  if (_internal_has_card()) {
    clear_has_entity_val();
    ::Types::CardRef* temp = entity_val_.card_;
    entity_val_.card_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EntityValue::unsafe_arena_set_allocated_card(::Types::CardRef* card) {
  clear_entity_val();
  if (card) {
    set_has_card();
    entity_val_.card_ = card;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Types.EntityValue.Card)
}
inline ::Types::CardRef* EntityValue::_internal_mutable_card() {
  if (!_internal_has_card()) {
    clear_entity_val();
    set_has_card();
    entity_val_.card_ = CreateMaybeMessage< ::Types::CardRef >(GetArena());
  }
  return entity_val_.card_;
}
inline ::Types::CardRef* EntityValue::mutable_card() {
  // @@protoc_insertion_point(field_mutable:Types.EntityValue.Card)
  return _internal_mutable_card();
}

// .Types.TileRef Tile = 5;
inline bool EntityValue::_internal_has_tile() const {
  return entity_val_case() == kTile;
}
inline bool EntityValue::has_tile() const {
  return _internal_has_tile();
}
inline void EntityValue::set_has_tile() {
  _oneof_case_[0] = kTile;
}
inline void EntityValue::clear_tile() {
  if (_internal_has_tile()) {
    if (GetArena() == nullptr) {
      delete entity_val_.tile_;
    }
    clear_has_entity_val();
  }
}
inline ::Types::TileRef* EntityValue::release_tile() {
  // @@protoc_insertion_point(field_release:Types.EntityValue.Tile)
  if (_internal_has_tile()) {
    clear_has_entity_val();
      ::Types::TileRef* temp = entity_val_.tile_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    entity_val_.tile_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Types::TileRef& EntityValue::_internal_tile() const {
  return _internal_has_tile()
      ? *entity_val_.tile_
      : reinterpret_cast< ::Types::TileRef&>(::Types::_TileRef_default_instance_);
}
inline const ::Types::TileRef& EntityValue::tile() const {
  // @@protoc_insertion_point(field_get:Types.EntityValue.Tile)
  return _internal_tile();
}
inline ::Types::TileRef* EntityValue::unsafe_arena_release_tile() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Types.EntityValue.Tile)
  if (_internal_has_tile()) {
    clear_has_entity_val();
    ::Types::TileRef* temp = entity_val_.tile_;
    entity_val_.tile_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EntityValue::unsafe_arena_set_allocated_tile(::Types::TileRef* tile) {
  clear_entity_val();
  if (tile) {
    set_has_tile();
    entity_val_.tile_ = tile;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Types.EntityValue.Tile)
}
inline ::Types::TileRef* EntityValue::_internal_mutable_tile() {
  if (!_internal_has_tile()) {
    clear_entity_val();
    set_has_tile();
    entity_val_.tile_ = CreateMaybeMessage< ::Types::TileRef >(GetArena());
  }
  return entity_val_.tile_;
}
inline ::Types::TileRef* EntityValue::mutable_tile() {
  // @@protoc_insertion_point(field_mutable:Types.EntityValue.Tile)
  return _internal_mutable_tile();
}

// .Types.TerrainType TerrainValue = 6;
inline bool EntityValue::_internal_has_terrainvalue() const {
  return entity_val_case() == kTerrainValue;
}
inline void EntityValue::set_has_terrainvalue() {
  _oneof_case_[0] = kTerrainValue;
}
inline void EntityValue::clear_terrainvalue() {
  if (_internal_has_terrainvalue()) {
    entity_val_.terrainvalue_ = 0;
    clear_has_entity_val();
  }
}
inline ::Types::TerrainType EntityValue::_internal_terrainvalue() const {
  if (_internal_has_terrainvalue()) {
    return static_cast< ::Types::TerrainType >(entity_val_.terrainvalue_);
  }
  return static_cast< ::Types::TerrainType >(0);
}
inline ::Types::TerrainType EntityValue::terrainvalue() const {
  // @@protoc_insertion_point(field_get:Types.EntityValue.TerrainValue)
  return _internal_terrainvalue();
}
inline void EntityValue::_internal_set_terrainvalue(::Types::TerrainType value) {
  if (!_internal_has_terrainvalue()) {
    clear_entity_val();
    set_has_terrainvalue();
  }
  entity_val_.terrainvalue_ = value;
}
inline void EntityValue::set_terrainvalue(::Types::TerrainType value) {
  // @@protoc_insertion_point(field_set:Types.EntityValue.TerrainValue)
  _internal_set_terrainvalue(value);
}

inline bool EntityValue::has_entity_val() const {
  return entity_val_case() != ENTITY_VAL_NOT_SET;
}
inline void EntityValue::clear_has_entity_val() {
  _oneof_case_[0] = ENTITY_VAL_NOT_SET;
}
inline EntityValue::EntityValCase EntityValue::entity_val_case() const {
  return EntityValue::EntityValCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Types

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::Types::TerrainType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Types::TerrainType>() {
  return ::Types::TerrainType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Types_2eproto
