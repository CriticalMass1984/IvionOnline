// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: GameState.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_GameState_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_GameState_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3014000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3014000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <GRPC/Types.pb.h>
#include <GRPC/Effects.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_GameState_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_GameState_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[11]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_GameState_2eproto;
namespace GameState {
class Card;
class CardDefaultTypeInternal;
extern CardDefaultTypeInternal _Card_default_instance_;
class GameInstance;
class GameInstanceDefaultTypeInternal;
extern GameInstanceDefaultTypeInternal _GameInstance_default_instance_;
class GameState;
class GameStateDefaultTypeInternal;
extern GameStateDefaultTypeInternal _GameState_default_instance_;
class InsertMutation;
class InsertMutationDefaultTypeInternal;
extern InsertMutationDefaultTypeInternal _InsertMutation_default_instance_;
class Mutation;
class MutationDefaultTypeInternal;
extern MutationDefaultTypeInternal _Mutation_default_instance_;
class Player;
class PlayerDefaultTypeInternal;
extern PlayerDefaultTypeInternal _Player_default_instance_;
class Player_Stats;
class Player_StatsDefaultTypeInternal;
extern Player_StatsDefaultTypeInternal _Player_Stats_default_instance_;
class RemoveMutation;
class RemoveMutationDefaultTypeInternal;
extern RemoveMutationDefaultTypeInternal _RemoveMutation_default_instance_;
class SetMutation;
class SetMutationDefaultTypeInternal;
extern SetMutationDefaultTypeInternal _SetMutation_default_instance_;
class Team;
class TeamDefaultTypeInternal;
extern TeamDefaultTypeInternal _Team_default_instance_;
class Tile;
class TileDefaultTypeInternal;
extern TileDefaultTypeInternal _Tile_default_instance_;
}  // namespace GameState
PROTOBUF_NAMESPACE_OPEN
template<> ::GameState::Card* Arena::CreateMaybeMessage<::GameState::Card>(Arena*);
template<> ::GameState::GameInstance* Arena::CreateMaybeMessage<::GameState::GameInstance>(Arena*);
template<> ::GameState::GameState* Arena::CreateMaybeMessage<::GameState::GameState>(Arena*);
template<> ::GameState::InsertMutation* Arena::CreateMaybeMessage<::GameState::InsertMutation>(Arena*);
template<> ::GameState::Mutation* Arena::CreateMaybeMessage<::GameState::Mutation>(Arena*);
template<> ::GameState::Player* Arena::CreateMaybeMessage<::GameState::Player>(Arena*);
template<> ::GameState::Player_Stats* Arena::CreateMaybeMessage<::GameState::Player_Stats>(Arena*);
template<> ::GameState::RemoveMutation* Arena::CreateMaybeMessage<::GameState::RemoveMutation>(Arena*);
template<> ::GameState::SetMutation* Arena::CreateMaybeMessage<::GameState::SetMutation>(Arena*);
template<> ::GameState::Team* Arena::CreateMaybeMessage<::GameState::Team>(Arena*);
template<> ::GameState::Tile* Arena::CreateMaybeMessage<::GameState::Tile>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace GameState {

enum Card_Color : int {
  Card_Color_GRAY = 0,
  Card_Color_BLACK = 1,
  Card_Color_RED = 2,
  Card_Color_GREEN = 3,
  Card_Color_BLUE = 4,
  Card_Color_WHITE = 5,
  Card_Color_Card_Color_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Card_Color_Card_Color_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Card_Color_IsValid(int value);
constexpr Card_Color Card_Color_Color_MIN = Card_Color_GRAY;
constexpr Card_Color Card_Color_Color_MAX = Card_Color_WHITE;
constexpr int Card_Color_Color_ARRAYSIZE = Card_Color_Color_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Card_Color_descriptor();
template<typename T>
inline const std::string& Card_Color_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Card_Color>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Card_Color_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Card_Color_descriptor(), enum_t_value);
}
inline bool Card_Color_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Card_Color* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Card_Color>(
    Card_Color_descriptor(), name, value);
}
// ===================================================================

class Player_Stats PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GameState.Player.Stats) */ {
 public:
  inline Player_Stats() : Player_Stats(nullptr) {}
  virtual ~Player_Stats();

  Player_Stats(const Player_Stats& from);
  Player_Stats(Player_Stats&& from) noexcept
    : Player_Stats() {
    *this = ::std::move(from);
  }

  inline Player_Stats& operator=(const Player_Stats& from) {
    CopyFrom(from);
    return *this;
  }
  inline Player_Stats& operator=(Player_Stats&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Player_Stats& default_instance();

  static inline const Player_Stats* internal_default_instance() {
    return reinterpret_cast<const Player_Stats*>(
               &_Player_Stats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Player_Stats& a, Player_Stats& b) {
    a.Swap(&b);
  }
  inline void Swap(Player_Stats* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Player_Stats* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Player_Stats* New() const final {
    return CreateMaybeMessage<Player_Stats>(nullptr);
  }

  Player_Stats* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Player_Stats>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Player_Stats& from);
  void MergeFrom(const Player_Stats& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Player_Stats* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GameState.Player.Stats";
  }
  protected:
  explicit Player_Stats(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GameState_2eproto);
    return ::descriptor_table_GameState_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHealthFieldNumber = 1,
    kActionsFieldNumber = 2,
    kPowerFieldNumber = 3,
    kSlowFieldNumber = 4,
    kSilenceFieldNumber = 5,
    kDisarmFieldNumber = 6,
    kInitiativeFieldNumber = 7,
  };
  // .Types.IntegerRef Health = 1;
  bool has_health() const;
  private:
  bool _internal_has_health() const;
  public:
  void clear_health();
  const ::Types::IntegerRef& health() const;
  ::Types::IntegerRef* release_health();
  ::Types::IntegerRef* mutable_health();
  void set_allocated_health(::Types::IntegerRef* health);
  private:
  const ::Types::IntegerRef& _internal_health() const;
  ::Types::IntegerRef* _internal_mutable_health();
  public:
  void unsafe_arena_set_allocated_health(
      ::Types::IntegerRef* health);
  ::Types::IntegerRef* unsafe_arena_release_health();

  // .Types.IntegerRef Actions = 2;
  bool has_actions() const;
  private:
  bool _internal_has_actions() const;
  public:
  void clear_actions();
  const ::Types::IntegerRef& actions() const;
  ::Types::IntegerRef* release_actions();
  ::Types::IntegerRef* mutable_actions();
  void set_allocated_actions(::Types::IntegerRef* actions);
  private:
  const ::Types::IntegerRef& _internal_actions() const;
  ::Types::IntegerRef* _internal_mutable_actions();
  public:
  void unsafe_arena_set_allocated_actions(
      ::Types::IntegerRef* actions);
  ::Types::IntegerRef* unsafe_arena_release_actions();

  // .Types.IntegerRef Power = 3;
  bool has_power() const;
  private:
  bool _internal_has_power() const;
  public:
  void clear_power();
  const ::Types::IntegerRef& power() const;
  ::Types::IntegerRef* release_power();
  ::Types::IntegerRef* mutable_power();
  void set_allocated_power(::Types::IntegerRef* power);
  private:
  const ::Types::IntegerRef& _internal_power() const;
  ::Types::IntegerRef* _internal_mutable_power();
  public:
  void unsafe_arena_set_allocated_power(
      ::Types::IntegerRef* power);
  ::Types::IntegerRef* unsafe_arena_release_power();

  // .Types.IntegerRef Slow = 4;
  bool has_slow() const;
  private:
  bool _internal_has_slow() const;
  public:
  void clear_slow();
  const ::Types::IntegerRef& slow() const;
  ::Types::IntegerRef* release_slow();
  ::Types::IntegerRef* mutable_slow();
  void set_allocated_slow(::Types::IntegerRef* slow);
  private:
  const ::Types::IntegerRef& _internal_slow() const;
  ::Types::IntegerRef* _internal_mutable_slow();
  public:
  void unsafe_arena_set_allocated_slow(
      ::Types::IntegerRef* slow);
  ::Types::IntegerRef* unsafe_arena_release_slow();

  // .Types.IntegerRef Silence = 5;
  bool has_silence() const;
  private:
  bool _internal_has_silence() const;
  public:
  void clear_silence();
  const ::Types::IntegerRef& silence() const;
  ::Types::IntegerRef* release_silence();
  ::Types::IntegerRef* mutable_silence();
  void set_allocated_silence(::Types::IntegerRef* silence);
  private:
  const ::Types::IntegerRef& _internal_silence() const;
  ::Types::IntegerRef* _internal_mutable_silence();
  public:
  void unsafe_arena_set_allocated_silence(
      ::Types::IntegerRef* silence);
  ::Types::IntegerRef* unsafe_arena_release_silence();

  // .Types.IntegerRef Disarm = 6;
  bool has_disarm() const;
  private:
  bool _internal_has_disarm() const;
  public:
  void clear_disarm();
  const ::Types::IntegerRef& disarm() const;
  ::Types::IntegerRef* release_disarm();
  ::Types::IntegerRef* mutable_disarm();
  void set_allocated_disarm(::Types::IntegerRef* disarm);
  private:
  const ::Types::IntegerRef& _internal_disarm() const;
  ::Types::IntegerRef* _internal_mutable_disarm();
  public:
  void unsafe_arena_set_allocated_disarm(
      ::Types::IntegerRef* disarm);
  ::Types::IntegerRef* unsafe_arena_release_disarm();

  // .Types.IntegerRef Initiative = 7;
  bool has_initiative() const;
  private:
  bool _internal_has_initiative() const;
  public:
  void clear_initiative();
  const ::Types::IntegerRef& initiative() const;
  ::Types::IntegerRef* release_initiative();
  ::Types::IntegerRef* mutable_initiative();
  void set_allocated_initiative(::Types::IntegerRef* initiative);
  private:
  const ::Types::IntegerRef& _internal_initiative() const;
  ::Types::IntegerRef* _internal_mutable_initiative();
  public:
  void unsafe_arena_set_allocated_initiative(
      ::Types::IntegerRef* initiative);
  ::Types::IntegerRef* unsafe_arena_release_initiative();

  // @@protoc_insertion_point(class_scope:GameState.Player.Stats)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Types::IntegerRef* health_;
  ::Types::IntegerRef* actions_;
  ::Types::IntegerRef* power_;
  ::Types::IntegerRef* slow_;
  ::Types::IntegerRef* silence_;
  ::Types::IntegerRef* disarm_;
  ::Types::IntegerRef* initiative_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameState_2eproto;
};
// -------------------------------------------------------------------

class Player PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GameState.Player) */ {
 public:
  inline Player() : Player(nullptr) {}
  virtual ~Player();

  Player(const Player& from);
  Player(Player&& from) noexcept
    : Player() {
    *this = ::std::move(from);
  }

  inline Player& operator=(const Player& from) {
    CopyFrom(from);
    return *this;
  }
  inline Player& operator=(Player&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Player& default_instance();

  static inline const Player* internal_default_instance() {
    return reinterpret_cast<const Player*>(
               &_Player_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Player& a, Player& b) {
    a.Swap(&b);
  }
  inline void Swap(Player* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Player* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Player* New() const final {
    return CreateMaybeMessage<Player>(nullptr);
  }

  Player* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Player>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Player& from);
  void MergeFrom(const Player& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Player* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GameState.Player";
  }
  protected:
  explicit Player(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GameState_2eproto);
    return ::descriptor_table_GameState_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Player_Stats Stats;

  // accessors -------------------------------------------------------

  enum : int {
    kFieldFieldNumber = 3,
    kHandFieldNumber = 4,
    kDeckFieldNumber = 5,
    kDiscardFieldNumber = 6,
    kFeatsFieldNumber = 7,
    kDisplayNameFieldNumber = 1,
    kUIDFieldNumber = 2,
    kStateFieldNumber = 8,
    kMaxStateFieldNumber = 9,
    kPositionFieldNumber = 10,
  };
  // repeated .Types.CardRef Field = 3;
  int field_size() const;
  private:
  int _internal_field_size() const;
  public:
  void clear_field();
  ::Types::CardRef* mutable_field(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Types::CardRef >*
      mutable_field();
  private:
  const ::Types::CardRef& _internal_field(int index) const;
  ::Types::CardRef* _internal_add_field();
  public:
  const ::Types::CardRef& field(int index) const;
  ::Types::CardRef* add_field();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Types::CardRef >&
      field() const;

  // repeated .Types.CardRef Hand = 4;
  int hand_size() const;
  private:
  int _internal_hand_size() const;
  public:
  void clear_hand();
  ::Types::CardRef* mutable_hand(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Types::CardRef >*
      mutable_hand();
  private:
  const ::Types::CardRef& _internal_hand(int index) const;
  ::Types::CardRef* _internal_add_hand();
  public:
  const ::Types::CardRef& hand(int index) const;
  ::Types::CardRef* add_hand();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Types::CardRef >&
      hand() const;

  // repeated .Types.CardRef Deck = 5;
  int deck_size() const;
  private:
  int _internal_deck_size() const;
  public:
  void clear_deck();
  ::Types::CardRef* mutable_deck(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Types::CardRef >*
      mutable_deck();
  private:
  const ::Types::CardRef& _internal_deck(int index) const;
  ::Types::CardRef* _internal_add_deck();
  public:
  const ::Types::CardRef& deck(int index) const;
  ::Types::CardRef* add_deck();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Types::CardRef >&
      deck() const;

  // repeated .Types.CardRef Discard = 6;
  int discard_size() const;
  private:
  int _internal_discard_size() const;
  public:
  void clear_discard();
  ::Types::CardRef* mutable_discard(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Types::CardRef >*
      mutable_discard();
  private:
  const ::Types::CardRef& _internal_discard(int index) const;
  ::Types::CardRef* _internal_add_discard();
  public:
  const ::Types::CardRef& discard(int index) const;
  ::Types::CardRef* add_discard();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Types::CardRef >&
      discard() const;

  // repeated .Types.CardRef Feats = 7;
  int feats_size() const;
  private:
  int _internal_feats_size() const;
  public:
  void clear_feats();
  ::Types::CardRef* mutable_feats(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Types::CardRef >*
      mutable_feats();
  private:
  const ::Types::CardRef& _internal_feats(int index) const;
  ::Types::CardRef* _internal_add_feats();
  public:
  const ::Types::CardRef& feats(int index) const;
  ::Types::CardRef* add_feats();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Types::CardRef >&
      feats() const;

  // string DisplayName = 1;
  void clear_displayname();
  const std::string& displayname() const;
  void set_displayname(const std::string& value);
  void set_displayname(std::string&& value);
  void set_displayname(const char* value);
  void set_displayname(const char* value, size_t size);
  std::string* mutable_displayname();
  std::string* release_displayname();
  void set_allocated_displayname(std::string* displayname);
  private:
  const std::string& _internal_displayname() const;
  void _internal_set_displayname(const std::string& value);
  std::string* _internal_mutable_displayname();
  public:

  // string UID = 2;
  void clear_uid();
  const std::string& uid() const;
  void set_uid(const std::string& value);
  void set_uid(std::string&& value);
  void set_uid(const char* value);
  void set_uid(const char* value, size_t size);
  std::string* mutable_uid();
  std::string* release_uid();
  void set_allocated_uid(std::string* uid);
  private:
  const std::string& _internal_uid() const;
  void _internal_set_uid(const std::string& value);
  std::string* _internal_mutable_uid();
  public:

  // .GameState.Player.Stats State = 8;
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  const ::GameState::Player_Stats& state() const;
  ::GameState::Player_Stats* release_state();
  ::GameState::Player_Stats* mutable_state();
  void set_allocated_state(::GameState::Player_Stats* state);
  private:
  const ::GameState::Player_Stats& _internal_state() const;
  ::GameState::Player_Stats* _internal_mutable_state();
  public:
  void unsafe_arena_set_allocated_state(
      ::GameState::Player_Stats* state);
  ::GameState::Player_Stats* unsafe_arena_release_state();

  // .GameState.Player.Stats MaxState = 9;
  bool has_maxstate() const;
  private:
  bool _internal_has_maxstate() const;
  public:
  void clear_maxstate();
  const ::GameState::Player_Stats& maxstate() const;
  ::GameState::Player_Stats* release_maxstate();
  ::GameState::Player_Stats* mutable_maxstate();
  void set_allocated_maxstate(::GameState::Player_Stats* maxstate);
  private:
  const ::GameState::Player_Stats& _internal_maxstate() const;
  ::GameState::Player_Stats* _internal_mutable_maxstate();
  public:
  void unsafe_arena_set_allocated_maxstate(
      ::GameState::Player_Stats* maxstate);
  ::GameState::Player_Stats* unsafe_arena_release_maxstate();

  // .Types.Vec2iRef Position = 10;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::Types::Vec2iRef& position() const;
  ::Types::Vec2iRef* release_position();
  ::Types::Vec2iRef* mutable_position();
  void set_allocated_position(::Types::Vec2iRef* position);
  private:
  const ::Types::Vec2iRef& _internal_position() const;
  ::Types::Vec2iRef* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::Types::Vec2iRef* position);
  ::Types::Vec2iRef* unsafe_arena_release_position();

  // @@protoc_insertion_point(class_scope:GameState.Player)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Types::CardRef > field_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Types::CardRef > hand_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Types::CardRef > deck_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Types::CardRef > discard_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Types::CardRef > feats_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr displayname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uid_;
  ::GameState::Player_Stats* state_;
  ::GameState::Player_Stats* maxstate_;
  ::Types::Vec2iRef* position_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameState_2eproto;
};
// -------------------------------------------------------------------

class Tile PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GameState.Tile) */ {
 public:
  inline Tile() : Tile(nullptr) {}
  virtual ~Tile();

  Tile(const Tile& from);
  Tile(Tile&& from) noexcept
    : Tile() {
    *this = ::std::move(from);
  }

  inline Tile& operator=(const Tile& from) {
    CopyFrom(from);
    return *this;
  }
  inline Tile& operator=(Tile&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Tile& default_instance();

  static inline const Tile* internal_default_instance() {
    return reinterpret_cast<const Tile*>(
               &_Tile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Tile& a, Tile& b) {
    a.Swap(&b);
  }
  inline void Swap(Tile* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Tile* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Tile* New() const final {
    return CreateMaybeMessage<Tile>(nullptr);
  }

  Tile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Tile>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Tile& from);
  void MergeFrom(const Tile& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Tile* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GameState.Tile";
  }
  protected:
  explicit Tile(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GameState_2eproto);
    return ::descriptor_table_GameState_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayersFieldNumber = 3,
    kCardsFieldNumber = 4,
    kPositionFieldNumber = 1,
    kTerrainFieldNumber = 2,
  };
  // repeated .Types.PlayerRef Players = 3;
  int players_size() const;
  private:
  int _internal_players_size() const;
  public:
  void clear_players();
  ::Types::PlayerRef* mutable_players(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Types::PlayerRef >*
      mutable_players();
  private:
  const ::Types::PlayerRef& _internal_players(int index) const;
  ::Types::PlayerRef* _internal_add_players();
  public:
  const ::Types::PlayerRef& players(int index) const;
  ::Types::PlayerRef* add_players();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Types::PlayerRef >&
      players() const;

  // repeated .Types.CardRef Cards = 4;
  int cards_size() const;
  private:
  int _internal_cards_size() const;
  public:
  void clear_cards();
  ::Types::CardRef* mutable_cards(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Types::CardRef >*
      mutable_cards();
  private:
  const ::Types::CardRef& _internal_cards(int index) const;
  ::Types::CardRef* _internal_add_cards();
  public:
  const ::Types::CardRef& cards(int index) const;
  ::Types::CardRef* add_cards();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Types::CardRef >&
      cards() const;

  // .Types.Vec2i Position = 1;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::Types::Vec2i& position() const;
  ::Types::Vec2i* release_position();
  ::Types::Vec2i* mutable_position();
  void set_allocated_position(::Types::Vec2i* position);
  private:
  const ::Types::Vec2i& _internal_position() const;
  ::Types::Vec2i* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::Types::Vec2i* position);
  ::Types::Vec2i* unsafe_arena_release_position();

  // .Types.TerrainType Terrain = 2;
  void clear_terrain();
  ::Types::TerrainType terrain() const;
  void set_terrain(::Types::TerrainType value);
  private:
  ::Types::TerrainType _internal_terrain() const;
  void _internal_set_terrain(::Types::TerrainType value);
  public:

  // @@protoc_insertion_point(class_scope:GameState.Tile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Types::PlayerRef > players_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Types::CardRef > cards_;
  ::Types::Vec2i* position_;
  int terrain_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameState_2eproto;
};
// -------------------------------------------------------------------

class Card PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GameState.Card) */ {
 public:
  inline Card() : Card(nullptr) {}
  virtual ~Card();

  Card(const Card& from);
  Card(Card&& from) noexcept
    : Card() {
    *this = ::std::move(from);
  }

  inline Card& operator=(const Card& from) {
    CopyFrom(from);
    return *this;
  }
  inline Card& operator=(Card&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Card& default_instance();

  static inline const Card* internal_default_instance() {
    return reinterpret_cast<const Card*>(
               &_Card_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Card& a, Card& b) {
    a.Swap(&b);
  }
  inline void Swap(Card* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Card* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Card* New() const final {
    return CreateMaybeMessage<Card>(nullptr);
  }

  Card* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Card>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Card& from);
  void MergeFrom(const Card& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Card* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GameState.Card";
  }
  protected:
  explicit Card(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GameState_2eproto);
    return ::descriptor_table_GameState_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Card_Color Color;
  static constexpr Color GRAY =
    Card_Color_GRAY;
  static constexpr Color BLACK =
    Card_Color_BLACK;
  static constexpr Color RED =
    Card_Color_RED;
  static constexpr Color GREEN =
    Card_Color_GREEN;
  static constexpr Color BLUE =
    Card_Color_BLUE;
  static constexpr Color WHITE =
    Card_Color_WHITE;
  static inline bool Color_IsValid(int value) {
    return Card_Color_IsValid(value);
  }
  static constexpr Color Color_MIN =
    Card_Color_Color_MIN;
  static constexpr Color Color_MAX =
    Card_Color_Color_MAX;
  static constexpr int Color_ARRAYSIZE =
    Card_Color_Color_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Color_descriptor() {
    return Card_Color_descriptor();
  }
  template<typename T>
  static inline const std::string& Color_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Color>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Color_Name.");
    return Card_Color_Name(enum_t_value);
  }
  static inline bool Color_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Color* value) {
    return Card_Color_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kColorsFieldNumber = 6,
    kNameFieldNumber = 1,
    kArchetypeFieldNumber = 2,
    kOwnerFieldNumber = 7,
    kControllerFieldNumber = 8,
    kActionCostFieldNumber = 9,
    kPowerCostFieldNumber = 10,
    kRangeFieldNumber = 11,
    kAttachedFieldNumber = 12,
    kAffectedBySlowFieldNumber = 13,
    kAffectedBySilenceFieldNumber = 14,
    kAffectedByDisarmFieldNumber = 15,
    kOmniPresentEffectFieldNumber = 16,
    kPassiveEffectFieldNumber = 17,
    kFeatEffectFieldNumber = 18,
    kPlayEffectFieldNumber = 19,
    kResolveEffectFieldNumber = 20,
    kUltimateFieldNumber = 3,
    kFeatFieldNumber = 4,
    kBasicActionFieldNumber = 5,
  };
  // repeated .GameState.Card.Color Colors = 6;
  int colors_size() const;
  private:
  int _internal_colors_size() const;
  public:
  void clear_colors();
  private:
  ::GameState::Card_Color _internal_colors(int index) const;
  void _internal_add_colors(::GameState::Card_Color value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_colors();
  public:
  ::GameState::Card_Color colors(int index) const;
  void set_colors(int index, ::GameState::Card_Color value);
  void add_colors(::GameState::Card_Color value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& colors() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_colors();

  // string Name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string Archetype = 2;
  void clear_archetype();
  const std::string& archetype() const;
  void set_archetype(const std::string& value);
  void set_archetype(std::string&& value);
  void set_archetype(const char* value);
  void set_archetype(const char* value, size_t size);
  std::string* mutable_archetype();
  std::string* release_archetype();
  void set_allocated_archetype(std::string* archetype);
  private:
  const std::string& _internal_archetype() const;
  void _internal_set_archetype(const std::string& value);
  std::string* _internal_mutable_archetype();
  public:

  // .Types.PlayerRef Owner = 7;
  bool has_owner() const;
  private:
  bool _internal_has_owner() const;
  public:
  void clear_owner();
  const ::Types::PlayerRef& owner() const;
  ::Types::PlayerRef* release_owner();
  ::Types::PlayerRef* mutable_owner();
  void set_allocated_owner(::Types::PlayerRef* owner);
  private:
  const ::Types::PlayerRef& _internal_owner() const;
  ::Types::PlayerRef* _internal_mutable_owner();
  public:
  void unsafe_arena_set_allocated_owner(
      ::Types::PlayerRef* owner);
  ::Types::PlayerRef* unsafe_arena_release_owner();

  // .Types.PlayerRef Controller = 8;
  bool has_controller() const;
  private:
  bool _internal_has_controller() const;
  public:
  void clear_controller();
  const ::Types::PlayerRef& controller() const;
  ::Types::PlayerRef* release_controller();
  ::Types::PlayerRef* mutable_controller();
  void set_allocated_controller(::Types::PlayerRef* controller);
  private:
  const ::Types::PlayerRef& _internal_controller() const;
  ::Types::PlayerRef* _internal_mutable_controller();
  public:
  void unsafe_arena_set_allocated_controller(
      ::Types::PlayerRef* controller);
  ::Types::PlayerRef* unsafe_arena_release_controller();

  // .Types.IntegerRef ActionCost = 9;
  bool has_actioncost() const;
  private:
  bool _internal_has_actioncost() const;
  public:
  void clear_actioncost();
  const ::Types::IntegerRef& actioncost() const;
  ::Types::IntegerRef* release_actioncost();
  ::Types::IntegerRef* mutable_actioncost();
  void set_allocated_actioncost(::Types::IntegerRef* actioncost);
  private:
  const ::Types::IntegerRef& _internal_actioncost() const;
  ::Types::IntegerRef* _internal_mutable_actioncost();
  public:
  void unsafe_arena_set_allocated_actioncost(
      ::Types::IntegerRef* actioncost);
  ::Types::IntegerRef* unsafe_arena_release_actioncost();

  // .Types.IntegerRef PowerCost = 10;
  bool has_powercost() const;
  private:
  bool _internal_has_powercost() const;
  public:
  void clear_powercost();
  const ::Types::IntegerRef& powercost() const;
  ::Types::IntegerRef* release_powercost();
  ::Types::IntegerRef* mutable_powercost();
  void set_allocated_powercost(::Types::IntegerRef* powercost);
  private:
  const ::Types::IntegerRef& _internal_powercost() const;
  ::Types::IntegerRef* _internal_mutable_powercost();
  public:
  void unsafe_arena_set_allocated_powercost(
      ::Types::IntegerRef* powercost);
  ::Types::IntegerRef* unsafe_arena_release_powercost();

  // .Types.IntegerRef Range = 11;
  bool has_range() const;
  private:
  bool _internal_has_range() const;
  public:
  void clear_range();
  const ::Types::IntegerRef& range() const;
  ::Types::IntegerRef* release_range();
  ::Types::IntegerRef* mutable_range();
  void set_allocated_range(::Types::IntegerRef* range);
  private:
  const ::Types::IntegerRef& _internal_range() const;
  ::Types::IntegerRef* _internal_mutable_range();
  public:
  void unsafe_arena_set_allocated_range(
      ::Types::IntegerRef* range);
  ::Types::IntegerRef* unsafe_arena_release_range();

  // .Types.EntityRef Attached = 12;
  bool has_attached() const;
  private:
  bool _internal_has_attached() const;
  public:
  void clear_attached();
  const ::Types::EntityRef& attached() const;
  ::Types::EntityRef* release_attached();
  ::Types::EntityRef* mutable_attached();
  void set_allocated_attached(::Types::EntityRef* attached);
  private:
  const ::Types::EntityRef& _internal_attached() const;
  ::Types::EntityRef* _internal_mutable_attached();
  public:
  void unsafe_arena_set_allocated_attached(
      ::Types::EntityRef* attached);
  ::Types::EntityRef* unsafe_arena_release_attached();

  // .Types.IntegerRef AffectedBySlow = 13;
  bool has_affectedbyslow() const;
  private:
  bool _internal_has_affectedbyslow() const;
  public:
  void clear_affectedbyslow();
  const ::Types::IntegerRef& affectedbyslow() const;
  ::Types::IntegerRef* release_affectedbyslow();
  ::Types::IntegerRef* mutable_affectedbyslow();
  void set_allocated_affectedbyslow(::Types::IntegerRef* affectedbyslow);
  private:
  const ::Types::IntegerRef& _internal_affectedbyslow() const;
  ::Types::IntegerRef* _internal_mutable_affectedbyslow();
  public:
  void unsafe_arena_set_allocated_affectedbyslow(
      ::Types::IntegerRef* affectedbyslow);
  ::Types::IntegerRef* unsafe_arena_release_affectedbyslow();

  // .Types.IntegerRef AffectedBySilence = 14;
  bool has_affectedbysilence() const;
  private:
  bool _internal_has_affectedbysilence() const;
  public:
  void clear_affectedbysilence();
  const ::Types::IntegerRef& affectedbysilence() const;
  ::Types::IntegerRef* release_affectedbysilence();
  ::Types::IntegerRef* mutable_affectedbysilence();
  void set_allocated_affectedbysilence(::Types::IntegerRef* affectedbysilence);
  private:
  const ::Types::IntegerRef& _internal_affectedbysilence() const;
  ::Types::IntegerRef* _internal_mutable_affectedbysilence();
  public:
  void unsafe_arena_set_allocated_affectedbysilence(
      ::Types::IntegerRef* affectedbysilence);
  ::Types::IntegerRef* unsafe_arena_release_affectedbysilence();

  // .Types.IntegerRef AffectedByDisarm = 15;
  bool has_affectedbydisarm() const;
  private:
  bool _internal_has_affectedbydisarm() const;
  public:
  void clear_affectedbydisarm();
  const ::Types::IntegerRef& affectedbydisarm() const;
  ::Types::IntegerRef* release_affectedbydisarm();
  ::Types::IntegerRef* mutable_affectedbydisarm();
  void set_allocated_affectedbydisarm(::Types::IntegerRef* affectedbydisarm);
  private:
  const ::Types::IntegerRef& _internal_affectedbydisarm() const;
  ::Types::IntegerRef* _internal_mutable_affectedbydisarm();
  public:
  void unsafe_arena_set_allocated_affectedbydisarm(
      ::Types::IntegerRef* affectedbydisarm);
  ::Types::IntegerRef* unsafe_arena_release_affectedbydisarm();

  // .Effects.CardEffect OmniPresentEffect = 16;
  bool has_omnipresenteffect() const;
  private:
  bool _internal_has_omnipresenteffect() const;
  public:
  void clear_omnipresenteffect();
  const ::Effects::CardEffect& omnipresenteffect() const;
  ::Effects::CardEffect* release_omnipresenteffect();
  ::Effects::CardEffect* mutable_omnipresenteffect();
  void set_allocated_omnipresenteffect(::Effects::CardEffect* omnipresenteffect);
  private:
  const ::Effects::CardEffect& _internal_omnipresenteffect() const;
  ::Effects::CardEffect* _internal_mutable_omnipresenteffect();
  public:
  void unsafe_arena_set_allocated_omnipresenteffect(
      ::Effects::CardEffect* omnipresenteffect);
  ::Effects::CardEffect* unsafe_arena_release_omnipresenteffect();

  // .Effects.CardEffect PassiveEffect = 17;
  bool has_passiveeffect() const;
  private:
  bool _internal_has_passiveeffect() const;
  public:
  void clear_passiveeffect();
  const ::Effects::CardEffect& passiveeffect() const;
  ::Effects::CardEffect* release_passiveeffect();
  ::Effects::CardEffect* mutable_passiveeffect();
  void set_allocated_passiveeffect(::Effects::CardEffect* passiveeffect);
  private:
  const ::Effects::CardEffect& _internal_passiveeffect() const;
  ::Effects::CardEffect* _internal_mutable_passiveeffect();
  public:
  void unsafe_arena_set_allocated_passiveeffect(
      ::Effects::CardEffect* passiveeffect);
  ::Effects::CardEffect* unsafe_arena_release_passiveeffect();

  // .Effects.CardEffect FeatEffect = 18;
  bool has_feateffect() const;
  private:
  bool _internal_has_feateffect() const;
  public:
  void clear_feateffect();
  const ::Effects::CardEffect& feateffect() const;
  ::Effects::CardEffect* release_feateffect();
  ::Effects::CardEffect* mutable_feateffect();
  void set_allocated_feateffect(::Effects::CardEffect* feateffect);
  private:
  const ::Effects::CardEffect& _internal_feateffect() const;
  ::Effects::CardEffect* _internal_mutable_feateffect();
  public:
  void unsafe_arena_set_allocated_feateffect(
      ::Effects::CardEffect* feateffect);
  ::Effects::CardEffect* unsafe_arena_release_feateffect();

  // .Effects.CardEffect PlayEffect = 19;
  bool has_playeffect() const;
  private:
  bool _internal_has_playeffect() const;
  public:
  void clear_playeffect();
  const ::Effects::CardEffect& playeffect() const;
  ::Effects::CardEffect* release_playeffect();
  ::Effects::CardEffect* mutable_playeffect();
  void set_allocated_playeffect(::Effects::CardEffect* playeffect);
  private:
  const ::Effects::CardEffect& _internal_playeffect() const;
  ::Effects::CardEffect* _internal_mutable_playeffect();
  public:
  void unsafe_arena_set_allocated_playeffect(
      ::Effects::CardEffect* playeffect);
  ::Effects::CardEffect* unsafe_arena_release_playeffect();

  // .Effects.CardEffect ResolveEffect = 20;
  bool has_resolveeffect() const;
  private:
  bool _internal_has_resolveeffect() const;
  public:
  void clear_resolveeffect();
  const ::Effects::CardEffect& resolveeffect() const;
  ::Effects::CardEffect* release_resolveeffect();
  ::Effects::CardEffect* mutable_resolveeffect();
  void set_allocated_resolveeffect(::Effects::CardEffect* resolveeffect);
  private:
  const ::Effects::CardEffect& _internal_resolveeffect() const;
  ::Effects::CardEffect* _internal_mutable_resolveeffect();
  public:
  void unsafe_arena_set_allocated_resolveeffect(
      ::Effects::CardEffect* resolveeffect);
  ::Effects::CardEffect* unsafe_arena_release_resolveeffect();

  // bool Ultimate = 3;
  void clear_ultimate();
  bool ultimate() const;
  void set_ultimate(bool value);
  private:
  bool _internal_ultimate() const;
  void _internal_set_ultimate(bool value);
  public:

  // bool Feat = 4;
  void clear_feat();
  bool feat() const;
  void set_feat(bool value);
  private:
  bool _internal_feat() const;
  void _internal_set_feat(bool value);
  public:

  // bool BasicAction = 5;
  void clear_basicaction();
  bool basicaction() const;
  void set_basicaction(bool value);
  private:
  bool _internal_basicaction() const;
  void _internal_set_basicaction(bool value);
  public:

  // @@protoc_insertion_point(class_scope:GameState.Card)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> colors_;
  mutable std::atomic<int> _colors_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr archetype_;
  ::Types::PlayerRef* owner_;
  ::Types::PlayerRef* controller_;
  ::Types::IntegerRef* actioncost_;
  ::Types::IntegerRef* powercost_;
  ::Types::IntegerRef* range_;
  ::Types::EntityRef* attached_;
  ::Types::IntegerRef* affectedbyslow_;
  ::Types::IntegerRef* affectedbysilence_;
  ::Types::IntegerRef* affectedbydisarm_;
  ::Effects::CardEffect* omnipresenteffect_;
  ::Effects::CardEffect* passiveeffect_;
  ::Effects::CardEffect* feateffect_;
  ::Effects::CardEffect* playeffect_;
  ::Effects::CardEffect* resolveeffect_;
  bool ultimate_;
  bool feat_;
  bool basicaction_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameState_2eproto;
};
// -------------------------------------------------------------------

class Team PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GameState.Team) */ {
 public:
  inline Team() : Team(nullptr) {}
  virtual ~Team();

  Team(const Team& from);
  Team(Team&& from) noexcept
    : Team() {
    *this = ::std::move(from);
  }

  inline Team& operator=(const Team& from) {
    CopyFrom(from);
    return *this;
  }
  inline Team& operator=(Team&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Team& default_instance();

  static inline const Team* internal_default_instance() {
    return reinterpret_cast<const Team*>(
               &_Team_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Team& a, Team& b) {
    a.Swap(&b);
  }
  inline void Swap(Team* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Team* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Team* New() const final {
    return CreateMaybeMessage<Team>(nullptr);
  }

  Team* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Team>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Team& from);
  void MergeFrom(const Team& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Team* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GameState.Team";
  }
  protected:
  explicit Team(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GameState_2eproto);
    return ::descriptor_table_GameState_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayersFieldNumber = 1,
  };
  // repeated .Types.PlayerRef Players = 1;
  int players_size() const;
  private:
  int _internal_players_size() const;
  public:
  void clear_players();
  ::Types::PlayerRef* mutable_players(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Types::PlayerRef >*
      mutable_players();
  private:
  const ::Types::PlayerRef& _internal_players(int index) const;
  ::Types::PlayerRef* _internal_add_players();
  public:
  const ::Types::PlayerRef& players(int index) const;
  ::Types::PlayerRef* add_players();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Types::PlayerRef >&
      players() const;

  // @@protoc_insertion_point(class_scope:GameState.Team)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Types::PlayerRef > players_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameState_2eproto;
};
// -------------------------------------------------------------------

class SetMutation PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GameState.SetMutation) */ {
 public:
  inline SetMutation() : SetMutation(nullptr) {}
  virtual ~SetMutation();

  SetMutation(const SetMutation& from);
  SetMutation(SetMutation&& from) noexcept
    : SetMutation() {
    *this = ::std::move(from);
  }

  inline SetMutation& operator=(const SetMutation& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetMutation& operator=(SetMutation&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SetMutation& default_instance();

  static inline const SetMutation* internal_default_instance() {
    return reinterpret_cast<const SetMutation*>(
               &_SetMutation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SetMutation& a, SetMutation& b) {
    a.Swap(&b);
  }
  inline void Swap(SetMutation* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetMutation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SetMutation* New() const final {
    return CreateMaybeMessage<SetMutation>(nullptr);
  }

  SetMutation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SetMutation>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SetMutation& from);
  void MergeFrom(const SetMutation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetMutation* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GameState.SetMutation";
  }
  protected:
  explicit SetMutation(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GameState_2eproto);
    return ::descriptor_table_GameState_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectFieldNumber = 1,
    kNewValueFieldNumber = 2,
    kOldValueFieldNumber = 3,
  };
  // .Types.EntityRef Object = 1;
  bool has_object() const;
  private:
  bool _internal_has_object() const;
  public:
  void clear_object();
  const ::Types::EntityRef& object() const;
  ::Types::EntityRef* release_object();
  ::Types::EntityRef* mutable_object();
  void set_allocated_object(::Types::EntityRef* object);
  private:
  const ::Types::EntityRef& _internal_object() const;
  ::Types::EntityRef* _internal_mutable_object();
  public:
  void unsafe_arena_set_allocated_object(
      ::Types::EntityRef* object);
  ::Types::EntityRef* unsafe_arena_release_object();

  // .Types.EntityValue NewValue = 2;
  bool has_newvalue() const;
  private:
  bool _internal_has_newvalue() const;
  public:
  void clear_newvalue();
  const ::Types::EntityValue& newvalue() const;
  ::Types::EntityValue* release_newvalue();
  ::Types::EntityValue* mutable_newvalue();
  void set_allocated_newvalue(::Types::EntityValue* newvalue);
  private:
  const ::Types::EntityValue& _internal_newvalue() const;
  ::Types::EntityValue* _internal_mutable_newvalue();
  public:
  void unsafe_arena_set_allocated_newvalue(
      ::Types::EntityValue* newvalue);
  ::Types::EntityValue* unsafe_arena_release_newvalue();

  // .Types.EntityValue OldValue = 3;
  bool has_oldvalue() const;
  private:
  bool _internal_has_oldvalue() const;
  public:
  void clear_oldvalue();
  const ::Types::EntityValue& oldvalue() const;
  ::Types::EntityValue* release_oldvalue();
  ::Types::EntityValue* mutable_oldvalue();
  void set_allocated_oldvalue(::Types::EntityValue* oldvalue);
  private:
  const ::Types::EntityValue& _internal_oldvalue() const;
  ::Types::EntityValue* _internal_mutable_oldvalue();
  public:
  void unsafe_arena_set_allocated_oldvalue(
      ::Types::EntityValue* oldvalue);
  ::Types::EntityValue* unsafe_arena_release_oldvalue();

  // @@protoc_insertion_point(class_scope:GameState.SetMutation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Types::EntityRef* object_;
  ::Types::EntityValue* newvalue_;
  ::Types::EntityValue* oldvalue_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameState_2eproto;
};
// -------------------------------------------------------------------

class RemoveMutation PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GameState.RemoveMutation) */ {
 public:
  inline RemoveMutation() : RemoveMutation(nullptr) {}
  virtual ~RemoveMutation();

  RemoveMutation(const RemoveMutation& from);
  RemoveMutation(RemoveMutation&& from) noexcept
    : RemoveMutation() {
    *this = ::std::move(from);
  }

  inline RemoveMutation& operator=(const RemoveMutation& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoveMutation& operator=(RemoveMutation&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RemoveMutation& default_instance();

  static inline const RemoveMutation* internal_default_instance() {
    return reinterpret_cast<const RemoveMutation*>(
               &_RemoveMutation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RemoveMutation& a, RemoveMutation& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoveMutation* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoveMutation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RemoveMutation* New() const final {
    return CreateMaybeMessage<RemoveMutation>(nullptr);
  }

  RemoveMutation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RemoveMutation>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RemoveMutation& from);
  void MergeFrom(const RemoveMutation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoveMutation* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GameState.RemoveMutation";
  }
  protected:
  explicit RemoveMutation(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GameState_2eproto);
    return ::descriptor_table_GameState_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectFieldNumber = 1,
    kOldValueFieldNumber = 2,
  };
  // .Types.EntityRef Object = 1;
  bool has_object() const;
  private:
  bool _internal_has_object() const;
  public:
  void clear_object();
  const ::Types::EntityRef& object() const;
  ::Types::EntityRef* release_object();
  ::Types::EntityRef* mutable_object();
  void set_allocated_object(::Types::EntityRef* object);
  private:
  const ::Types::EntityRef& _internal_object() const;
  ::Types::EntityRef* _internal_mutable_object();
  public:
  void unsafe_arena_set_allocated_object(
      ::Types::EntityRef* object);
  ::Types::EntityRef* unsafe_arena_release_object();

  // .Types.EntityValue OldValue = 2;
  bool has_oldvalue() const;
  private:
  bool _internal_has_oldvalue() const;
  public:
  void clear_oldvalue();
  const ::Types::EntityValue& oldvalue() const;
  ::Types::EntityValue* release_oldvalue();
  ::Types::EntityValue* mutable_oldvalue();
  void set_allocated_oldvalue(::Types::EntityValue* oldvalue);
  private:
  const ::Types::EntityValue& _internal_oldvalue() const;
  ::Types::EntityValue* _internal_mutable_oldvalue();
  public:
  void unsafe_arena_set_allocated_oldvalue(
      ::Types::EntityValue* oldvalue);
  ::Types::EntityValue* unsafe_arena_release_oldvalue();

  // @@protoc_insertion_point(class_scope:GameState.RemoveMutation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Types::EntityRef* object_;
  ::Types::EntityValue* oldvalue_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameState_2eproto;
};
// -------------------------------------------------------------------

class InsertMutation PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GameState.InsertMutation) */ {
 public:
  inline InsertMutation() : InsertMutation(nullptr) {}
  virtual ~InsertMutation();

  InsertMutation(const InsertMutation& from);
  InsertMutation(InsertMutation&& from) noexcept
    : InsertMutation() {
    *this = ::std::move(from);
  }

  inline InsertMutation& operator=(const InsertMutation& from) {
    CopyFrom(from);
    return *this;
  }
  inline InsertMutation& operator=(InsertMutation&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const InsertMutation& default_instance();

  static inline const InsertMutation* internal_default_instance() {
    return reinterpret_cast<const InsertMutation*>(
               &_InsertMutation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(InsertMutation& a, InsertMutation& b) {
    a.Swap(&b);
  }
  inline void Swap(InsertMutation* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InsertMutation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InsertMutation* New() const final {
    return CreateMaybeMessage<InsertMutation>(nullptr);
  }

  InsertMutation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InsertMutation>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const InsertMutation& from);
  void MergeFrom(const InsertMutation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InsertMutation* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GameState.InsertMutation";
  }
  protected:
  explicit InsertMutation(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GameState_2eproto);
    return ::descriptor_table_GameState_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectFieldNumber = 1,
    kNewValueFieldNumber = 2,
  };
  // .Types.EntityRef Object = 1;
  bool has_object() const;
  private:
  bool _internal_has_object() const;
  public:
  void clear_object();
  const ::Types::EntityRef& object() const;
  ::Types::EntityRef* release_object();
  ::Types::EntityRef* mutable_object();
  void set_allocated_object(::Types::EntityRef* object);
  private:
  const ::Types::EntityRef& _internal_object() const;
  ::Types::EntityRef* _internal_mutable_object();
  public:
  void unsafe_arena_set_allocated_object(
      ::Types::EntityRef* object);
  ::Types::EntityRef* unsafe_arena_release_object();

  // .Types.EntityValue NewValue = 2;
  bool has_newvalue() const;
  private:
  bool _internal_has_newvalue() const;
  public:
  void clear_newvalue();
  const ::Types::EntityValue& newvalue() const;
  ::Types::EntityValue* release_newvalue();
  ::Types::EntityValue* mutable_newvalue();
  void set_allocated_newvalue(::Types::EntityValue* newvalue);
  private:
  const ::Types::EntityValue& _internal_newvalue() const;
  ::Types::EntityValue* _internal_mutable_newvalue();
  public:
  void unsafe_arena_set_allocated_newvalue(
      ::Types::EntityValue* newvalue);
  ::Types::EntityValue* unsafe_arena_release_newvalue();

  // @@protoc_insertion_point(class_scope:GameState.InsertMutation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Types::EntityRef* object_;
  ::Types::EntityValue* newvalue_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameState_2eproto;
};
// -------------------------------------------------------------------

class Mutation PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GameState.Mutation) */ {
 public:
  inline Mutation() : Mutation(nullptr) {}
  virtual ~Mutation();

  Mutation(const Mutation& from);
  Mutation(Mutation&& from) noexcept
    : Mutation() {
    *this = ::std::move(from);
  }

  inline Mutation& operator=(const Mutation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Mutation& operator=(Mutation&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Mutation& default_instance();

  enum MutationCase {
    kSet = 1,
    kRemove = 2,
    kInsert = 3,
    MUTATION_NOT_SET = 0,
  };

  static inline const Mutation* internal_default_instance() {
    return reinterpret_cast<const Mutation*>(
               &_Mutation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Mutation& a, Mutation& b) {
    a.Swap(&b);
  }
  inline void Swap(Mutation* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Mutation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Mutation* New() const final {
    return CreateMaybeMessage<Mutation>(nullptr);
  }

  Mutation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Mutation>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Mutation& from);
  void MergeFrom(const Mutation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Mutation* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GameState.Mutation";
  }
  protected:
  explicit Mutation(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GameState_2eproto);
    return ::descriptor_table_GameState_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSetFieldNumber = 1,
    kRemoveFieldNumber = 2,
    kInsertFieldNumber = 3,
  };
  // .GameState.SetMutation Set = 1;
  bool has_set() const;
  private:
  bool _internal_has_set() const;
  public:
  void clear_set();
  const ::GameState::SetMutation& set() const;
  ::GameState::SetMutation* release_set();
  ::GameState::SetMutation* mutable_set();
  void set_allocated_set(::GameState::SetMutation* set);
  private:
  const ::GameState::SetMutation& _internal_set() const;
  ::GameState::SetMutation* _internal_mutable_set();
  public:
  void unsafe_arena_set_allocated_set(
      ::GameState::SetMutation* set);
  ::GameState::SetMutation* unsafe_arena_release_set();

  // .GameState.RemoveMutation Remove = 2;
  bool has_remove() const;
  private:
  bool _internal_has_remove() const;
  public:
  void clear_remove();
  const ::GameState::RemoveMutation& remove() const;
  ::GameState::RemoveMutation* release_remove();
  ::GameState::RemoveMutation* mutable_remove();
  void set_allocated_remove(::GameState::RemoveMutation* remove);
  private:
  const ::GameState::RemoveMutation& _internal_remove() const;
  ::GameState::RemoveMutation* _internal_mutable_remove();
  public:
  void unsafe_arena_set_allocated_remove(
      ::GameState::RemoveMutation* remove);
  ::GameState::RemoveMutation* unsafe_arena_release_remove();

  // .GameState.InsertMutation Insert = 3;
  bool has_insert() const;
  private:
  bool _internal_has_insert() const;
  public:
  void clear_insert();
  const ::GameState::InsertMutation& insert() const;
  ::GameState::InsertMutation* release_insert();
  ::GameState::InsertMutation* mutable_insert();
  void set_allocated_insert(::GameState::InsertMutation* insert);
  private:
  const ::GameState::InsertMutation& _internal_insert() const;
  ::GameState::InsertMutation* _internal_mutable_insert();
  public:
  void unsafe_arena_set_allocated_insert(
      ::GameState::InsertMutation* insert);
  ::GameState::InsertMutation* unsafe_arena_release_insert();

  void clear_mutation();
  MutationCase mutation_case() const;
  // @@protoc_insertion_point(class_scope:GameState.Mutation)
 private:
  class _Internal;
  void set_has_set();
  void set_has_remove();
  void set_has_insert();

  inline bool has_mutation() const;
  inline void clear_has_mutation();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union MutationUnion {
    MutationUnion() {}
    ::GameState::SetMutation* set_;
    ::GameState::RemoveMutation* remove_;
    ::GameState::InsertMutation* insert_;
  } mutation_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_GameState_2eproto;
};
// -------------------------------------------------------------------

class GameState PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GameState.GameState) */ {
 public:
  inline GameState() : GameState(nullptr) {}
  virtual ~GameState();

  GameState(const GameState& from);
  GameState(GameState&& from) noexcept
    : GameState() {
    *this = ::std::move(from);
  }

  inline GameState& operator=(const GameState& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameState& operator=(GameState&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GameState& default_instance();

  static inline const GameState* internal_default_instance() {
    return reinterpret_cast<const GameState*>(
               &_GameState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(GameState& a, GameState& b) {
    a.Swap(&b);
  }
  inline void Swap(GameState* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GameState* New() const final {
    return CreateMaybeMessage<GameState>(nullptr);
  }

  GameState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GameState>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GameState& from);
  void MergeFrom(const GameState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GameState.GameState";
  }
  protected:
  explicit GameState(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GameState_2eproto);
    return ::descriptor_table_GameState_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayersFieldNumber = 1,
    kCardsFieldNumber = 2,
    kTilesFieldNumber = 3,
    kTeamsFieldNumber = 4,
    kStackFieldNumber = 7,
    kTurnNumberFieldNumber = 6,
  };
  // repeated .GameState.Player Players = 1;
  int players_size() const;
  private:
  int _internal_players_size() const;
  public:
  void clear_players();
  ::GameState::Player* mutable_players(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::Player >*
      mutable_players();
  private:
  const ::GameState::Player& _internal_players(int index) const;
  ::GameState::Player* _internal_add_players();
  public:
  const ::GameState::Player& players(int index) const;
  ::GameState::Player* add_players();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::Player >&
      players() const;

  // repeated .GameState.Card Cards = 2;
  int cards_size() const;
  private:
  int _internal_cards_size() const;
  public:
  void clear_cards();
  ::GameState::Card* mutable_cards(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::Card >*
      mutable_cards();
  private:
  const ::GameState::Card& _internal_cards(int index) const;
  ::GameState::Card* _internal_add_cards();
  public:
  const ::GameState::Card& cards(int index) const;
  ::GameState::Card* add_cards();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::Card >&
      cards() const;

  // repeated .GameState.Tile Tiles = 3;
  int tiles_size() const;
  private:
  int _internal_tiles_size() const;
  public:
  void clear_tiles();
  ::GameState::Tile* mutable_tiles(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::Tile >*
      mutable_tiles();
  private:
  const ::GameState::Tile& _internal_tiles(int index) const;
  ::GameState::Tile* _internal_add_tiles();
  public:
  const ::GameState::Tile& tiles(int index) const;
  ::GameState::Tile* add_tiles();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::Tile >&
      tiles() const;

  // repeated .GameState.Team Teams = 4;
  int teams_size() const;
  private:
  int _internal_teams_size() const;
  public:
  void clear_teams();
  ::GameState::Team* mutable_teams(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::Team >*
      mutable_teams();
  private:
  const ::GameState::Team& _internal_teams(int index) const;
  ::GameState::Team* _internal_add_teams();
  public:
  const ::GameState::Team& teams(int index) const;
  ::GameState::Team* add_teams();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::Team >&
      teams() const;

  // repeated .GameState.Card Stack = 7;
  int stack_size() const;
  private:
  int _internal_stack_size() const;
  public:
  void clear_stack();
  ::GameState::Card* mutable_stack(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::Card >*
      mutable_stack();
  private:
  const ::GameState::Card& _internal_stack(int index) const;
  ::GameState::Card* _internal_add_stack();
  public:
  const ::GameState::Card& stack(int index) const;
  ::GameState::Card* add_stack();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::Card >&
      stack() const;

  // .Types.Integer TurnNumber = 6;
  bool has_turnnumber() const;
  private:
  bool _internal_has_turnnumber() const;
  public:
  void clear_turnnumber();
  const ::Types::Integer& turnnumber() const;
  ::Types::Integer* release_turnnumber();
  ::Types::Integer* mutable_turnnumber();
  void set_allocated_turnnumber(::Types::Integer* turnnumber);
  private:
  const ::Types::Integer& _internal_turnnumber() const;
  ::Types::Integer* _internal_mutable_turnnumber();
  public:
  void unsafe_arena_set_allocated_turnnumber(
      ::Types::Integer* turnnumber);
  ::Types::Integer* unsafe_arena_release_turnnumber();

  // @@protoc_insertion_point(class_scope:GameState.GameState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::Player > players_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::Card > cards_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::Tile > tiles_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::Team > teams_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::Card > stack_;
  ::Types::Integer* turnnumber_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameState_2eproto;
};
// -------------------------------------------------------------------

class GameInstance PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GameState.GameInstance) */ {
 public:
  inline GameInstance() : GameInstance(nullptr) {}
  virtual ~GameInstance();

  GameInstance(const GameInstance& from);
  GameInstance(GameInstance&& from) noexcept
    : GameInstance() {
    *this = ::std::move(from);
  }

  inline GameInstance& operator=(const GameInstance& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameInstance& operator=(GameInstance&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GameInstance& default_instance();

  static inline const GameInstance* internal_default_instance() {
    return reinterpret_cast<const GameInstance*>(
               &_GameInstance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(GameInstance& a, GameInstance& b) {
    a.Swap(&b);
  }
  inline void Swap(GameInstance* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameInstance* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GameInstance* New() const final {
    return CreateMaybeMessage<GameInstance>(nullptr);
  }

  GameInstance* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GameInstance>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GameInstance& from);
  void MergeFrom(const GameInstance& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameInstance* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GameState.GameInstance";
  }
  protected:
  explicit GameInstance(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GameState_2eproto);
    return ::descriptor_table_GameState_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHistoryFieldNumber = 2,
    kGameStateFieldNumber = 1,
  };
  // repeated .GameState.Mutation History = 2;
  int history_size() const;
  private:
  int _internal_history_size() const;
  public:
  void clear_history();
  ::GameState::Mutation* mutable_history(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::Mutation >*
      mutable_history();
  private:
  const ::GameState::Mutation& _internal_history(int index) const;
  ::GameState::Mutation* _internal_add_history();
  public:
  const ::GameState::Mutation& history(int index) const;
  ::GameState::Mutation* add_history();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::Mutation >&
      history() const;

  // .GameState.GameState GameState = 1;
  bool has_gamestate() const;
  private:
  bool _internal_has_gamestate() const;
  public:
  void clear_gamestate();
  const ::GameState::GameState& gamestate() const;
  ::GameState::GameState* release_gamestate();
  ::GameState::GameState* mutable_gamestate();
  void set_allocated_gamestate(::GameState::GameState* gamestate);
  private:
  const ::GameState::GameState& _internal_gamestate() const;
  ::GameState::GameState* _internal_mutable_gamestate();
  public:
  void unsafe_arena_set_allocated_gamestate(
      ::GameState::GameState* gamestate);
  ::GameState::GameState* unsafe_arena_release_gamestate();

  // @@protoc_insertion_point(class_scope:GameState.GameInstance)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::Mutation > history_;
  ::GameState::GameState* gamestate_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameState_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Player_Stats

// .Types.IntegerRef Health = 1;
inline bool Player_Stats::_internal_has_health() const {
  return this != internal_default_instance() && health_ != nullptr;
}
inline bool Player_Stats::has_health() const {
  return _internal_has_health();
}
inline const ::Types::IntegerRef& Player_Stats::_internal_health() const {
  const ::Types::IntegerRef* p = health_;
  return p != nullptr ? *p : reinterpret_cast<const ::Types::IntegerRef&>(
      ::Types::_IntegerRef_default_instance_);
}
inline const ::Types::IntegerRef& Player_Stats::health() const {
  // @@protoc_insertion_point(field_get:GameState.Player.Stats.Health)
  return _internal_health();
}
inline void Player_Stats::unsafe_arena_set_allocated_health(
    ::Types::IntegerRef* health) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(health_);
  }
  health_ = health;
  if (health) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.Player.Stats.Health)
}
inline ::Types::IntegerRef* Player_Stats::release_health() {
  
  ::Types::IntegerRef* temp = health_;
  health_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Types::IntegerRef* Player_Stats::unsafe_arena_release_health() {
  // @@protoc_insertion_point(field_release:GameState.Player.Stats.Health)
  
  ::Types::IntegerRef* temp = health_;
  health_ = nullptr;
  return temp;
}
inline ::Types::IntegerRef* Player_Stats::_internal_mutable_health() {
  
  if (health_ == nullptr) {
    auto* p = CreateMaybeMessage<::Types::IntegerRef>(GetArena());
    health_ = p;
  }
  return health_;
}
inline ::Types::IntegerRef* Player_Stats::mutable_health() {
  // @@protoc_insertion_point(field_mutable:GameState.Player.Stats.Health)
  return _internal_mutable_health();
}
inline void Player_Stats::set_allocated_health(::Types::IntegerRef* health) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(health_);
  }
  if (health) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(health)->GetArena();
    if (message_arena != submessage_arena) {
      health = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, health, submessage_arena);
    }
    
  } else {
    
  }
  health_ = health;
  // @@protoc_insertion_point(field_set_allocated:GameState.Player.Stats.Health)
}

// .Types.IntegerRef Actions = 2;
inline bool Player_Stats::_internal_has_actions() const {
  return this != internal_default_instance() && actions_ != nullptr;
}
inline bool Player_Stats::has_actions() const {
  return _internal_has_actions();
}
inline const ::Types::IntegerRef& Player_Stats::_internal_actions() const {
  const ::Types::IntegerRef* p = actions_;
  return p != nullptr ? *p : reinterpret_cast<const ::Types::IntegerRef&>(
      ::Types::_IntegerRef_default_instance_);
}
inline const ::Types::IntegerRef& Player_Stats::actions() const {
  // @@protoc_insertion_point(field_get:GameState.Player.Stats.Actions)
  return _internal_actions();
}
inline void Player_Stats::unsafe_arena_set_allocated_actions(
    ::Types::IntegerRef* actions) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(actions_);
  }
  actions_ = actions;
  if (actions) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.Player.Stats.Actions)
}
inline ::Types::IntegerRef* Player_Stats::release_actions() {
  
  ::Types::IntegerRef* temp = actions_;
  actions_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Types::IntegerRef* Player_Stats::unsafe_arena_release_actions() {
  // @@protoc_insertion_point(field_release:GameState.Player.Stats.Actions)
  
  ::Types::IntegerRef* temp = actions_;
  actions_ = nullptr;
  return temp;
}
inline ::Types::IntegerRef* Player_Stats::_internal_mutable_actions() {
  
  if (actions_ == nullptr) {
    auto* p = CreateMaybeMessage<::Types::IntegerRef>(GetArena());
    actions_ = p;
  }
  return actions_;
}
inline ::Types::IntegerRef* Player_Stats::mutable_actions() {
  // @@protoc_insertion_point(field_mutable:GameState.Player.Stats.Actions)
  return _internal_mutable_actions();
}
inline void Player_Stats::set_allocated_actions(::Types::IntegerRef* actions) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(actions_);
  }
  if (actions) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(actions)->GetArena();
    if (message_arena != submessage_arena) {
      actions = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, actions, submessage_arena);
    }
    
  } else {
    
  }
  actions_ = actions;
  // @@protoc_insertion_point(field_set_allocated:GameState.Player.Stats.Actions)
}

// .Types.IntegerRef Power = 3;
inline bool Player_Stats::_internal_has_power() const {
  return this != internal_default_instance() && power_ != nullptr;
}
inline bool Player_Stats::has_power() const {
  return _internal_has_power();
}
inline const ::Types::IntegerRef& Player_Stats::_internal_power() const {
  const ::Types::IntegerRef* p = power_;
  return p != nullptr ? *p : reinterpret_cast<const ::Types::IntegerRef&>(
      ::Types::_IntegerRef_default_instance_);
}
inline const ::Types::IntegerRef& Player_Stats::power() const {
  // @@protoc_insertion_point(field_get:GameState.Player.Stats.Power)
  return _internal_power();
}
inline void Player_Stats::unsafe_arena_set_allocated_power(
    ::Types::IntegerRef* power) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(power_);
  }
  power_ = power;
  if (power) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.Player.Stats.Power)
}
inline ::Types::IntegerRef* Player_Stats::release_power() {
  
  ::Types::IntegerRef* temp = power_;
  power_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Types::IntegerRef* Player_Stats::unsafe_arena_release_power() {
  // @@protoc_insertion_point(field_release:GameState.Player.Stats.Power)
  
  ::Types::IntegerRef* temp = power_;
  power_ = nullptr;
  return temp;
}
inline ::Types::IntegerRef* Player_Stats::_internal_mutable_power() {
  
  if (power_ == nullptr) {
    auto* p = CreateMaybeMessage<::Types::IntegerRef>(GetArena());
    power_ = p;
  }
  return power_;
}
inline ::Types::IntegerRef* Player_Stats::mutable_power() {
  // @@protoc_insertion_point(field_mutable:GameState.Player.Stats.Power)
  return _internal_mutable_power();
}
inline void Player_Stats::set_allocated_power(::Types::IntegerRef* power) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(power_);
  }
  if (power) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(power)->GetArena();
    if (message_arena != submessage_arena) {
      power = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, power, submessage_arena);
    }
    
  } else {
    
  }
  power_ = power;
  // @@protoc_insertion_point(field_set_allocated:GameState.Player.Stats.Power)
}

// .Types.IntegerRef Slow = 4;
inline bool Player_Stats::_internal_has_slow() const {
  return this != internal_default_instance() && slow_ != nullptr;
}
inline bool Player_Stats::has_slow() const {
  return _internal_has_slow();
}
inline const ::Types::IntegerRef& Player_Stats::_internal_slow() const {
  const ::Types::IntegerRef* p = slow_;
  return p != nullptr ? *p : reinterpret_cast<const ::Types::IntegerRef&>(
      ::Types::_IntegerRef_default_instance_);
}
inline const ::Types::IntegerRef& Player_Stats::slow() const {
  // @@protoc_insertion_point(field_get:GameState.Player.Stats.Slow)
  return _internal_slow();
}
inline void Player_Stats::unsafe_arena_set_allocated_slow(
    ::Types::IntegerRef* slow) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(slow_);
  }
  slow_ = slow;
  if (slow) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.Player.Stats.Slow)
}
inline ::Types::IntegerRef* Player_Stats::release_slow() {
  
  ::Types::IntegerRef* temp = slow_;
  slow_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Types::IntegerRef* Player_Stats::unsafe_arena_release_slow() {
  // @@protoc_insertion_point(field_release:GameState.Player.Stats.Slow)
  
  ::Types::IntegerRef* temp = slow_;
  slow_ = nullptr;
  return temp;
}
inline ::Types::IntegerRef* Player_Stats::_internal_mutable_slow() {
  
  if (slow_ == nullptr) {
    auto* p = CreateMaybeMessage<::Types::IntegerRef>(GetArena());
    slow_ = p;
  }
  return slow_;
}
inline ::Types::IntegerRef* Player_Stats::mutable_slow() {
  // @@protoc_insertion_point(field_mutable:GameState.Player.Stats.Slow)
  return _internal_mutable_slow();
}
inline void Player_Stats::set_allocated_slow(::Types::IntegerRef* slow) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(slow_);
  }
  if (slow) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(slow)->GetArena();
    if (message_arena != submessage_arena) {
      slow = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, slow, submessage_arena);
    }
    
  } else {
    
  }
  slow_ = slow;
  // @@protoc_insertion_point(field_set_allocated:GameState.Player.Stats.Slow)
}

// .Types.IntegerRef Silence = 5;
inline bool Player_Stats::_internal_has_silence() const {
  return this != internal_default_instance() && silence_ != nullptr;
}
inline bool Player_Stats::has_silence() const {
  return _internal_has_silence();
}
inline const ::Types::IntegerRef& Player_Stats::_internal_silence() const {
  const ::Types::IntegerRef* p = silence_;
  return p != nullptr ? *p : reinterpret_cast<const ::Types::IntegerRef&>(
      ::Types::_IntegerRef_default_instance_);
}
inline const ::Types::IntegerRef& Player_Stats::silence() const {
  // @@protoc_insertion_point(field_get:GameState.Player.Stats.Silence)
  return _internal_silence();
}
inline void Player_Stats::unsafe_arena_set_allocated_silence(
    ::Types::IntegerRef* silence) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(silence_);
  }
  silence_ = silence;
  if (silence) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.Player.Stats.Silence)
}
inline ::Types::IntegerRef* Player_Stats::release_silence() {
  
  ::Types::IntegerRef* temp = silence_;
  silence_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Types::IntegerRef* Player_Stats::unsafe_arena_release_silence() {
  // @@protoc_insertion_point(field_release:GameState.Player.Stats.Silence)
  
  ::Types::IntegerRef* temp = silence_;
  silence_ = nullptr;
  return temp;
}
inline ::Types::IntegerRef* Player_Stats::_internal_mutable_silence() {
  
  if (silence_ == nullptr) {
    auto* p = CreateMaybeMessage<::Types::IntegerRef>(GetArena());
    silence_ = p;
  }
  return silence_;
}
inline ::Types::IntegerRef* Player_Stats::mutable_silence() {
  // @@protoc_insertion_point(field_mutable:GameState.Player.Stats.Silence)
  return _internal_mutable_silence();
}
inline void Player_Stats::set_allocated_silence(::Types::IntegerRef* silence) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(silence_);
  }
  if (silence) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(silence)->GetArena();
    if (message_arena != submessage_arena) {
      silence = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, silence, submessage_arena);
    }
    
  } else {
    
  }
  silence_ = silence;
  // @@protoc_insertion_point(field_set_allocated:GameState.Player.Stats.Silence)
}

// .Types.IntegerRef Disarm = 6;
inline bool Player_Stats::_internal_has_disarm() const {
  return this != internal_default_instance() && disarm_ != nullptr;
}
inline bool Player_Stats::has_disarm() const {
  return _internal_has_disarm();
}
inline const ::Types::IntegerRef& Player_Stats::_internal_disarm() const {
  const ::Types::IntegerRef* p = disarm_;
  return p != nullptr ? *p : reinterpret_cast<const ::Types::IntegerRef&>(
      ::Types::_IntegerRef_default_instance_);
}
inline const ::Types::IntegerRef& Player_Stats::disarm() const {
  // @@protoc_insertion_point(field_get:GameState.Player.Stats.Disarm)
  return _internal_disarm();
}
inline void Player_Stats::unsafe_arena_set_allocated_disarm(
    ::Types::IntegerRef* disarm) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(disarm_);
  }
  disarm_ = disarm;
  if (disarm) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.Player.Stats.Disarm)
}
inline ::Types::IntegerRef* Player_Stats::release_disarm() {
  
  ::Types::IntegerRef* temp = disarm_;
  disarm_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Types::IntegerRef* Player_Stats::unsafe_arena_release_disarm() {
  // @@protoc_insertion_point(field_release:GameState.Player.Stats.Disarm)
  
  ::Types::IntegerRef* temp = disarm_;
  disarm_ = nullptr;
  return temp;
}
inline ::Types::IntegerRef* Player_Stats::_internal_mutable_disarm() {
  
  if (disarm_ == nullptr) {
    auto* p = CreateMaybeMessage<::Types::IntegerRef>(GetArena());
    disarm_ = p;
  }
  return disarm_;
}
inline ::Types::IntegerRef* Player_Stats::mutable_disarm() {
  // @@protoc_insertion_point(field_mutable:GameState.Player.Stats.Disarm)
  return _internal_mutable_disarm();
}
inline void Player_Stats::set_allocated_disarm(::Types::IntegerRef* disarm) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(disarm_);
  }
  if (disarm) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(disarm)->GetArena();
    if (message_arena != submessage_arena) {
      disarm = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, disarm, submessage_arena);
    }
    
  } else {
    
  }
  disarm_ = disarm;
  // @@protoc_insertion_point(field_set_allocated:GameState.Player.Stats.Disarm)
}

// .Types.IntegerRef Initiative = 7;
inline bool Player_Stats::_internal_has_initiative() const {
  return this != internal_default_instance() && initiative_ != nullptr;
}
inline bool Player_Stats::has_initiative() const {
  return _internal_has_initiative();
}
inline const ::Types::IntegerRef& Player_Stats::_internal_initiative() const {
  const ::Types::IntegerRef* p = initiative_;
  return p != nullptr ? *p : reinterpret_cast<const ::Types::IntegerRef&>(
      ::Types::_IntegerRef_default_instance_);
}
inline const ::Types::IntegerRef& Player_Stats::initiative() const {
  // @@protoc_insertion_point(field_get:GameState.Player.Stats.Initiative)
  return _internal_initiative();
}
inline void Player_Stats::unsafe_arena_set_allocated_initiative(
    ::Types::IntegerRef* initiative) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(initiative_);
  }
  initiative_ = initiative;
  if (initiative) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.Player.Stats.Initiative)
}
inline ::Types::IntegerRef* Player_Stats::release_initiative() {
  
  ::Types::IntegerRef* temp = initiative_;
  initiative_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Types::IntegerRef* Player_Stats::unsafe_arena_release_initiative() {
  // @@protoc_insertion_point(field_release:GameState.Player.Stats.Initiative)
  
  ::Types::IntegerRef* temp = initiative_;
  initiative_ = nullptr;
  return temp;
}
inline ::Types::IntegerRef* Player_Stats::_internal_mutable_initiative() {
  
  if (initiative_ == nullptr) {
    auto* p = CreateMaybeMessage<::Types::IntegerRef>(GetArena());
    initiative_ = p;
  }
  return initiative_;
}
inline ::Types::IntegerRef* Player_Stats::mutable_initiative() {
  // @@protoc_insertion_point(field_mutable:GameState.Player.Stats.Initiative)
  return _internal_mutable_initiative();
}
inline void Player_Stats::set_allocated_initiative(::Types::IntegerRef* initiative) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(initiative_);
  }
  if (initiative) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(initiative)->GetArena();
    if (message_arena != submessage_arena) {
      initiative = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, initiative, submessage_arena);
    }
    
  } else {
    
  }
  initiative_ = initiative;
  // @@protoc_insertion_point(field_set_allocated:GameState.Player.Stats.Initiative)
}

// -------------------------------------------------------------------

// Player

// string DisplayName = 1;
inline void Player::clear_displayname() {
  displayname_.ClearToEmpty();
}
inline const std::string& Player::displayname() const {
  // @@protoc_insertion_point(field_get:GameState.Player.DisplayName)
  return _internal_displayname();
}
inline void Player::set_displayname(const std::string& value) {
  _internal_set_displayname(value);
  // @@protoc_insertion_point(field_set:GameState.Player.DisplayName)
}
inline std::string* Player::mutable_displayname() {
  // @@protoc_insertion_point(field_mutable:GameState.Player.DisplayName)
  return _internal_mutable_displayname();
}
inline const std::string& Player::_internal_displayname() const {
  return displayname_.Get();
}
inline void Player::_internal_set_displayname(const std::string& value) {
  
  displayname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Player::set_displayname(std::string&& value) {
  
  displayname_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:GameState.Player.DisplayName)
}
inline void Player::set_displayname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  displayname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:GameState.Player.DisplayName)
}
inline void Player::set_displayname(const char* value,
    size_t size) {
  
  displayname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:GameState.Player.DisplayName)
}
inline std::string* Player::_internal_mutable_displayname() {
  
  return displayname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Player::release_displayname() {
  // @@protoc_insertion_point(field_release:GameState.Player.DisplayName)
  return displayname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Player::set_allocated_displayname(std::string* displayname) {
  if (displayname != nullptr) {
    
  } else {
    
  }
  displayname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), displayname,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:GameState.Player.DisplayName)
}

// string UID = 2;
inline void Player::clear_uid() {
  uid_.ClearToEmpty();
}
inline const std::string& Player::uid() const {
  // @@protoc_insertion_point(field_get:GameState.Player.UID)
  return _internal_uid();
}
inline void Player::set_uid(const std::string& value) {
  _internal_set_uid(value);
  // @@protoc_insertion_point(field_set:GameState.Player.UID)
}
inline std::string* Player::mutable_uid() {
  // @@protoc_insertion_point(field_mutable:GameState.Player.UID)
  return _internal_mutable_uid();
}
inline const std::string& Player::_internal_uid() const {
  return uid_.Get();
}
inline void Player::_internal_set_uid(const std::string& value) {
  
  uid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Player::set_uid(std::string&& value) {
  
  uid_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:GameState.Player.UID)
}
inline void Player::set_uid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  uid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:GameState.Player.UID)
}
inline void Player::set_uid(const char* value,
    size_t size) {
  
  uid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:GameState.Player.UID)
}
inline std::string* Player::_internal_mutable_uid() {
  
  return uid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Player::release_uid() {
  // @@protoc_insertion_point(field_release:GameState.Player.UID)
  return uid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Player::set_allocated_uid(std::string* uid) {
  if (uid != nullptr) {
    
  } else {
    
  }
  uid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:GameState.Player.UID)
}

// repeated .Types.CardRef Field = 3;
inline int Player::_internal_field_size() const {
  return field_.size();
}
inline int Player::field_size() const {
  return _internal_field_size();
}
inline ::Types::CardRef* Player::mutable_field(int index) {
  // @@protoc_insertion_point(field_mutable:GameState.Player.Field)
  return field_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Types::CardRef >*
Player::mutable_field() {
  // @@protoc_insertion_point(field_mutable_list:GameState.Player.Field)
  return &field_;
}
inline const ::Types::CardRef& Player::_internal_field(int index) const {
  return field_.Get(index);
}
inline const ::Types::CardRef& Player::field(int index) const {
  // @@protoc_insertion_point(field_get:GameState.Player.Field)
  return _internal_field(index);
}
inline ::Types::CardRef* Player::_internal_add_field() {
  return field_.Add();
}
inline ::Types::CardRef* Player::add_field() {
  // @@protoc_insertion_point(field_add:GameState.Player.Field)
  return _internal_add_field();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Types::CardRef >&
Player::field() const {
  // @@protoc_insertion_point(field_list:GameState.Player.Field)
  return field_;
}

// repeated .Types.CardRef Hand = 4;
inline int Player::_internal_hand_size() const {
  return hand_.size();
}
inline int Player::hand_size() const {
  return _internal_hand_size();
}
inline ::Types::CardRef* Player::mutable_hand(int index) {
  // @@protoc_insertion_point(field_mutable:GameState.Player.Hand)
  return hand_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Types::CardRef >*
Player::mutable_hand() {
  // @@protoc_insertion_point(field_mutable_list:GameState.Player.Hand)
  return &hand_;
}
inline const ::Types::CardRef& Player::_internal_hand(int index) const {
  return hand_.Get(index);
}
inline const ::Types::CardRef& Player::hand(int index) const {
  // @@protoc_insertion_point(field_get:GameState.Player.Hand)
  return _internal_hand(index);
}
inline ::Types::CardRef* Player::_internal_add_hand() {
  return hand_.Add();
}
inline ::Types::CardRef* Player::add_hand() {
  // @@protoc_insertion_point(field_add:GameState.Player.Hand)
  return _internal_add_hand();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Types::CardRef >&
Player::hand() const {
  // @@protoc_insertion_point(field_list:GameState.Player.Hand)
  return hand_;
}

// repeated .Types.CardRef Deck = 5;
inline int Player::_internal_deck_size() const {
  return deck_.size();
}
inline int Player::deck_size() const {
  return _internal_deck_size();
}
inline ::Types::CardRef* Player::mutable_deck(int index) {
  // @@protoc_insertion_point(field_mutable:GameState.Player.Deck)
  return deck_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Types::CardRef >*
Player::mutable_deck() {
  // @@protoc_insertion_point(field_mutable_list:GameState.Player.Deck)
  return &deck_;
}
inline const ::Types::CardRef& Player::_internal_deck(int index) const {
  return deck_.Get(index);
}
inline const ::Types::CardRef& Player::deck(int index) const {
  // @@protoc_insertion_point(field_get:GameState.Player.Deck)
  return _internal_deck(index);
}
inline ::Types::CardRef* Player::_internal_add_deck() {
  return deck_.Add();
}
inline ::Types::CardRef* Player::add_deck() {
  // @@protoc_insertion_point(field_add:GameState.Player.Deck)
  return _internal_add_deck();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Types::CardRef >&
Player::deck() const {
  // @@protoc_insertion_point(field_list:GameState.Player.Deck)
  return deck_;
}

// repeated .Types.CardRef Discard = 6;
inline int Player::_internal_discard_size() const {
  return discard_.size();
}
inline int Player::discard_size() const {
  return _internal_discard_size();
}
inline ::Types::CardRef* Player::mutable_discard(int index) {
  // @@protoc_insertion_point(field_mutable:GameState.Player.Discard)
  return discard_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Types::CardRef >*
Player::mutable_discard() {
  // @@protoc_insertion_point(field_mutable_list:GameState.Player.Discard)
  return &discard_;
}
inline const ::Types::CardRef& Player::_internal_discard(int index) const {
  return discard_.Get(index);
}
inline const ::Types::CardRef& Player::discard(int index) const {
  // @@protoc_insertion_point(field_get:GameState.Player.Discard)
  return _internal_discard(index);
}
inline ::Types::CardRef* Player::_internal_add_discard() {
  return discard_.Add();
}
inline ::Types::CardRef* Player::add_discard() {
  // @@protoc_insertion_point(field_add:GameState.Player.Discard)
  return _internal_add_discard();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Types::CardRef >&
Player::discard() const {
  // @@protoc_insertion_point(field_list:GameState.Player.Discard)
  return discard_;
}

// repeated .Types.CardRef Feats = 7;
inline int Player::_internal_feats_size() const {
  return feats_.size();
}
inline int Player::feats_size() const {
  return _internal_feats_size();
}
inline ::Types::CardRef* Player::mutable_feats(int index) {
  // @@protoc_insertion_point(field_mutable:GameState.Player.Feats)
  return feats_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Types::CardRef >*
Player::mutable_feats() {
  // @@protoc_insertion_point(field_mutable_list:GameState.Player.Feats)
  return &feats_;
}
inline const ::Types::CardRef& Player::_internal_feats(int index) const {
  return feats_.Get(index);
}
inline const ::Types::CardRef& Player::feats(int index) const {
  // @@protoc_insertion_point(field_get:GameState.Player.Feats)
  return _internal_feats(index);
}
inline ::Types::CardRef* Player::_internal_add_feats() {
  return feats_.Add();
}
inline ::Types::CardRef* Player::add_feats() {
  // @@protoc_insertion_point(field_add:GameState.Player.Feats)
  return _internal_add_feats();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Types::CardRef >&
Player::feats() const {
  // @@protoc_insertion_point(field_list:GameState.Player.Feats)
  return feats_;
}

// .GameState.Player.Stats State = 8;
inline bool Player::_internal_has_state() const {
  return this != internal_default_instance() && state_ != nullptr;
}
inline bool Player::has_state() const {
  return _internal_has_state();
}
inline void Player::clear_state() {
  if (GetArena() == nullptr && state_ != nullptr) {
    delete state_;
  }
  state_ = nullptr;
}
inline const ::GameState::Player_Stats& Player::_internal_state() const {
  const ::GameState::Player_Stats* p = state_;
  return p != nullptr ? *p : reinterpret_cast<const ::GameState::Player_Stats&>(
      ::GameState::_Player_Stats_default_instance_);
}
inline const ::GameState::Player_Stats& Player::state() const {
  // @@protoc_insertion_point(field_get:GameState.Player.State)
  return _internal_state();
}
inline void Player::unsafe_arena_set_allocated_state(
    ::GameState::Player_Stats* state) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(state_);
  }
  state_ = state;
  if (state) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.Player.State)
}
inline ::GameState::Player_Stats* Player::release_state() {
  
  ::GameState::Player_Stats* temp = state_;
  state_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::GameState::Player_Stats* Player::unsafe_arena_release_state() {
  // @@protoc_insertion_point(field_release:GameState.Player.State)
  
  ::GameState::Player_Stats* temp = state_;
  state_ = nullptr;
  return temp;
}
inline ::GameState::Player_Stats* Player::_internal_mutable_state() {
  
  if (state_ == nullptr) {
    auto* p = CreateMaybeMessage<::GameState::Player_Stats>(GetArena());
    state_ = p;
  }
  return state_;
}
inline ::GameState::Player_Stats* Player::mutable_state() {
  // @@protoc_insertion_point(field_mutable:GameState.Player.State)
  return _internal_mutable_state();
}
inline void Player::set_allocated_state(::GameState::Player_Stats* state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete state_;
  }
  if (state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(state);
    if (message_arena != submessage_arena) {
      state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    
  } else {
    
  }
  state_ = state;
  // @@protoc_insertion_point(field_set_allocated:GameState.Player.State)
}

// .GameState.Player.Stats MaxState = 9;
inline bool Player::_internal_has_maxstate() const {
  return this != internal_default_instance() && maxstate_ != nullptr;
}
inline bool Player::has_maxstate() const {
  return _internal_has_maxstate();
}
inline void Player::clear_maxstate() {
  if (GetArena() == nullptr && maxstate_ != nullptr) {
    delete maxstate_;
  }
  maxstate_ = nullptr;
}
inline const ::GameState::Player_Stats& Player::_internal_maxstate() const {
  const ::GameState::Player_Stats* p = maxstate_;
  return p != nullptr ? *p : reinterpret_cast<const ::GameState::Player_Stats&>(
      ::GameState::_Player_Stats_default_instance_);
}
inline const ::GameState::Player_Stats& Player::maxstate() const {
  // @@protoc_insertion_point(field_get:GameState.Player.MaxState)
  return _internal_maxstate();
}
inline void Player::unsafe_arena_set_allocated_maxstate(
    ::GameState::Player_Stats* maxstate) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(maxstate_);
  }
  maxstate_ = maxstate;
  if (maxstate) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.Player.MaxState)
}
inline ::GameState::Player_Stats* Player::release_maxstate() {
  
  ::GameState::Player_Stats* temp = maxstate_;
  maxstate_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::GameState::Player_Stats* Player::unsafe_arena_release_maxstate() {
  // @@protoc_insertion_point(field_release:GameState.Player.MaxState)
  
  ::GameState::Player_Stats* temp = maxstate_;
  maxstate_ = nullptr;
  return temp;
}
inline ::GameState::Player_Stats* Player::_internal_mutable_maxstate() {
  
  if (maxstate_ == nullptr) {
    auto* p = CreateMaybeMessage<::GameState::Player_Stats>(GetArena());
    maxstate_ = p;
  }
  return maxstate_;
}
inline ::GameState::Player_Stats* Player::mutable_maxstate() {
  // @@protoc_insertion_point(field_mutable:GameState.Player.MaxState)
  return _internal_mutable_maxstate();
}
inline void Player::set_allocated_maxstate(::GameState::Player_Stats* maxstate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete maxstate_;
  }
  if (maxstate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(maxstate);
    if (message_arena != submessage_arena) {
      maxstate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, maxstate, submessage_arena);
    }
    
  } else {
    
  }
  maxstate_ = maxstate;
  // @@protoc_insertion_point(field_set_allocated:GameState.Player.MaxState)
}

// .Types.Vec2iRef Position = 10;
inline bool Player::_internal_has_position() const {
  return this != internal_default_instance() && position_ != nullptr;
}
inline bool Player::has_position() const {
  return _internal_has_position();
}
inline const ::Types::Vec2iRef& Player::_internal_position() const {
  const ::Types::Vec2iRef* p = position_;
  return p != nullptr ? *p : reinterpret_cast<const ::Types::Vec2iRef&>(
      ::Types::_Vec2iRef_default_instance_);
}
inline const ::Types::Vec2iRef& Player::position() const {
  // @@protoc_insertion_point(field_get:GameState.Player.Position)
  return _internal_position();
}
inline void Player::unsafe_arena_set_allocated_position(
    ::Types::Vec2iRef* position) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.Player.Position)
}
inline ::Types::Vec2iRef* Player::release_position() {
  
  ::Types::Vec2iRef* temp = position_;
  position_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Types::Vec2iRef* Player::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:GameState.Player.Position)
  
  ::Types::Vec2iRef* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::Types::Vec2iRef* Player::_internal_mutable_position() {
  
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::Types::Vec2iRef>(GetArena());
    position_ = p;
  }
  return position_;
}
inline ::Types::Vec2iRef* Player::mutable_position() {
  // @@protoc_insertion_point(field_mutable:GameState.Player.Position)
  return _internal_mutable_position();
}
inline void Player::set_allocated_position(::Types::Vec2iRef* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position)->GetArena();
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:GameState.Player.Position)
}

// -------------------------------------------------------------------

// Tile

// .Types.Vec2i Position = 1;
inline bool Tile::_internal_has_position() const {
  return this != internal_default_instance() && position_ != nullptr;
}
inline bool Tile::has_position() const {
  return _internal_has_position();
}
inline const ::Types::Vec2i& Tile::_internal_position() const {
  const ::Types::Vec2i* p = position_;
  return p != nullptr ? *p : reinterpret_cast<const ::Types::Vec2i&>(
      ::Types::_Vec2i_default_instance_);
}
inline const ::Types::Vec2i& Tile::position() const {
  // @@protoc_insertion_point(field_get:GameState.Tile.Position)
  return _internal_position();
}
inline void Tile::unsafe_arena_set_allocated_position(
    ::Types::Vec2i* position) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.Tile.Position)
}
inline ::Types::Vec2i* Tile::release_position() {
  
  ::Types::Vec2i* temp = position_;
  position_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Types::Vec2i* Tile::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:GameState.Tile.Position)
  
  ::Types::Vec2i* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::Types::Vec2i* Tile::_internal_mutable_position() {
  
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::Types::Vec2i>(GetArena());
    position_ = p;
  }
  return position_;
}
inline ::Types::Vec2i* Tile::mutable_position() {
  // @@protoc_insertion_point(field_mutable:GameState.Tile.Position)
  return _internal_mutable_position();
}
inline void Tile::set_allocated_position(::Types::Vec2i* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position)->GetArena();
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:GameState.Tile.Position)
}

// .Types.TerrainType Terrain = 2;
inline void Tile::clear_terrain() {
  terrain_ = 0;
}
inline ::Types::TerrainType Tile::_internal_terrain() const {
  return static_cast< ::Types::TerrainType >(terrain_);
}
inline ::Types::TerrainType Tile::terrain() const {
  // @@protoc_insertion_point(field_get:GameState.Tile.Terrain)
  return _internal_terrain();
}
inline void Tile::_internal_set_terrain(::Types::TerrainType value) {
  
  terrain_ = value;
}
inline void Tile::set_terrain(::Types::TerrainType value) {
  _internal_set_terrain(value);
  // @@protoc_insertion_point(field_set:GameState.Tile.Terrain)
}

// repeated .Types.PlayerRef Players = 3;
inline int Tile::_internal_players_size() const {
  return players_.size();
}
inline int Tile::players_size() const {
  return _internal_players_size();
}
inline ::Types::PlayerRef* Tile::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:GameState.Tile.Players)
  return players_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Types::PlayerRef >*
Tile::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:GameState.Tile.Players)
  return &players_;
}
inline const ::Types::PlayerRef& Tile::_internal_players(int index) const {
  return players_.Get(index);
}
inline const ::Types::PlayerRef& Tile::players(int index) const {
  // @@protoc_insertion_point(field_get:GameState.Tile.Players)
  return _internal_players(index);
}
inline ::Types::PlayerRef* Tile::_internal_add_players() {
  return players_.Add();
}
inline ::Types::PlayerRef* Tile::add_players() {
  // @@protoc_insertion_point(field_add:GameState.Tile.Players)
  return _internal_add_players();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Types::PlayerRef >&
Tile::players() const {
  // @@protoc_insertion_point(field_list:GameState.Tile.Players)
  return players_;
}

// repeated .Types.CardRef Cards = 4;
inline int Tile::_internal_cards_size() const {
  return cards_.size();
}
inline int Tile::cards_size() const {
  return _internal_cards_size();
}
inline ::Types::CardRef* Tile::mutable_cards(int index) {
  // @@protoc_insertion_point(field_mutable:GameState.Tile.Cards)
  return cards_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Types::CardRef >*
Tile::mutable_cards() {
  // @@protoc_insertion_point(field_mutable_list:GameState.Tile.Cards)
  return &cards_;
}
inline const ::Types::CardRef& Tile::_internal_cards(int index) const {
  return cards_.Get(index);
}
inline const ::Types::CardRef& Tile::cards(int index) const {
  // @@protoc_insertion_point(field_get:GameState.Tile.Cards)
  return _internal_cards(index);
}
inline ::Types::CardRef* Tile::_internal_add_cards() {
  return cards_.Add();
}
inline ::Types::CardRef* Tile::add_cards() {
  // @@protoc_insertion_point(field_add:GameState.Tile.Cards)
  return _internal_add_cards();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Types::CardRef >&
Tile::cards() const {
  // @@protoc_insertion_point(field_list:GameState.Tile.Cards)
  return cards_;
}

// -------------------------------------------------------------------

// Card

// string Name = 1;
inline void Card::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Card::name() const {
  // @@protoc_insertion_point(field_get:GameState.Card.Name)
  return _internal_name();
}
inline void Card::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:GameState.Card.Name)
}
inline std::string* Card::mutable_name() {
  // @@protoc_insertion_point(field_mutable:GameState.Card.Name)
  return _internal_mutable_name();
}
inline const std::string& Card::_internal_name() const {
  return name_.Get();
}
inline void Card::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Card::set_name(std::string&& value) {
  
  name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:GameState.Card.Name)
}
inline void Card::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:GameState.Card.Name)
}
inline void Card::set_name(const char* value,
    size_t size) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:GameState.Card.Name)
}
inline std::string* Card::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Card::release_name() {
  // @@protoc_insertion_point(field_release:GameState.Card.Name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Card::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:GameState.Card.Name)
}

// string Archetype = 2;
inline void Card::clear_archetype() {
  archetype_.ClearToEmpty();
}
inline const std::string& Card::archetype() const {
  // @@protoc_insertion_point(field_get:GameState.Card.Archetype)
  return _internal_archetype();
}
inline void Card::set_archetype(const std::string& value) {
  _internal_set_archetype(value);
  // @@protoc_insertion_point(field_set:GameState.Card.Archetype)
}
inline std::string* Card::mutable_archetype() {
  // @@protoc_insertion_point(field_mutable:GameState.Card.Archetype)
  return _internal_mutable_archetype();
}
inline const std::string& Card::_internal_archetype() const {
  return archetype_.Get();
}
inline void Card::_internal_set_archetype(const std::string& value) {
  
  archetype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Card::set_archetype(std::string&& value) {
  
  archetype_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:GameState.Card.Archetype)
}
inline void Card::set_archetype(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  archetype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:GameState.Card.Archetype)
}
inline void Card::set_archetype(const char* value,
    size_t size) {
  
  archetype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:GameState.Card.Archetype)
}
inline std::string* Card::_internal_mutable_archetype() {
  
  return archetype_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Card::release_archetype() {
  // @@protoc_insertion_point(field_release:GameState.Card.Archetype)
  return archetype_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Card::set_allocated_archetype(std::string* archetype) {
  if (archetype != nullptr) {
    
  } else {
    
  }
  archetype_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), archetype,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:GameState.Card.Archetype)
}

// bool Ultimate = 3;
inline void Card::clear_ultimate() {
  ultimate_ = false;
}
inline bool Card::_internal_ultimate() const {
  return ultimate_;
}
inline bool Card::ultimate() const {
  // @@protoc_insertion_point(field_get:GameState.Card.Ultimate)
  return _internal_ultimate();
}
inline void Card::_internal_set_ultimate(bool value) {
  
  ultimate_ = value;
}
inline void Card::set_ultimate(bool value) {
  _internal_set_ultimate(value);
  // @@protoc_insertion_point(field_set:GameState.Card.Ultimate)
}

// bool Feat = 4;
inline void Card::clear_feat() {
  feat_ = false;
}
inline bool Card::_internal_feat() const {
  return feat_;
}
inline bool Card::feat() const {
  // @@protoc_insertion_point(field_get:GameState.Card.Feat)
  return _internal_feat();
}
inline void Card::_internal_set_feat(bool value) {
  
  feat_ = value;
}
inline void Card::set_feat(bool value) {
  _internal_set_feat(value);
  // @@protoc_insertion_point(field_set:GameState.Card.Feat)
}

// bool BasicAction = 5;
inline void Card::clear_basicaction() {
  basicaction_ = false;
}
inline bool Card::_internal_basicaction() const {
  return basicaction_;
}
inline bool Card::basicaction() const {
  // @@protoc_insertion_point(field_get:GameState.Card.BasicAction)
  return _internal_basicaction();
}
inline void Card::_internal_set_basicaction(bool value) {
  
  basicaction_ = value;
}
inline void Card::set_basicaction(bool value) {
  _internal_set_basicaction(value);
  // @@protoc_insertion_point(field_set:GameState.Card.BasicAction)
}

// repeated .GameState.Card.Color Colors = 6;
inline int Card::_internal_colors_size() const {
  return colors_.size();
}
inline int Card::colors_size() const {
  return _internal_colors_size();
}
inline void Card::clear_colors() {
  colors_.Clear();
}
inline ::GameState::Card_Color Card::_internal_colors(int index) const {
  return static_cast< ::GameState::Card_Color >(colors_.Get(index));
}
inline ::GameState::Card_Color Card::colors(int index) const {
  // @@protoc_insertion_point(field_get:GameState.Card.Colors)
  return _internal_colors(index);
}
inline void Card::set_colors(int index, ::GameState::Card_Color value) {
  colors_.Set(index, value);
  // @@protoc_insertion_point(field_set:GameState.Card.Colors)
}
inline void Card::_internal_add_colors(::GameState::Card_Color value) {
  colors_.Add(value);
}
inline void Card::add_colors(::GameState::Card_Color value) {
  // @@protoc_insertion_point(field_add:GameState.Card.Colors)
  _internal_add_colors(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
Card::colors() const {
  // @@protoc_insertion_point(field_list:GameState.Card.Colors)
  return colors_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
Card::_internal_mutable_colors() {
  return &colors_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
Card::mutable_colors() {
  // @@protoc_insertion_point(field_mutable_list:GameState.Card.Colors)
  return _internal_mutable_colors();
}

// .Types.PlayerRef Owner = 7;
inline bool Card::_internal_has_owner() const {
  return this != internal_default_instance() && owner_ != nullptr;
}
inline bool Card::has_owner() const {
  return _internal_has_owner();
}
inline const ::Types::PlayerRef& Card::_internal_owner() const {
  const ::Types::PlayerRef* p = owner_;
  return p != nullptr ? *p : reinterpret_cast<const ::Types::PlayerRef&>(
      ::Types::_PlayerRef_default_instance_);
}
inline const ::Types::PlayerRef& Card::owner() const {
  // @@protoc_insertion_point(field_get:GameState.Card.Owner)
  return _internal_owner();
}
inline void Card::unsafe_arena_set_allocated_owner(
    ::Types::PlayerRef* owner) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(owner_);
  }
  owner_ = owner;
  if (owner) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.Card.Owner)
}
inline ::Types::PlayerRef* Card::release_owner() {
  
  ::Types::PlayerRef* temp = owner_;
  owner_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Types::PlayerRef* Card::unsafe_arena_release_owner() {
  // @@protoc_insertion_point(field_release:GameState.Card.Owner)
  
  ::Types::PlayerRef* temp = owner_;
  owner_ = nullptr;
  return temp;
}
inline ::Types::PlayerRef* Card::_internal_mutable_owner() {
  
  if (owner_ == nullptr) {
    auto* p = CreateMaybeMessage<::Types::PlayerRef>(GetArena());
    owner_ = p;
  }
  return owner_;
}
inline ::Types::PlayerRef* Card::mutable_owner() {
  // @@protoc_insertion_point(field_mutable:GameState.Card.Owner)
  return _internal_mutable_owner();
}
inline void Card::set_allocated_owner(::Types::PlayerRef* owner) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(owner_);
  }
  if (owner) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(owner)->GetArena();
    if (message_arena != submessage_arena) {
      owner = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, owner, submessage_arena);
    }
    
  } else {
    
  }
  owner_ = owner;
  // @@protoc_insertion_point(field_set_allocated:GameState.Card.Owner)
}

// .Types.PlayerRef Controller = 8;
inline bool Card::_internal_has_controller() const {
  return this != internal_default_instance() && controller_ != nullptr;
}
inline bool Card::has_controller() const {
  return _internal_has_controller();
}
inline const ::Types::PlayerRef& Card::_internal_controller() const {
  const ::Types::PlayerRef* p = controller_;
  return p != nullptr ? *p : reinterpret_cast<const ::Types::PlayerRef&>(
      ::Types::_PlayerRef_default_instance_);
}
inline const ::Types::PlayerRef& Card::controller() const {
  // @@protoc_insertion_point(field_get:GameState.Card.Controller)
  return _internal_controller();
}
inline void Card::unsafe_arena_set_allocated_controller(
    ::Types::PlayerRef* controller) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(controller_);
  }
  controller_ = controller;
  if (controller) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.Card.Controller)
}
inline ::Types::PlayerRef* Card::release_controller() {
  
  ::Types::PlayerRef* temp = controller_;
  controller_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Types::PlayerRef* Card::unsafe_arena_release_controller() {
  // @@protoc_insertion_point(field_release:GameState.Card.Controller)
  
  ::Types::PlayerRef* temp = controller_;
  controller_ = nullptr;
  return temp;
}
inline ::Types::PlayerRef* Card::_internal_mutable_controller() {
  
  if (controller_ == nullptr) {
    auto* p = CreateMaybeMessage<::Types::PlayerRef>(GetArena());
    controller_ = p;
  }
  return controller_;
}
inline ::Types::PlayerRef* Card::mutable_controller() {
  // @@protoc_insertion_point(field_mutable:GameState.Card.Controller)
  return _internal_mutable_controller();
}
inline void Card::set_allocated_controller(::Types::PlayerRef* controller) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(controller_);
  }
  if (controller) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(controller)->GetArena();
    if (message_arena != submessage_arena) {
      controller = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, controller, submessage_arena);
    }
    
  } else {
    
  }
  controller_ = controller;
  // @@protoc_insertion_point(field_set_allocated:GameState.Card.Controller)
}

// .Types.IntegerRef ActionCost = 9;
inline bool Card::_internal_has_actioncost() const {
  return this != internal_default_instance() && actioncost_ != nullptr;
}
inline bool Card::has_actioncost() const {
  return _internal_has_actioncost();
}
inline const ::Types::IntegerRef& Card::_internal_actioncost() const {
  const ::Types::IntegerRef* p = actioncost_;
  return p != nullptr ? *p : reinterpret_cast<const ::Types::IntegerRef&>(
      ::Types::_IntegerRef_default_instance_);
}
inline const ::Types::IntegerRef& Card::actioncost() const {
  // @@protoc_insertion_point(field_get:GameState.Card.ActionCost)
  return _internal_actioncost();
}
inline void Card::unsafe_arena_set_allocated_actioncost(
    ::Types::IntegerRef* actioncost) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(actioncost_);
  }
  actioncost_ = actioncost;
  if (actioncost) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.Card.ActionCost)
}
inline ::Types::IntegerRef* Card::release_actioncost() {
  
  ::Types::IntegerRef* temp = actioncost_;
  actioncost_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Types::IntegerRef* Card::unsafe_arena_release_actioncost() {
  // @@protoc_insertion_point(field_release:GameState.Card.ActionCost)
  
  ::Types::IntegerRef* temp = actioncost_;
  actioncost_ = nullptr;
  return temp;
}
inline ::Types::IntegerRef* Card::_internal_mutable_actioncost() {
  
  if (actioncost_ == nullptr) {
    auto* p = CreateMaybeMessage<::Types::IntegerRef>(GetArena());
    actioncost_ = p;
  }
  return actioncost_;
}
inline ::Types::IntegerRef* Card::mutable_actioncost() {
  // @@protoc_insertion_point(field_mutable:GameState.Card.ActionCost)
  return _internal_mutable_actioncost();
}
inline void Card::set_allocated_actioncost(::Types::IntegerRef* actioncost) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(actioncost_);
  }
  if (actioncost) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(actioncost)->GetArena();
    if (message_arena != submessage_arena) {
      actioncost = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, actioncost, submessage_arena);
    }
    
  } else {
    
  }
  actioncost_ = actioncost;
  // @@protoc_insertion_point(field_set_allocated:GameState.Card.ActionCost)
}

// .Types.IntegerRef PowerCost = 10;
inline bool Card::_internal_has_powercost() const {
  return this != internal_default_instance() && powercost_ != nullptr;
}
inline bool Card::has_powercost() const {
  return _internal_has_powercost();
}
inline const ::Types::IntegerRef& Card::_internal_powercost() const {
  const ::Types::IntegerRef* p = powercost_;
  return p != nullptr ? *p : reinterpret_cast<const ::Types::IntegerRef&>(
      ::Types::_IntegerRef_default_instance_);
}
inline const ::Types::IntegerRef& Card::powercost() const {
  // @@protoc_insertion_point(field_get:GameState.Card.PowerCost)
  return _internal_powercost();
}
inline void Card::unsafe_arena_set_allocated_powercost(
    ::Types::IntegerRef* powercost) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(powercost_);
  }
  powercost_ = powercost;
  if (powercost) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.Card.PowerCost)
}
inline ::Types::IntegerRef* Card::release_powercost() {
  
  ::Types::IntegerRef* temp = powercost_;
  powercost_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Types::IntegerRef* Card::unsafe_arena_release_powercost() {
  // @@protoc_insertion_point(field_release:GameState.Card.PowerCost)
  
  ::Types::IntegerRef* temp = powercost_;
  powercost_ = nullptr;
  return temp;
}
inline ::Types::IntegerRef* Card::_internal_mutable_powercost() {
  
  if (powercost_ == nullptr) {
    auto* p = CreateMaybeMessage<::Types::IntegerRef>(GetArena());
    powercost_ = p;
  }
  return powercost_;
}
inline ::Types::IntegerRef* Card::mutable_powercost() {
  // @@protoc_insertion_point(field_mutable:GameState.Card.PowerCost)
  return _internal_mutable_powercost();
}
inline void Card::set_allocated_powercost(::Types::IntegerRef* powercost) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(powercost_);
  }
  if (powercost) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(powercost)->GetArena();
    if (message_arena != submessage_arena) {
      powercost = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, powercost, submessage_arena);
    }
    
  } else {
    
  }
  powercost_ = powercost;
  // @@protoc_insertion_point(field_set_allocated:GameState.Card.PowerCost)
}

// .Types.IntegerRef Range = 11;
inline bool Card::_internal_has_range() const {
  return this != internal_default_instance() && range_ != nullptr;
}
inline bool Card::has_range() const {
  return _internal_has_range();
}
inline const ::Types::IntegerRef& Card::_internal_range() const {
  const ::Types::IntegerRef* p = range_;
  return p != nullptr ? *p : reinterpret_cast<const ::Types::IntegerRef&>(
      ::Types::_IntegerRef_default_instance_);
}
inline const ::Types::IntegerRef& Card::range() const {
  // @@protoc_insertion_point(field_get:GameState.Card.Range)
  return _internal_range();
}
inline void Card::unsafe_arena_set_allocated_range(
    ::Types::IntegerRef* range) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(range_);
  }
  range_ = range;
  if (range) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.Card.Range)
}
inline ::Types::IntegerRef* Card::release_range() {
  
  ::Types::IntegerRef* temp = range_;
  range_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Types::IntegerRef* Card::unsafe_arena_release_range() {
  // @@protoc_insertion_point(field_release:GameState.Card.Range)
  
  ::Types::IntegerRef* temp = range_;
  range_ = nullptr;
  return temp;
}
inline ::Types::IntegerRef* Card::_internal_mutable_range() {
  
  if (range_ == nullptr) {
    auto* p = CreateMaybeMessage<::Types::IntegerRef>(GetArena());
    range_ = p;
  }
  return range_;
}
inline ::Types::IntegerRef* Card::mutable_range() {
  // @@protoc_insertion_point(field_mutable:GameState.Card.Range)
  return _internal_mutable_range();
}
inline void Card::set_allocated_range(::Types::IntegerRef* range) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(range_);
  }
  if (range) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(range)->GetArena();
    if (message_arena != submessage_arena) {
      range = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, range, submessage_arena);
    }
    
  } else {
    
  }
  range_ = range;
  // @@protoc_insertion_point(field_set_allocated:GameState.Card.Range)
}

// .Types.EntityRef Attached = 12;
inline bool Card::_internal_has_attached() const {
  return this != internal_default_instance() && attached_ != nullptr;
}
inline bool Card::has_attached() const {
  return _internal_has_attached();
}
inline const ::Types::EntityRef& Card::_internal_attached() const {
  const ::Types::EntityRef* p = attached_;
  return p != nullptr ? *p : reinterpret_cast<const ::Types::EntityRef&>(
      ::Types::_EntityRef_default_instance_);
}
inline const ::Types::EntityRef& Card::attached() const {
  // @@protoc_insertion_point(field_get:GameState.Card.Attached)
  return _internal_attached();
}
inline void Card::unsafe_arena_set_allocated_attached(
    ::Types::EntityRef* attached) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(attached_);
  }
  attached_ = attached;
  if (attached) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.Card.Attached)
}
inline ::Types::EntityRef* Card::release_attached() {
  
  ::Types::EntityRef* temp = attached_;
  attached_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Types::EntityRef* Card::unsafe_arena_release_attached() {
  // @@protoc_insertion_point(field_release:GameState.Card.Attached)
  
  ::Types::EntityRef* temp = attached_;
  attached_ = nullptr;
  return temp;
}
inline ::Types::EntityRef* Card::_internal_mutable_attached() {
  
  if (attached_ == nullptr) {
    auto* p = CreateMaybeMessage<::Types::EntityRef>(GetArena());
    attached_ = p;
  }
  return attached_;
}
inline ::Types::EntityRef* Card::mutable_attached() {
  // @@protoc_insertion_point(field_mutable:GameState.Card.Attached)
  return _internal_mutable_attached();
}
inline void Card::set_allocated_attached(::Types::EntityRef* attached) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(attached_);
  }
  if (attached) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(attached)->GetArena();
    if (message_arena != submessage_arena) {
      attached = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, attached, submessage_arena);
    }
    
  } else {
    
  }
  attached_ = attached;
  // @@protoc_insertion_point(field_set_allocated:GameState.Card.Attached)
}

// .Types.IntegerRef AffectedBySlow = 13;
inline bool Card::_internal_has_affectedbyslow() const {
  return this != internal_default_instance() && affectedbyslow_ != nullptr;
}
inline bool Card::has_affectedbyslow() const {
  return _internal_has_affectedbyslow();
}
inline const ::Types::IntegerRef& Card::_internal_affectedbyslow() const {
  const ::Types::IntegerRef* p = affectedbyslow_;
  return p != nullptr ? *p : reinterpret_cast<const ::Types::IntegerRef&>(
      ::Types::_IntegerRef_default_instance_);
}
inline const ::Types::IntegerRef& Card::affectedbyslow() const {
  // @@protoc_insertion_point(field_get:GameState.Card.AffectedBySlow)
  return _internal_affectedbyslow();
}
inline void Card::unsafe_arena_set_allocated_affectedbyslow(
    ::Types::IntegerRef* affectedbyslow) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(affectedbyslow_);
  }
  affectedbyslow_ = affectedbyslow;
  if (affectedbyslow) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.Card.AffectedBySlow)
}
inline ::Types::IntegerRef* Card::release_affectedbyslow() {
  
  ::Types::IntegerRef* temp = affectedbyslow_;
  affectedbyslow_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Types::IntegerRef* Card::unsafe_arena_release_affectedbyslow() {
  // @@protoc_insertion_point(field_release:GameState.Card.AffectedBySlow)
  
  ::Types::IntegerRef* temp = affectedbyslow_;
  affectedbyslow_ = nullptr;
  return temp;
}
inline ::Types::IntegerRef* Card::_internal_mutable_affectedbyslow() {
  
  if (affectedbyslow_ == nullptr) {
    auto* p = CreateMaybeMessage<::Types::IntegerRef>(GetArena());
    affectedbyslow_ = p;
  }
  return affectedbyslow_;
}
inline ::Types::IntegerRef* Card::mutable_affectedbyslow() {
  // @@protoc_insertion_point(field_mutable:GameState.Card.AffectedBySlow)
  return _internal_mutable_affectedbyslow();
}
inline void Card::set_allocated_affectedbyslow(::Types::IntegerRef* affectedbyslow) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(affectedbyslow_);
  }
  if (affectedbyslow) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(affectedbyslow)->GetArena();
    if (message_arena != submessage_arena) {
      affectedbyslow = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, affectedbyslow, submessage_arena);
    }
    
  } else {
    
  }
  affectedbyslow_ = affectedbyslow;
  // @@protoc_insertion_point(field_set_allocated:GameState.Card.AffectedBySlow)
}

// .Types.IntegerRef AffectedBySilence = 14;
inline bool Card::_internal_has_affectedbysilence() const {
  return this != internal_default_instance() && affectedbysilence_ != nullptr;
}
inline bool Card::has_affectedbysilence() const {
  return _internal_has_affectedbysilence();
}
inline const ::Types::IntegerRef& Card::_internal_affectedbysilence() const {
  const ::Types::IntegerRef* p = affectedbysilence_;
  return p != nullptr ? *p : reinterpret_cast<const ::Types::IntegerRef&>(
      ::Types::_IntegerRef_default_instance_);
}
inline const ::Types::IntegerRef& Card::affectedbysilence() const {
  // @@protoc_insertion_point(field_get:GameState.Card.AffectedBySilence)
  return _internal_affectedbysilence();
}
inline void Card::unsafe_arena_set_allocated_affectedbysilence(
    ::Types::IntegerRef* affectedbysilence) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(affectedbysilence_);
  }
  affectedbysilence_ = affectedbysilence;
  if (affectedbysilence) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.Card.AffectedBySilence)
}
inline ::Types::IntegerRef* Card::release_affectedbysilence() {
  
  ::Types::IntegerRef* temp = affectedbysilence_;
  affectedbysilence_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Types::IntegerRef* Card::unsafe_arena_release_affectedbysilence() {
  // @@protoc_insertion_point(field_release:GameState.Card.AffectedBySilence)
  
  ::Types::IntegerRef* temp = affectedbysilence_;
  affectedbysilence_ = nullptr;
  return temp;
}
inline ::Types::IntegerRef* Card::_internal_mutable_affectedbysilence() {
  
  if (affectedbysilence_ == nullptr) {
    auto* p = CreateMaybeMessage<::Types::IntegerRef>(GetArena());
    affectedbysilence_ = p;
  }
  return affectedbysilence_;
}
inline ::Types::IntegerRef* Card::mutable_affectedbysilence() {
  // @@protoc_insertion_point(field_mutable:GameState.Card.AffectedBySilence)
  return _internal_mutable_affectedbysilence();
}
inline void Card::set_allocated_affectedbysilence(::Types::IntegerRef* affectedbysilence) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(affectedbysilence_);
  }
  if (affectedbysilence) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(affectedbysilence)->GetArena();
    if (message_arena != submessage_arena) {
      affectedbysilence = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, affectedbysilence, submessage_arena);
    }
    
  } else {
    
  }
  affectedbysilence_ = affectedbysilence;
  // @@protoc_insertion_point(field_set_allocated:GameState.Card.AffectedBySilence)
}

// .Types.IntegerRef AffectedByDisarm = 15;
inline bool Card::_internal_has_affectedbydisarm() const {
  return this != internal_default_instance() && affectedbydisarm_ != nullptr;
}
inline bool Card::has_affectedbydisarm() const {
  return _internal_has_affectedbydisarm();
}
inline const ::Types::IntegerRef& Card::_internal_affectedbydisarm() const {
  const ::Types::IntegerRef* p = affectedbydisarm_;
  return p != nullptr ? *p : reinterpret_cast<const ::Types::IntegerRef&>(
      ::Types::_IntegerRef_default_instance_);
}
inline const ::Types::IntegerRef& Card::affectedbydisarm() const {
  // @@protoc_insertion_point(field_get:GameState.Card.AffectedByDisarm)
  return _internal_affectedbydisarm();
}
inline void Card::unsafe_arena_set_allocated_affectedbydisarm(
    ::Types::IntegerRef* affectedbydisarm) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(affectedbydisarm_);
  }
  affectedbydisarm_ = affectedbydisarm;
  if (affectedbydisarm) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.Card.AffectedByDisarm)
}
inline ::Types::IntegerRef* Card::release_affectedbydisarm() {
  
  ::Types::IntegerRef* temp = affectedbydisarm_;
  affectedbydisarm_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Types::IntegerRef* Card::unsafe_arena_release_affectedbydisarm() {
  // @@protoc_insertion_point(field_release:GameState.Card.AffectedByDisarm)
  
  ::Types::IntegerRef* temp = affectedbydisarm_;
  affectedbydisarm_ = nullptr;
  return temp;
}
inline ::Types::IntegerRef* Card::_internal_mutable_affectedbydisarm() {
  
  if (affectedbydisarm_ == nullptr) {
    auto* p = CreateMaybeMessage<::Types::IntegerRef>(GetArena());
    affectedbydisarm_ = p;
  }
  return affectedbydisarm_;
}
inline ::Types::IntegerRef* Card::mutable_affectedbydisarm() {
  // @@protoc_insertion_point(field_mutable:GameState.Card.AffectedByDisarm)
  return _internal_mutable_affectedbydisarm();
}
inline void Card::set_allocated_affectedbydisarm(::Types::IntegerRef* affectedbydisarm) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(affectedbydisarm_);
  }
  if (affectedbydisarm) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(affectedbydisarm)->GetArena();
    if (message_arena != submessage_arena) {
      affectedbydisarm = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, affectedbydisarm, submessage_arena);
    }
    
  } else {
    
  }
  affectedbydisarm_ = affectedbydisarm;
  // @@protoc_insertion_point(field_set_allocated:GameState.Card.AffectedByDisarm)
}

// .Effects.CardEffect OmniPresentEffect = 16;
inline bool Card::_internal_has_omnipresenteffect() const {
  return this != internal_default_instance() && omnipresenteffect_ != nullptr;
}
inline bool Card::has_omnipresenteffect() const {
  return _internal_has_omnipresenteffect();
}
inline const ::Effects::CardEffect& Card::_internal_omnipresenteffect() const {
  const ::Effects::CardEffect* p = omnipresenteffect_;
  return p != nullptr ? *p : reinterpret_cast<const ::Effects::CardEffect&>(
      ::Effects::_CardEffect_default_instance_);
}
inline const ::Effects::CardEffect& Card::omnipresenteffect() const {
  // @@protoc_insertion_point(field_get:GameState.Card.OmniPresentEffect)
  return _internal_omnipresenteffect();
}
inline void Card::unsafe_arena_set_allocated_omnipresenteffect(
    ::Effects::CardEffect* omnipresenteffect) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(omnipresenteffect_);
  }
  omnipresenteffect_ = omnipresenteffect;
  if (omnipresenteffect) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.Card.OmniPresentEffect)
}
inline ::Effects::CardEffect* Card::release_omnipresenteffect() {
  
  ::Effects::CardEffect* temp = omnipresenteffect_;
  omnipresenteffect_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Effects::CardEffect* Card::unsafe_arena_release_omnipresenteffect() {
  // @@protoc_insertion_point(field_release:GameState.Card.OmniPresentEffect)
  
  ::Effects::CardEffect* temp = omnipresenteffect_;
  omnipresenteffect_ = nullptr;
  return temp;
}
inline ::Effects::CardEffect* Card::_internal_mutable_omnipresenteffect() {
  
  if (omnipresenteffect_ == nullptr) {
    auto* p = CreateMaybeMessage<::Effects::CardEffect>(GetArena());
    omnipresenteffect_ = p;
  }
  return omnipresenteffect_;
}
inline ::Effects::CardEffect* Card::mutable_omnipresenteffect() {
  // @@protoc_insertion_point(field_mutable:GameState.Card.OmniPresentEffect)
  return _internal_mutable_omnipresenteffect();
}
inline void Card::set_allocated_omnipresenteffect(::Effects::CardEffect* omnipresenteffect) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(omnipresenteffect_);
  }
  if (omnipresenteffect) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(omnipresenteffect)->GetArena();
    if (message_arena != submessage_arena) {
      omnipresenteffect = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, omnipresenteffect, submessage_arena);
    }
    
  } else {
    
  }
  omnipresenteffect_ = omnipresenteffect;
  // @@protoc_insertion_point(field_set_allocated:GameState.Card.OmniPresentEffect)
}

// .Effects.CardEffect PassiveEffect = 17;
inline bool Card::_internal_has_passiveeffect() const {
  return this != internal_default_instance() && passiveeffect_ != nullptr;
}
inline bool Card::has_passiveeffect() const {
  return _internal_has_passiveeffect();
}
inline const ::Effects::CardEffect& Card::_internal_passiveeffect() const {
  const ::Effects::CardEffect* p = passiveeffect_;
  return p != nullptr ? *p : reinterpret_cast<const ::Effects::CardEffect&>(
      ::Effects::_CardEffect_default_instance_);
}
inline const ::Effects::CardEffect& Card::passiveeffect() const {
  // @@protoc_insertion_point(field_get:GameState.Card.PassiveEffect)
  return _internal_passiveeffect();
}
inline void Card::unsafe_arena_set_allocated_passiveeffect(
    ::Effects::CardEffect* passiveeffect) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(passiveeffect_);
  }
  passiveeffect_ = passiveeffect;
  if (passiveeffect) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.Card.PassiveEffect)
}
inline ::Effects::CardEffect* Card::release_passiveeffect() {
  
  ::Effects::CardEffect* temp = passiveeffect_;
  passiveeffect_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Effects::CardEffect* Card::unsafe_arena_release_passiveeffect() {
  // @@protoc_insertion_point(field_release:GameState.Card.PassiveEffect)
  
  ::Effects::CardEffect* temp = passiveeffect_;
  passiveeffect_ = nullptr;
  return temp;
}
inline ::Effects::CardEffect* Card::_internal_mutable_passiveeffect() {
  
  if (passiveeffect_ == nullptr) {
    auto* p = CreateMaybeMessage<::Effects::CardEffect>(GetArena());
    passiveeffect_ = p;
  }
  return passiveeffect_;
}
inline ::Effects::CardEffect* Card::mutable_passiveeffect() {
  // @@protoc_insertion_point(field_mutable:GameState.Card.PassiveEffect)
  return _internal_mutable_passiveeffect();
}
inline void Card::set_allocated_passiveeffect(::Effects::CardEffect* passiveeffect) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(passiveeffect_);
  }
  if (passiveeffect) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(passiveeffect)->GetArena();
    if (message_arena != submessage_arena) {
      passiveeffect = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, passiveeffect, submessage_arena);
    }
    
  } else {
    
  }
  passiveeffect_ = passiveeffect;
  // @@protoc_insertion_point(field_set_allocated:GameState.Card.PassiveEffect)
}

// .Effects.CardEffect FeatEffect = 18;
inline bool Card::_internal_has_feateffect() const {
  return this != internal_default_instance() && feateffect_ != nullptr;
}
inline bool Card::has_feateffect() const {
  return _internal_has_feateffect();
}
inline const ::Effects::CardEffect& Card::_internal_feateffect() const {
  const ::Effects::CardEffect* p = feateffect_;
  return p != nullptr ? *p : reinterpret_cast<const ::Effects::CardEffect&>(
      ::Effects::_CardEffect_default_instance_);
}
inline const ::Effects::CardEffect& Card::feateffect() const {
  // @@protoc_insertion_point(field_get:GameState.Card.FeatEffect)
  return _internal_feateffect();
}
inline void Card::unsafe_arena_set_allocated_feateffect(
    ::Effects::CardEffect* feateffect) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(feateffect_);
  }
  feateffect_ = feateffect;
  if (feateffect) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.Card.FeatEffect)
}
inline ::Effects::CardEffect* Card::release_feateffect() {
  
  ::Effects::CardEffect* temp = feateffect_;
  feateffect_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Effects::CardEffect* Card::unsafe_arena_release_feateffect() {
  // @@protoc_insertion_point(field_release:GameState.Card.FeatEffect)
  
  ::Effects::CardEffect* temp = feateffect_;
  feateffect_ = nullptr;
  return temp;
}
inline ::Effects::CardEffect* Card::_internal_mutable_feateffect() {
  
  if (feateffect_ == nullptr) {
    auto* p = CreateMaybeMessage<::Effects::CardEffect>(GetArena());
    feateffect_ = p;
  }
  return feateffect_;
}
inline ::Effects::CardEffect* Card::mutable_feateffect() {
  // @@protoc_insertion_point(field_mutable:GameState.Card.FeatEffect)
  return _internal_mutable_feateffect();
}
inline void Card::set_allocated_feateffect(::Effects::CardEffect* feateffect) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(feateffect_);
  }
  if (feateffect) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(feateffect)->GetArena();
    if (message_arena != submessage_arena) {
      feateffect = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, feateffect, submessage_arena);
    }
    
  } else {
    
  }
  feateffect_ = feateffect;
  // @@protoc_insertion_point(field_set_allocated:GameState.Card.FeatEffect)
}

// .Effects.CardEffect PlayEffect = 19;
inline bool Card::_internal_has_playeffect() const {
  return this != internal_default_instance() && playeffect_ != nullptr;
}
inline bool Card::has_playeffect() const {
  return _internal_has_playeffect();
}
inline const ::Effects::CardEffect& Card::_internal_playeffect() const {
  const ::Effects::CardEffect* p = playeffect_;
  return p != nullptr ? *p : reinterpret_cast<const ::Effects::CardEffect&>(
      ::Effects::_CardEffect_default_instance_);
}
inline const ::Effects::CardEffect& Card::playeffect() const {
  // @@protoc_insertion_point(field_get:GameState.Card.PlayEffect)
  return _internal_playeffect();
}
inline void Card::unsafe_arena_set_allocated_playeffect(
    ::Effects::CardEffect* playeffect) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(playeffect_);
  }
  playeffect_ = playeffect;
  if (playeffect) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.Card.PlayEffect)
}
inline ::Effects::CardEffect* Card::release_playeffect() {
  
  ::Effects::CardEffect* temp = playeffect_;
  playeffect_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Effects::CardEffect* Card::unsafe_arena_release_playeffect() {
  // @@protoc_insertion_point(field_release:GameState.Card.PlayEffect)
  
  ::Effects::CardEffect* temp = playeffect_;
  playeffect_ = nullptr;
  return temp;
}
inline ::Effects::CardEffect* Card::_internal_mutable_playeffect() {
  
  if (playeffect_ == nullptr) {
    auto* p = CreateMaybeMessage<::Effects::CardEffect>(GetArena());
    playeffect_ = p;
  }
  return playeffect_;
}
inline ::Effects::CardEffect* Card::mutable_playeffect() {
  // @@protoc_insertion_point(field_mutable:GameState.Card.PlayEffect)
  return _internal_mutable_playeffect();
}
inline void Card::set_allocated_playeffect(::Effects::CardEffect* playeffect) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(playeffect_);
  }
  if (playeffect) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(playeffect)->GetArena();
    if (message_arena != submessage_arena) {
      playeffect = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, playeffect, submessage_arena);
    }
    
  } else {
    
  }
  playeffect_ = playeffect;
  // @@protoc_insertion_point(field_set_allocated:GameState.Card.PlayEffect)
}

// .Effects.CardEffect ResolveEffect = 20;
inline bool Card::_internal_has_resolveeffect() const {
  return this != internal_default_instance() && resolveeffect_ != nullptr;
}
inline bool Card::has_resolveeffect() const {
  return _internal_has_resolveeffect();
}
inline const ::Effects::CardEffect& Card::_internal_resolveeffect() const {
  const ::Effects::CardEffect* p = resolveeffect_;
  return p != nullptr ? *p : reinterpret_cast<const ::Effects::CardEffect&>(
      ::Effects::_CardEffect_default_instance_);
}
inline const ::Effects::CardEffect& Card::resolveeffect() const {
  // @@protoc_insertion_point(field_get:GameState.Card.ResolveEffect)
  return _internal_resolveeffect();
}
inline void Card::unsafe_arena_set_allocated_resolveeffect(
    ::Effects::CardEffect* resolveeffect) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(resolveeffect_);
  }
  resolveeffect_ = resolveeffect;
  if (resolveeffect) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.Card.ResolveEffect)
}
inline ::Effects::CardEffect* Card::release_resolveeffect() {
  
  ::Effects::CardEffect* temp = resolveeffect_;
  resolveeffect_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Effects::CardEffect* Card::unsafe_arena_release_resolveeffect() {
  // @@protoc_insertion_point(field_release:GameState.Card.ResolveEffect)
  
  ::Effects::CardEffect* temp = resolveeffect_;
  resolveeffect_ = nullptr;
  return temp;
}
inline ::Effects::CardEffect* Card::_internal_mutable_resolveeffect() {
  
  if (resolveeffect_ == nullptr) {
    auto* p = CreateMaybeMessage<::Effects::CardEffect>(GetArena());
    resolveeffect_ = p;
  }
  return resolveeffect_;
}
inline ::Effects::CardEffect* Card::mutable_resolveeffect() {
  // @@protoc_insertion_point(field_mutable:GameState.Card.ResolveEffect)
  return _internal_mutable_resolveeffect();
}
inline void Card::set_allocated_resolveeffect(::Effects::CardEffect* resolveeffect) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(resolveeffect_);
  }
  if (resolveeffect) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(resolveeffect)->GetArena();
    if (message_arena != submessage_arena) {
      resolveeffect = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, resolveeffect, submessage_arena);
    }
    
  } else {
    
  }
  resolveeffect_ = resolveeffect;
  // @@protoc_insertion_point(field_set_allocated:GameState.Card.ResolveEffect)
}

// -------------------------------------------------------------------

// Team

// repeated .Types.PlayerRef Players = 1;
inline int Team::_internal_players_size() const {
  return players_.size();
}
inline int Team::players_size() const {
  return _internal_players_size();
}
inline ::Types::PlayerRef* Team::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:GameState.Team.Players)
  return players_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Types::PlayerRef >*
Team::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:GameState.Team.Players)
  return &players_;
}
inline const ::Types::PlayerRef& Team::_internal_players(int index) const {
  return players_.Get(index);
}
inline const ::Types::PlayerRef& Team::players(int index) const {
  // @@protoc_insertion_point(field_get:GameState.Team.Players)
  return _internal_players(index);
}
inline ::Types::PlayerRef* Team::_internal_add_players() {
  return players_.Add();
}
inline ::Types::PlayerRef* Team::add_players() {
  // @@protoc_insertion_point(field_add:GameState.Team.Players)
  return _internal_add_players();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Types::PlayerRef >&
Team::players() const {
  // @@protoc_insertion_point(field_list:GameState.Team.Players)
  return players_;
}

// -------------------------------------------------------------------

// SetMutation

// .Types.EntityRef Object = 1;
inline bool SetMutation::_internal_has_object() const {
  return this != internal_default_instance() && object_ != nullptr;
}
inline bool SetMutation::has_object() const {
  return _internal_has_object();
}
inline const ::Types::EntityRef& SetMutation::_internal_object() const {
  const ::Types::EntityRef* p = object_;
  return p != nullptr ? *p : reinterpret_cast<const ::Types::EntityRef&>(
      ::Types::_EntityRef_default_instance_);
}
inline const ::Types::EntityRef& SetMutation::object() const {
  // @@protoc_insertion_point(field_get:GameState.SetMutation.Object)
  return _internal_object();
}
inline void SetMutation::unsafe_arena_set_allocated_object(
    ::Types::EntityRef* object) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(object_);
  }
  object_ = object;
  if (object) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.SetMutation.Object)
}
inline ::Types::EntityRef* SetMutation::release_object() {
  
  ::Types::EntityRef* temp = object_;
  object_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Types::EntityRef* SetMutation::unsafe_arena_release_object() {
  // @@protoc_insertion_point(field_release:GameState.SetMutation.Object)
  
  ::Types::EntityRef* temp = object_;
  object_ = nullptr;
  return temp;
}
inline ::Types::EntityRef* SetMutation::_internal_mutable_object() {
  
  if (object_ == nullptr) {
    auto* p = CreateMaybeMessage<::Types::EntityRef>(GetArena());
    object_ = p;
  }
  return object_;
}
inline ::Types::EntityRef* SetMutation::mutable_object() {
  // @@protoc_insertion_point(field_mutable:GameState.SetMutation.Object)
  return _internal_mutable_object();
}
inline void SetMutation::set_allocated_object(::Types::EntityRef* object) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(object_);
  }
  if (object) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(object)->GetArena();
    if (message_arena != submessage_arena) {
      object = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, object, submessage_arena);
    }
    
  } else {
    
  }
  object_ = object;
  // @@protoc_insertion_point(field_set_allocated:GameState.SetMutation.Object)
}

// .Types.EntityValue NewValue = 2;
inline bool SetMutation::_internal_has_newvalue() const {
  return this != internal_default_instance() && newvalue_ != nullptr;
}
inline bool SetMutation::has_newvalue() const {
  return _internal_has_newvalue();
}
inline const ::Types::EntityValue& SetMutation::_internal_newvalue() const {
  const ::Types::EntityValue* p = newvalue_;
  return p != nullptr ? *p : reinterpret_cast<const ::Types::EntityValue&>(
      ::Types::_EntityValue_default_instance_);
}
inline const ::Types::EntityValue& SetMutation::newvalue() const {
  // @@protoc_insertion_point(field_get:GameState.SetMutation.NewValue)
  return _internal_newvalue();
}
inline void SetMutation::unsafe_arena_set_allocated_newvalue(
    ::Types::EntityValue* newvalue) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(newvalue_);
  }
  newvalue_ = newvalue;
  if (newvalue) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.SetMutation.NewValue)
}
inline ::Types::EntityValue* SetMutation::release_newvalue() {
  
  ::Types::EntityValue* temp = newvalue_;
  newvalue_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Types::EntityValue* SetMutation::unsafe_arena_release_newvalue() {
  // @@protoc_insertion_point(field_release:GameState.SetMutation.NewValue)
  
  ::Types::EntityValue* temp = newvalue_;
  newvalue_ = nullptr;
  return temp;
}
inline ::Types::EntityValue* SetMutation::_internal_mutable_newvalue() {
  
  if (newvalue_ == nullptr) {
    auto* p = CreateMaybeMessage<::Types::EntityValue>(GetArena());
    newvalue_ = p;
  }
  return newvalue_;
}
inline ::Types::EntityValue* SetMutation::mutable_newvalue() {
  // @@protoc_insertion_point(field_mutable:GameState.SetMutation.NewValue)
  return _internal_mutable_newvalue();
}
inline void SetMutation::set_allocated_newvalue(::Types::EntityValue* newvalue) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(newvalue_);
  }
  if (newvalue) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(newvalue)->GetArena();
    if (message_arena != submessage_arena) {
      newvalue = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, newvalue, submessage_arena);
    }
    
  } else {
    
  }
  newvalue_ = newvalue;
  // @@protoc_insertion_point(field_set_allocated:GameState.SetMutation.NewValue)
}

// .Types.EntityValue OldValue = 3;
inline bool SetMutation::_internal_has_oldvalue() const {
  return this != internal_default_instance() && oldvalue_ != nullptr;
}
inline bool SetMutation::has_oldvalue() const {
  return _internal_has_oldvalue();
}
inline const ::Types::EntityValue& SetMutation::_internal_oldvalue() const {
  const ::Types::EntityValue* p = oldvalue_;
  return p != nullptr ? *p : reinterpret_cast<const ::Types::EntityValue&>(
      ::Types::_EntityValue_default_instance_);
}
inline const ::Types::EntityValue& SetMutation::oldvalue() const {
  // @@protoc_insertion_point(field_get:GameState.SetMutation.OldValue)
  return _internal_oldvalue();
}
inline void SetMutation::unsafe_arena_set_allocated_oldvalue(
    ::Types::EntityValue* oldvalue) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(oldvalue_);
  }
  oldvalue_ = oldvalue;
  if (oldvalue) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.SetMutation.OldValue)
}
inline ::Types::EntityValue* SetMutation::release_oldvalue() {
  
  ::Types::EntityValue* temp = oldvalue_;
  oldvalue_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Types::EntityValue* SetMutation::unsafe_arena_release_oldvalue() {
  // @@protoc_insertion_point(field_release:GameState.SetMutation.OldValue)
  
  ::Types::EntityValue* temp = oldvalue_;
  oldvalue_ = nullptr;
  return temp;
}
inline ::Types::EntityValue* SetMutation::_internal_mutable_oldvalue() {
  
  if (oldvalue_ == nullptr) {
    auto* p = CreateMaybeMessage<::Types::EntityValue>(GetArena());
    oldvalue_ = p;
  }
  return oldvalue_;
}
inline ::Types::EntityValue* SetMutation::mutable_oldvalue() {
  // @@protoc_insertion_point(field_mutable:GameState.SetMutation.OldValue)
  return _internal_mutable_oldvalue();
}
inline void SetMutation::set_allocated_oldvalue(::Types::EntityValue* oldvalue) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(oldvalue_);
  }
  if (oldvalue) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(oldvalue)->GetArena();
    if (message_arena != submessage_arena) {
      oldvalue = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, oldvalue, submessage_arena);
    }
    
  } else {
    
  }
  oldvalue_ = oldvalue;
  // @@protoc_insertion_point(field_set_allocated:GameState.SetMutation.OldValue)
}

// -------------------------------------------------------------------

// RemoveMutation

// .Types.EntityRef Object = 1;
inline bool RemoveMutation::_internal_has_object() const {
  return this != internal_default_instance() && object_ != nullptr;
}
inline bool RemoveMutation::has_object() const {
  return _internal_has_object();
}
inline const ::Types::EntityRef& RemoveMutation::_internal_object() const {
  const ::Types::EntityRef* p = object_;
  return p != nullptr ? *p : reinterpret_cast<const ::Types::EntityRef&>(
      ::Types::_EntityRef_default_instance_);
}
inline const ::Types::EntityRef& RemoveMutation::object() const {
  // @@protoc_insertion_point(field_get:GameState.RemoveMutation.Object)
  return _internal_object();
}
inline void RemoveMutation::unsafe_arena_set_allocated_object(
    ::Types::EntityRef* object) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(object_);
  }
  object_ = object;
  if (object) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.RemoveMutation.Object)
}
inline ::Types::EntityRef* RemoveMutation::release_object() {
  
  ::Types::EntityRef* temp = object_;
  object_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Types::EntityRef* RemoveMutation::unsafe_arena_release_object() {
  // @@protoc_insertion_point(field_release:GameState.RemoveMutation.Object)
  
  ::Types::EntityRef* temp = object_;
  object_ = nullptr;
  return temp;
}
inline ::Types::EntityRef* RemoveMutation::_internal_mutable_object() {
  
  if (object_ == nullptr) {
    auto* p = CreateMaybeMessage<::Types::EntityRef>(GetArena());
    object_ = p;
  }
  return object_;
}
inline ::Types::EntityRef* RemoveMutation::mutable_object() {
  // @@protoc_insertion_point(field_mutable:GameState.RemoveMutation.Object)
  return _internal_mutable_object();
}
inline void RemoveMutation::set_allocated_object(::Types::EntityRef* object) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(object_);
  }
  if (object) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(object)->GetArena();
    if (message_arena != submessage_arena) {
      object = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, object, submessage_arena);
    }
    
  } else {
    
  }
  object_ = object;
  // @@protoc_insertion_point(field_set_allocated:GameState.RemoveMutation.Object)
}

// .Types.EntityValue OldValue = 2;
inline bool RemoveMutation::_internal_has_oldvalue() const {
  return this != internal_default_instance() && oldvalue_ != nullptr;
}
inline bool RemoveMutation::has_oldvalue() const {
  return _internal_has_oldvalue();
}
inline const ::Types::EntityValue& RemoveMutation::_internal_oldvalue() const {
  const ::Types::EntityValue* p = oldvalue_;
  return p != nullptr ? *p : reinterpret_cast<const ::Types::EntityValue&>(
      ::Types::_EntityValue_default_instance_);
}
inline const ::Types::EntityValue& RemoveMutation::oldvalue() const {
  // @@protoc_insertion_point(field_get:GameState.RemoveMutation.OldValue)
  return _internal_oldvalue();
}
inline void RemoveMutation::unsafe_arena_set_allocated_oldvalue(
    ::Types::EntityValue* oldvalue) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(oldvalue_);
  }
  oldvalue_ = oldvalue;
  if (oldvalue) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.RemoveMutation.OldValue)
}
inline ::Types::EntityValue* RemoveMutation::release_oldvalue() {
  
  ::Types::EntityValue* temp = oldvalue_;
  oldvalue_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Types::EntityValue* RemoveMutation::unsafe_arena_release_oldvalue() {
  // @@protoc_insertion_point(field_release:GameState.RemoveMutation.OldValue)
  
  ::Types::EntityValue* temp = oldvalue_;
  oldvalue_ = nullptr;
  return temp;
}
inline ::Types::EntityValue* RemoveMutation::_internal_mutable_oldvalue() {
  
  if (oldvalue_ == nullptr) {
    auto* p = CreateMaybeMessage<::Types::EntityValue>(GetArena());
    oldvalue_ = p;
  }
  return oldvalue_;
}
inline ::Types::EntityValue* RemoveMutation::mutable_oldvalue() {
  // @@protoc_insertion_point(field_mutable:GameState.RemoveMutation.OldValue)
  return _internal_mutable_oldvalue();
}
inline void RemoveMutation::set_allocated_oldvalue(::Types::EntityValue* oldvalue) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(oldvalue_);
  }
  if (oldvalue) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(oldvalue)->GetArena();
    if (message_arena != submessage_arena) {
      oldvalue = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, oldvalue, submessage_arena);
    }
    
  } else {
    
  }
  oldvalue_ = oldvalue;
  // @@protoc_insertion_point(field_set_allocated:GameState.RemoveMutation.OldValue)
}

// -------------------------------------------------------------------

// InsertMutation

// .Types.EntityRef Object = 1;
inline bool InsertMutation::_internal_has_object() const {
  return this != internal_default_instance() && object_ != nullptr;
}
inline bool InsertMutation::has_object() const {
  return _internal_has_object();
}
inline const ::Types::EntityRef& InsertMutation::_internal_object() const {
  const ::Types::EntityRef* p = object_;
  return p != nullptr ? *p : reinterpret_cast<const ::Types::EntityRef&>(
      ::Types::_EntityRef_default_instance_);
}
inline const ::Types::EntityRef& InsertMutation::object() const {
  // @@protoc_insertion_point(field_get:GameState.InsertMutation.Object)
  return _internal_object();
}
inline void InsertMutation::unsafe_arena_set_allocated_object(
    ::Types::EntityRef* object) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(object_);
  }
  object_ = object;
  if (object) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.InsertMutation.Object)
}
inline ::Types::EntityRef* InsertMutation::release_object() {
  
  ::Types::EntityRef* temp = object_;
  object_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Types::EntityRef* InsertMutation::unsafe_arena_release_object() {
  // @@protoc_insertion_point(field_release:GameState.InsertMutation.Object)
  
  ::Types::EntityRef* temp = object_;
  object_ = nullptr;
  return temp;
}
inline ::Types::EntityRef* InsertMutation::_internal_mutable_object() {
  
  if (object_ == nullptr) {
    auto* p = CreateMaybeMessage<::Types::EntityRef>(GetArena());
    object_ = p;
  }
  return object_;
}
inline ::Types::EntityRef* InsertMutation::mutable_object() {
  // @@protoc_insertion_point(field_mutable:GameState.InsertMutation.Object)
  return _internal_mutable_object();
}
inline void InsertMutation::set_allocated_object(::Types::EntityRef* object) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(object_);
  }
  if (object) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(object)->GetArena();
    if (message_arena != submessage_arena) {
      object = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, object, submessage_arena);
    }
    
  } else {
    
  }
  object_ = object;
  // @@protoc_insertion_point(field_set_allocated:GameState.InsertMutation.Object)
}

// .Types.EntityValue NewValue = 2;
inline bool InsertMutation::_internal_has_newvalue() const {
  return this != internal_default_instance() && newvalue_ != nullptr;
}
inline bool InsertMutation::has_newvalue() const {
  return _internal_has_newvalue();
}
inline const ::Types::EntityValue& InsertMutation::_internal_newvalue() const {
  const ::Types::EntityValue* p = newvalue_;
  return p != nullptr ? *p : reinterpret_cast<const ::Types::EntityValue&>(
      ::Types::_EntityValue_default_instance_);
}
inline const ::Types::EntityValue& InsertMutation::newvalue() const {
  // @@protoc_insertion_point(field_get:GameState.InsertMutation.NewValue)
  return _internal_newvalue();
}
inline void InsertMutation::unsafe_arena_set_allocated_newvalue(
    ::Types::EntityValue* newvalue) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(newvalue_);
  }
  newvalue_ = newvalue;
  if (newvalue) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.InsertMutation.NewValue)
}
inline ::Types::EntityValue* InsertMutation::release_newvalue() {
  
  ::Types::EntityValue* temp = newvalue_;
  newvalue_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Types::EntityValue* InsertMutation::unsafe_arena_release_newvalue() {
  // @@protoc_insertion_point(field_release:GameState.InsertMutation.NewValue)
  
  ::Types::EntityValue* temp = newvalue_;
  newvalue_ = nullptr;
  return temp;
}
inline ::Types::EntityValue* InsertMutation::_internal_mutable_newvalue() {
  
  if (newvalue_ == nullptr) {
    auto* p = CreateMaybeMessage<::Types::EntityValue>(GetArena());
    newvalue_ = p;
  }
  return newvalue_;
}
inline ::Types::EntityValue* InsertMutation::mutable_newvalue() {
  // @@protoc_insertion_point(field_mutable:GameState.InsertMutation.NewValue)
  return _internal_mutable_newvalue();
}
inline void InsertMutation::set_allocated_newvalue(::Types::EntityValue* newvalue) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(newvalue_);
  }
  if (newvalue) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(newvalue)->GetArena();
    if (message_arena != submessage_arena) {
      newvalue = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, newvalue, submessage_arena);
    }
    
  } else {
    
  }
  newvalue_ = newvalue;
  // @@protoc_insertion_point(field_set_allocated:GameState.InsertMutation.NewValue)
}

// -------------------------------------------------------------------

// Mutation

// .GameState.SetMutation Set = 1;
inline bool Mutation::_internal_has_set() const {
  return mutation_case() == kSet;
}
inline bool Mutation::has_set() const {
  return _internal_has_set();
}
inline void Mutation::set_has_set() {
  _oneof_case_[0] = kSet;
}
inline void Mutation::clear_set() {
  if (_internal_has_set()) {
    if (GetArena() == nullptr) {
      delete mutation_.set_;
    }
    clear_has_mutation();
  }
}
inline ::GameState::SetMutation* Mutation::release_set() {
  // @@protoc_insertion_point(field_release:GameState.Mutation.Set)
  if (_internal_has_set()) {
    clear_has_mutation();
      ::GameState::SetMutation* temp = mutation_.set_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    mutation_.set_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::GameState::SetMutation& Mutation::_internal_set() const {
  return _internal_has_set()
      ? *mutation_.set_
      : reinterpret_cast< ::GameState::SetMutation&>(::GameState::_SetMutation_default_instance_);
}
inline const ::GameState::SetMutation& Mutation::set() const {
  // @@protoc_insertion_point(field_get:GameState.Mutation.Set)
  return _internal_set();
}
inline ::GameState::SetMutation* Mutation::unsafe_arena_release_set() {
  // @@protoc_insertion_point(field_unsafe_arena_release:GameState.Mutation.Set)
  if (_internal_has_set()) {
    clear_has_mutation();
    ::GameState::SetMutation* temp = mutation_.set_;
    mutation_.set_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Mutation::unsafe_arena_set_allocated_set(::GameState::SetMutation* set) {
  clear_mutation();
  if (set) {
    set_has_set();
    mutation_.set_ = set;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.Mutation.Set)
}
inline ::GameState::SetMutation* Mutation::_internal_mutable_set() {
  if (!_internal_has_set()) {
    clear_mutation();
    set_has_set();
    mutation_.set_ = CreateMaybeMessage< ::GameState::SetMutation >(GetArena());
  }
  return mutation_.set_;
}
inline ::GameState::SetMutation* Mutation::mutable_set() {
  // @@protoc_insertion_point(field_mutable:GameState.Mutation.Set)
  return _internal_mutable_set();
}

// .GameState.RemoveMutation Remove = 2;
inline bool Mutation::_internal_has_remove() const {
  return mutation_case() == kRemove;
}
inline bool Mutation::has_remove() const {
  return _internal_has_remove();
}
inline void Mutation::set_has_remove() {
  _oneof_case_[0] = kRemove;
}
inline void Mutation::clear_remove() {
  if (_internal_has_remove()) {
    if (GetArena() == nullptr) {
      delete mutation_.remove_;
    }
    clear_has_mutation();
  }
}
inline ::GameState::RemoveMutation* Mutation::release_remove() {
  // @@protoc_insertion_point(field_release:GameState.Mutation.Remove)
  if (_internal_has_remove()) {
    clear_has_mutation();
      ::GameState::RemoveMutation* temp = mutation_.remove_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    mutation_.remove_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::GameState::RemoveMutation& Mutation::_internal_remove() const {
  return _internal_has_remove()
      ? *mutation_.remove_
      : reinterpret_cast< ::GameState::RemoveMutation&>(::GameState::_RemoveMutation_default_instance_);
}
inline const ::GameState::RemoveMutation& Mutation::remove() const {
  // @@protoc_insertion_point(field_get:GameState.Mutation.Remove)
  return _internal_remove();
}
inline ::GameState::RemoveMutation* Mutation::unsafe_arena_release_remove() {
  // @@protoc_insertion_point(field_unsafe_arena_release:GameState.Mutation.Remove)
  if (_internal_has_remove()) {
    clear_has_mutation();
    ::GameState::RemoveMutation* temp = mutation_.remove_;
    mutation_.remove_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Mutation::unsafe_arena_set_allocated_remove(::GameState::RemoveMutation* remove) {
  clear_mutation();
  if (remove) {
    set_has_remove();
    mutation_.remove_ = remove;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.Mutation.Remove)
}
inline ::GameState::RemoveMutation* Mutation::_internal_mutable_remove() {
  if (!_internal_has_remove()) {
    clear_mutation();
    set_has_remove();
    mutation_.remove_ = CreateMaybeMessage< ::GameState::RemoveMutation >(GetArena());
  }
  return mutation_.remove_;
}
inline ::GameState::RemoveMutation* Mutation::mutable_remove() {
  // @@protoc_insertion_point(field_mutable:GameState.Mutation.Remove)
  return _internal_mutable_remove();
}

// .GameState.InsertMutation Insert = 3;
inline bool Mutation::_internal_has_insert() const {
  return mutation_case() == kInsert;
}
inline bool Mutation::has_insert() const {
  return _internal_has_insert();
}
inline void Mutation::set_has_insert() {
  _oneof_case_[0] = kInsert;
}
inline void Mutation::clear_insert() {
  if (_internal_has_insert()) {
    if (GetArena() == nullptr) {
      delete mutation_.insert_;
    }
    clear_has_mutation();
  }
}
inline ::GameState::InsertMutation* Mutation::release_insert() {
  // @@protoc_insertion_point(field_release:GameState.Mutation.Insert)
  if (_internal_has_insert()) {
    clear_has_mutation();
      ::GameState::InsertMutation* temp = mutation_.insert_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    mutation_.insert_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::GameState::InsertMutation& Mutation::_internal_insert() const {
  return _internal_has_insert()
      ? *mutation_.insert_
      : reinterpret_cast< ::GameState::InsertMutation&>(::GameState::_InsertMutation_default_instance_);
}
inline const ::GameState::InsertMutation& Mutation::insert() const {
  // @@protoc_insertion_point(field_get:GameState.Mutation.Insert)
  return _internal_insert();
}
inline ::GameState::InsertMutation* Mutation::unsafe_arena_release_insert() {
  // @@protoc_insertion_point(field_unsafe_arena_release:GameState.Mutation.Insert)
  if (_internal_has_insert()) {
    clear_has_mutation();
    ::GameState::InsertMutation* temp = mutation_.insert_;
    mutation_.insert_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Mutation::unsafe_arena_set_allocated_insert(::GameState::InsertMutation* insert) {
  clear_mutation();
  if (insert) {
    set_has_insert();
    mutation_.insert_ = insert;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.Mutation.Insert)
}
inline ::GameState::InsertMutation* Mutation::_internal_mutable_insert() {
  if (!_internal_has_insert()) {
    clear_mutation();
    set_has_insert();
    mutation_.insert_ = CreateMaybeMessage< ::GameState::InsertMutation >(GetArena());
  }
  return mutation_.insert_;
}
inline ::GameState::InsertMutation* Mutation::mutable_insert() {
  // @@protoc_insertion_point(field_mutable:GameState.Mutation.Insert)
  return _internal_mutable_insert();
}

inline bool Mutation::has_mutation() const {
  return mutation_case() != MUTATION_NOT_SET;
}
inline void Mutation::clear_has_mutation() {
  _oneof_case_[0] = MUTATION_NOT_SET;
}
inline Mutation::MutationCase Mutation::mutation_case() const {
  return Mutation::MutationCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// GameState

// repeated .GameState.Player Players = 1;
inline int GameState::_internal_players_size() const {
  return players_.size();
}
inline int GameState::players_size() const {
  return _internal_players_size();
}
inline void GameState::clear_players() {
  players_.Clear();
}
inline ::GameState::Player* GameState::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:GameState.GameState.Players)
  return players_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::Player >*
GameState::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:GameState.GameState.Players)
  return &players_;
}
inline const ::GameState::Player& GameState::_internal_players(int index) const {
  return players_.Get(index);
}
inline const ::GameState::Player& GameState::players(int index) const {
  // @@protoc_insertion_point(field_get:GameState.GameState.Players)
  return _internal_players(index);
}
inline ::GameState::Player* GameState::_internal_add_players() {
  return players_.Add();
}
inline ::GameState::Player* GameState::add_players() {
  // @@protoc_insertion_point(field_add:GameState.GameState.Players)
  return _internal_add_players();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::Player >&
GameState::players() const {
  // @@protoc_insertion_point(field_list:GameState.GameState.Players)
  return players_;
}

// repeated .GameState.Card Cards = 2;
inline int GameState::_internal_cards_size() const {
  return cards_.size();
}
inline int GameState::cards_size() const {
  return _internal_cards_size();
}
inline void GameState::clear_cards() {
  cards_.Clear();
}
inline ::GameState::Card* GameState::mutable_cards(int index) {
  // @@protoc_insertion_point(field_mutable:GameState.GameState.Cards)
  return cards_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::Card >*
GameState::mutable_cards() {
  // @@protoc_insertion_point(field_mutable_list:GameState.GameState.Cards)
  return &cards_;
}
inline const ::GameState::Card& GameState::_internal_cards(int index) const {
  return cards_.Get(index);
}
inline const ::GameState::Card& GameState::cards(int index) const {
  // @@protoc_insertion_point(field_get:GameState.GameState.Cards)
  return _internal_cards(index);
}
inline ::GameState::Card* GameState::_internal_add_cards() {
  return cards_.Add();
}
inline ::GameState::Card* GameState::add_cards() {
  // @@protoc_insertion_point(field_add:GameState.GameState.Cards)
  return _internal_add_cards();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::Card >&
GameState::cards() const {
  // @@protoc_insertion_point(field_list:GameState.GameState.Cards)
  return cards_;
}

// repeated .GameState.Tile Tiles = 3;
inline int GameState::_internal_tiles_size() const {
  return tiles_.size();
}
inline int GameState::tiles_size() const {
  return _internal_tiles_size();
}
inline void GameState::clear_tiles() {
  tiles_.Clear();
}
inline ::GameState::Tile* GameState::mutable_tiles(int index) {
  // @@protoc_insertion_point(field_mutable:GameState.GameState.Tiles)
  return tiles_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::Tile >*
GameState::mutable_tiles() {
  // @@protoc_insertion_point(field_mutable_list:GameState.GameState.Tiles)
  return &tiles_;
}
inline const ::GameState::Tile& GameState::_internal_tiles(int index) const {
  return tiles_.Get(index);
}
inline const ::GameState::Tile& GameState::tiles(int index) const {
  // @@protoc_insertion_point(field_get:GameState.GameState.Tiles)
  return _internal_tiles(index);
}
inline ::GameState::Tile* GameState::_internal_add_tiles() {
  return tiles_.Add();
}
inline ::GameState::Tile* GameState::add_tiles() {
  // @@protoc_insertion_point(field_add:GameState.GameState.Tiles)
  return _internal_add_tiles();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::Tile >&
GameState::tiles() const {
  // @@protoc_insertion_point(field_list:GameState.GameState.Tiles)
  return tiles_;
}

// repeated .GameState.Team Teams = 4;
inline int GameState::_internal_teams_size() const {
  return teams_.size();
}
inline int GameState::teams_size() const {
  return _internal_teams_size();
}
inline void GameState::clear_teams() {
  teams_.Clear();
}
inline ::GameState::Team* GameState::mutable_teams(int index) {
  // @@protoc_insertion_point(field_mutable:GameState.GameState.Teams)
  return teams_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::Team >*
GameState::mutable_teams() {
  // @@protoc_insertion_point(field_mutable_list:GameState.GameState.Teams)
  return &teams_;
}
inline const ::GameState::Team& GameState::_internal_teams(int index) const {
  return teams_.Get(index);
}
inline const ::GameState::Team& GameState::teams(int index) const {
  // @@protoc_insertion_point(field_get:GameState.GameState.Teams)
  return _internal_teams(index);
}
inline ::GameState::Team* GameState::_internal_add_teams() {
  return teams_.Add();
}
inline ::GameState::Team* GameState::add_teams() {
  // @@protoc_insertion_point(field_add:GameState.GameState.Teams)
  return _internal_add_teams();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::Team >&
GameState::teams() const {
  // @@protoc_insertion_point(field_list:GameState.GameState.Teams)
  return teams_;
}

// .Types.Integer TurnNumber = 6;
inline bool GameState::_internal_has_turnnumber() const {
  return this != internal_default_instance() && turnnumber_ != nullptr;
}
inline bool GameState::has_turnnumber() const {
  return _internal_has_turnnumber();
}
inline const ::Types::Integer& GameState::_internal_turnnumber() const {
  const ::Types::Integer* p = turnnumber_;
  return p != nullptr ? *p : reinterpret_cast<const ::Types::Integer&>(
      ::Types::_Integer_default_instance_);
}
inline const ::Types::Integer& GameState::turnnumber() const {
  // @@protoc_insertion_point(field_get:GameState.GameState.TurnNumber)
  return _internal_turnnumber();
}
inline void GameState::unsafe_arena_set_allocated_turnnumber(
    ::Types::Integer* turnnumber) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(turnnumber_);
  }
  turnnumber_ = turnnumber;
  if (turnnumber) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.GameState.TurnNumber)
}
inline ::Types::Integer* GameState::release_turnnumber() {
  
  ::Types::Integer* temp = turnnumber_;
  turnnumber_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Types::Integer* GameState::unsafe_arena_release_turnnumber() {
  // @@protoc_insertion_point(field_release:GameState.GameState.TurnNumber)
  
  ::Types::Integer* temp = turnnumber_;
  turnnumber_ = nullptr;
  return temp;
}
inline ::Types::Integer* GameState::_internal_mutable_turnnumber() {
  
  if (turnnumber_ == nullptr) {
    auto* p = CreateMaybeMessage<::Types::Integer>(GetArena());
    turnnumber_ = p;
  }
  return turnnumber_;
}
inline ::Types::Integer* GameState::mutable_turnnumber() {
  // @@protoc_insertion_point(field_mutable:GameState.GameState.TurnNumber)
  return _internal_mutable_turnnumber();
}
inline void GameState::set_allocated_turnnumber(::Types::Integer* turnnumber) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(turnnumber_);
  }
  if (turnnumber) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(turnnumber)->GetArena();
    if (message_arena != submessage_arena) {
      turnnumber = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, turnnumber, submessage_arena);
    }
    
  } else {
    
  }
  turnnumber_ = turnnumber;
  // @@protoc_insertion_point(field_set_allocated:GameState.GameState.TurnNumber)
}

// repeated .GameState.Card Stack = 7;
inline int GameState::_internal_stack_size() const {
  return stack_.size();
}
inline int GameState::stack_size() const {
  return _internal_stack_size();
}
inline void GameState::clear_stack() {
  stack_.Clear();
}
inline ::GameState::Card* GameState::mutable_stack(int index) {
  // @@protoc_insertion_point(field_mutable:GameState.GameState.Stack)
  return stack_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::Card >*
GameState::mutable_stack() {
  // @@protoc_insertion_point(field_mutable_list:GameState.GameState.Stack)
  return &stack_;
}
inline const ::GameState::Card& GameState::_internal_stack(int index) const {
  return stack_.Get(index);
}
inline const ::GameState::Card& GameState::stack(int index) const {
  // @@protoc_insertion_point(field_get:GameState.GameState.Stack)
  return _internal_stack(index);
}
inline ::GameState::Card* GameState::_internal_add_stack() {
  return stack_.Add();
}
inline ::GameState::Card* GameState::add_stack() {
  // @@protoc_insertion_point(field_add:GameState.GameState.Stack)
  return _internal_add_stack();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::Card >&
GameState::stack() const {
  // @@protoc_insertion_point(field_list:GameState.GameState.Stack)
  return stack_;
}

// -------------------------------------------------------------------

// GameInstance

// .GameState.GameState GameState = 1;
inline bool GameInstance::_internal_has_gamestate() const {
  return this != internal_default_instance() && gamestate_ != nullptr;
}
inline bool GameInstance::has_gamestate() const {
  return _internal_has_gamestate();
}
inline void GameInstance::clear_gamestate() {
  if (GetArena() == nullptr && gamestate_ != nullptr) {
    delete gamestate_;
  }
  gamestate_ = nullptr;
}
inline const ::GameState::GameState& GameInstance::_internal_gamestate() const {
  const ::GameState::GameState* p = gamestate_;
  return p != nullptr ? *p : reinterpret_cast<const ::GameState::GameState&>(
      ::GameState::_GameState_default_instance_);
}
inline const ::GameState::GameState& GameInstance::gamestate() const {
  // @@protoc_insertion_point(field_get:GameState.GameInstance.GameState)
  return _internal_gamestate();
}
inline void GameInstance::unsafe_arena_set_allocated_gamestate(
    ::GameState::GameState* gamestate) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gamestate_);
  }
  gamestate_ = gamestate;
  if (gamestate) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.GameInstance.GameState)
}
inline ::GameState::GameState* GameInstance::release_gamestate() {
  
  ::GameState::GameState* temp = gamestate_;
  gamestate_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::GameState::GameState* GameInstance::unsafe_arena_release_gamestate() {
  // @@protoc_insertion_point(field_release:GameState.GameInstance.GameState)
  
  ::GameState::GameState* temp = gamestate_;
  gamestate_ = nullptr;
  return temp;
}
inline ::GameState::GameState* GameInstance::_internal_mutable_gamestate() {
  
  if (gamestate_ == nullptr) {
    auto* p = CreateMaybeMessage<::GameState::GameState>(GetArena());
    gamestate_ = p;
  }
  return gamestate_;
}
inline ::GameState::GameState* GameInstance::mutable_gamestate() {
  // @@protoc_insertion_point(field_mutable:GameState.GameInstance.GameState)
  return _internal_mutable_gamestate();
}
inline void GameInstance::set_allocated_gamestate(::GameState::GameState* gamestate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete gamestate_;
  }
  if (gamestate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(gamestate);
    if (message_arena != submessage_arena) {
      gamestate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gamestate, submessage_arena);
    }
    
  } else {
    
  }
  gamestate_ = gamestate;
  // @@protoc_insertion_point(field_set_allocated:GameState.GameInstance.GameState)
}

// repeated .GameState.Mutation History = 2;
inline int GameInstance::_internal_history_size() const {
  return history_.size();
}
inline int GameInstance::history_size() const {
  return _internal_history_size();
}
inline void GameInstance::clear_history() {
  history_.Clear();
}
inline ::GameState::Mutation* GameInstance::mutable_history(int index) {
  // @@protoc_insertion_point(field_mutable:GameState.GameInstance.History)
  return history_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::Mutation >*
GameInstance::mutable_history() {
  // @@protoc_insertion_point(field_mutable_list:GameState.GameInstance.History)
  return &history_;
}
inline const ::GameState::Mutation& GameInstance::_internal_history(int index) const {
  return history_.Get(index);
}
inline const ::GameState::Mutation& GameInstance::history(int index) const {
  // @@protoc_insertion_point(field_get:GameState.GameInstance.History)
  return _internal_history(index);
}
inline ::GameState::Mutation* GameInstance::_internal_add_history() {
  return history_.Add();
}
inline ::GameState::Mutation* GameInstance::add_history() {
  // @@protoc_insertion_point(field_add:GameState.GameInstance.History)
  return _internal_add_history();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::Mutation >&
GameInstance::history() const {
  // @@protoc_insertion_point(field_list:GameState.GameInstance.History)
  return history_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace GameState

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::GameState::Card_Color> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::GameState::Card_Color>() {
  return ::GameState::Card_Color_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_GameState_2eproto
