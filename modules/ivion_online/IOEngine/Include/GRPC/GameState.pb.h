// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: GameState.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_GameState_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_GameState_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3014000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3014000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <GRPC/Types.pb.h>
#include <GRPC/Effects.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_GameState_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_GameState_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[23]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_GameState_2eproto;
namespace GameState {
class Card;
class CardDefaultTypeInternal;
extern CardDefaultTypeInternal _Card_default_instance_;
class CardRef;
class CardRefDefaultTypeInternal;
extern CardRefDefaultTypeInternal _CardRef_default_instance_;
class EntityRef;
class EntityRefDefaultTypeInternal;
extern EntityRefDefaultTypeInternal _EntityRef_default_instance_;
class EntityValue;
class EntityValueDefaultTypeInternal;
extern EntityValueDefaultTypeInternal _EntityValue_default_instance_;
class GameInstance;
class GameInstanceDefaultTypeInternal;
extern GameInstanceDefaultTypeInternal _GameInstance_default_instance_;
class GameState;
class GameStateDefaultTypeInternal;
extern GameStateDefaultTypeInternal _GameState_default_instance_;
class InsertMutation;
class InsertMutationDefaultTypeInternal;
extern InsertMutationDefaultTypeInternal _InsertMutation_default_instance_;
class Integer;
class IntegerDefaultTypeInternal;
extern IntegerDefaultTypeInternal _Integer_default_instance_;
class IntegerRef;
class IntegerRefDefaultTypeInternal;
extern IntegerRefDefaultTypeInternal _IntegerRef_default_instance_;
class IntegerValue;
class IntegerValueDefaultTypeInternal;
extern IntegerValueDefaultTypeInternal _IntegerValue_default_instance_;
class Mutation;
class MutationDefaultTypeInternal;
extern MutationDefaultTypeInternal _Mutation_default_instance_;
class Path;
class PathDefaultTypeInternal;
extern PathDefaultTypeInternal _Path_default_instance_;
class Player;
class PlayerDefaultTypeInternal;
extern PlayerDefaultTypeInternal _Player_default_instance_;
class PlayerRef;
class PlayerRefDefaultTypeInternal;
extern PlayerRefDefaultTypeInternal _PlayerRef_default_instance_;
class Player_Stats;
class Player_StatsDefaultTypeInternal;
extern Player_StatsDefaultTypeInternal _Player_Stats_default_instance_;
class RemoveMutation;
class RemoveMutationDefaultTypeInternal;
extern RemoveMutationDefaultTypeInternal _RemoveMutation_default_instance_;
class SetMutation;
class SetMutationDefaultTypeInternal;
extern SetMutationDefaultTypeInternal _SetMutation_default_instance_;
class Team;
class TeamDefaultTypeInternal;
extern TeamDefaultTypeInternal _Team_default_instance_;
class Tile;
class TileDefaultTypeInternal;
extern TileDefaultTypeInternal _Tile_default_instance_;
class TileRef;
class TileRefDefaultTypeInternal;
extern TileRefDefaultTypeInternal _TileRef_default_instance_;
class Vec2i;
class Vec2iDefaultTypeInternal;
extern Vec2iDefaultTypeInternal _Vec2i_default_instance_;
class Vec2iRef;
class Vec2iRefDefaultTypeInternal;
extern Vec2iRefDefaultTypeInternal _Vec2iRef_default_instance_;
class Vec2iValue;
class Vec2iValueDefaultTypeInternal;
extern Vec2iValueDefaultTypeInternal _Vec2iValue_default_instance_;
}  // namespace GameState
PROTOBUF_NAMESPACE_OPEN
template<> ::GameState::Card* Arena::CreateMaybeMessage<::GameState::Card>(Arena*);
template<> ::GameState::CardRef* Arena::CreateMaybeMessage<::GameState::CardRef>(Arena*);
template<> ::GameState::EntityRef* Arena::CreateMaybeMessage<::GameState::EntityRef>(Arena*);
template<> ::GameState::EntityValue* Arena::CreateMaybeMessage<::GameState::EntityValue>(Arena*);
template<> ::GameState::GameInstance* Arena::CreateMaybeMessage<::GameState::GameInstance>(Arena*);
template<> ::GameState::GameState* Arena::CreateMaybeMessage<::GameState::GameState>(Arena*);
template<> ::GameState::InsertMutation* Arena::CreateMaybeMessage<::GameState::InsertMutation>(Arena*);
template<> ::GameState::Integer* Arena::CreateMaybeMessage<::GameState::Integer>(Arena*);
template<> ::GameState::IntegerRef* Arena::CreateMaybeMessage<::GameState::IntegerRef>(Arena*);
template<> ::GameState::IntegerValue* Arena::CreateMaybeMessage<::GameState::IntegerValue>(Arena*);
template<> ::GameState::Mutation* Arena::CreateMaybeMessage<::GameState::Mutation>(Arena*);
template<> ::GameState::Path* Arena::CreateMaybeMessage<::GameState::Path>(Arena*);
template<> ::GameState::Player* Arena::CreateMaybeMessage<::GameState::Player>(Arena*);
template<> ::GameState::PlayerRef* Arena::CreateMaybeMessage<::GameState::PlayerRef>(Arena*);
template<> ::GameState::Player_Stats* Arena::CreateMaybeMessage<::GameState::Player_Stats>(Arena*);
template<> ::GameState::RemoveMutation* Arena::CreateMaybeMessage<::GameState::RemoveMutation>(Arena*);
template<> ::GameState::SetMutation* Arena::CreateMaybeMessage<::GameState::SetMutation>(Arena*);
template<> ::GameState::Team* Arena::CreateMaybeMessage<::GameState::Team>(Arena*);
template<> ::GameState::Tile* Arena::CreateMaybeMessage<::GameState::Tile>(Arena*);
template<> ::GameState::TileRef* Arena::CreateMaybeMessage<::GameState::TileRef>(Arena*);
template<> ::GameState::Vec2i* Arena::CreateMaybeMessage<::GameState::Vec2i>(Arena*);
template<> ::GameState::Vec2iRef* Arena::CreateMaybeMessage<::GameState::Vec2iRef>(Arena*);
template<> ::GameState::Vec2iValue* Arena::CreateMaybeMessage<::GameState::Vec2iValue>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace GameState {

enum Card_Color : int {
  Card_Color_GRAY = 0,
  Card_Color_BLACK = 1,
  Card_Color_RED = 2,
  Card_Color_GREEN = 3,
  Card_Color_BLUE = 4,
  Card_Color_WHITE = 5,
  Card_Color_Card_Color_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Card_Color_Card_Color_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Card_Color_IsValid(int value);
constexpr Card_Color Card_Color_Color_MIN = Card_Color_GRAY;
constexpr Card_Color Card_Color_Color_MAX = Card_Color_WHITE;
constexpr int Card_Color_Color_ARRAYSIZE = Card_Color_Color_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Card_Color_descriptor();
template<typename T>
inline const std::string& Card_Color_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Card_Color>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Card_Color_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Card_Color_descriptor(), enum_t_value);
}
inline bool Card_Color_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Card_Color* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Card_Color>(
    Card_Color_descriptor(), name, value);
}
// ===================================================================

class Path PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GameState.Path) */ {
 public:
  inline Path() : Path(nullptr) {}
  virtual ~Path();

  Path(const Path& from);
  Path(Path&& from) noexcept
    : Path() {
    *this = ::std::move(from);
  }

  inline Path& operator=(const Path& from) {
    CopyFrom(from);
    return *this;
  }
  inline Path& operator=(Path&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Path& default_instance();

  static inline const Path* internal_default_instance() {
    return reinterpret_cast<const Path*>(
               &_Path_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Path& a, Path& b) {
    a.Swap(&b);
  }
  inline void Swap(Path* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Path* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Path* New() const final {
    return CreateMaybeMessage<Path>(nullptr);
  }

  Path* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Path>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Path& from);
  void MergeFrom(const Path& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Path* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GameState.Path";
  }
  protected:
  explicit Path(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GameState_2eproto);
    return ::descriptor_table_GameState_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldIndexFieldNumber = 1,
  };
  // repeated int32 FieldIndex = 1;
  int fieldindex_size() const;
  private:
  int _internal_fieldindex_size() const;
  public:
  void clear_fieldindex();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_fieldindex(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_fieldindex() const;
  void _internal_add_fieldindex(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_fieldindex();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 fieldindex(int index) const;
  void set_fieldindex(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_fieldindex(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      fieldindex() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_fieldindex();

  // @@protoc_insertion_point(class_scope:GameState.Path)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > fieldindex_;
  mutable std::atomic<int> _fieldindex_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameState_2eproto;
};
// -------------------------------------------------------------------

class Integer PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GameState.Integer) */ {
 public:
  inline Integer() : Integer(nullptr) {}
  virtual ~Integer();

  Integer(const Integer& from);
  Integer(Integer&& from) noexcept
    : Integer() {
    *this = ::std::move(from);
  }

  inline Integer& operator=(const Integer& from) {
    CopyFrom(from);
    return *this;
  }
  inline Integer& operator=(Integer&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Integer& default_instance();

  static inline const Integer* internal_default_instance() {
    return reinterpret_cast<const Integer*>(
               &_Integer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Integer& a, Integer& b) {
    a.Swap(&b);
  }
  inline void Swap(Integer* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Integer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Integer* New() const final {
    return CreateMaybeMessage<Integer>(nullptr);
  }

  Integer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Integer>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Integer& from);
  void MergeFrom(const Integer& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Integer* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GameState.Integer";
  }
  protected:
  explicit Integer(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GameState_2eproto);
    return ::descriptor_table_GameState_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // int32 Value = 1;
  void clear_value();
  ::PROTOBUF_NAMESPACE_ID::int32 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_value() const;
  void _internal_set_value(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:GameState.Integer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameState_2eproto;
};
// -------------------------------------------------------------------

class Vec2i PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GameState.Vec2i) */ {
 public:
  inline Vec2i() : Vec2i(nullptr) {}
  virtual ~Vec2i();

  Vec2i(const Vec2i& from);
  Vec2i(Vec2i&& from) noexcept
    : Vec2i() {
    *this = ::std::move(from);
  }

  inline Vec2i& operator=(const Vec2i& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vec2i& operator=(Vec2i&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Vec2i& default_instance();

  static inline const Vec2i* internal_default_instance() {
    return reinterpret_cast<const Vec2i*>(
               &_Vec2i_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Vec2i& a, Vec2i& b) {
    a.Swap(&b);
  }
  inline void Swap(Vec2i* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vec2i* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Vec2i* New() const final {
    return CreateMaybeMessage<Vec2i>(nullptr);
  }

  Vec2i* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Vec2i>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Vec2i& from);
  void MergeFrom(const Vec2i& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vec2i* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GameState.Vec2i";
  }
  protected:
  explicit Vec2i(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GameState_2eproto);
    return ::descriptor_table_GameState_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // int32 X = 1;
  void clear_x();
  ::PROTOBUF_NAMESPACE_ID::int32 x() const;
  void set_x(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_x() const;
  void _internal_set_x(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 Y = 2;
  void clear_y();
  ::PROTOBUF_NAMESPACE_ID::int32 y() const;
  void set_y(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_y() const;
  void _internal_set_y(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:GameState.Vec2i)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 x_;
  ::PROTOBUF_NAMESPACE_ID::int32 y_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameState_2eproto;
};
// -------------------------------------------------------------------

class PlayerRef PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GameState.PlayerRef) */ {
 public:
  inline PlayerRef() : PlayerRef(nullptr) {}
  virtual ~PlayerRef();

  PlayerRef(const PlayerRef& from);
  PlayerRef(PlayerRef&& from) noexcept
    : PlayerRef() {
    *this = ::std::move(from);
  }

  inline PlayerRef& operator=(const PlayerRef& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerRef& operator=(PlayerRef&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PlayerRef& default_instance();

  static inline const PlayerRef* internal_default_instance() {
    return reinterpret_cast<const PlayerRef*>(
               &_PlayerRef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(PlayerRef& a, PlayerRef& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerRef* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerRef* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PlayerRef* New() const final {
    return CreateMaybeMessage<PlayerRef>(nullptr);
  }

  PlayerRef* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PlayerRef>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PlayerRef& from);
  void MergeFrom(const PlayerRef& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerRef* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GameState.PlayerRef";
  }
  protected:
  explicit PlayerRef(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GameState_2eproto);
    return ::descriptor_table_GameState_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectPathFieldNumber = 1,
  };
  // .GameState.Path ObjectPath = 1;
  bool has_objectpath() const;
  private:
  bool _internal_has_objectpath() const;
  public:
  void clear_objectpath();
  const ::GameState::Path& objectpath() const;
  ::GameState::Path* release_objectpath();
  ::GameState::Path* mutable_objectpath();
  void set_allocated_objectpath(::GameState::Path* objectpath);
  private:
  const ::GameState::Path& _internal_objectpath() const;
  ::GameState::Path* _internal_mutable_objectpath();
  public:
  void unsafe_arena_set_allocated_objectpath(
      ::GameState::Path* objectpath);
  ::GameState::Path* unsafe_arena_release_objectpath();

  // @@protoc_insertion_point(class_scope:GameState.PlayerRef)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::GameState::Path* objectpath_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameState_2eproto;
};
// -------------------------------------------------------------------

class CardRef PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GameState.CardRef) */ {
 public:
  inline CardRef() : CardRef(nullptr) {}
  virtual ~CardRef();

  CardRef(const CardRef& from);
  CardRef(CardRef&& from) noexcept
    : CardRef() {
    *this = ::std::move(from);
  }

  inline CardRef& operator=(const CardRef& from) {
    CopyFrom(from);
    return *this;
  }
  inline CardRef& operator=(CardRef&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CardRef& default_instance();

  static inline const CardRef* internal_default_instance() {
    return reinterpret_cast<const CardRef*>(
               &_CardRef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CardRef& a, CardRef& b) {
    a.Swap(&b);
  }
  inline void Swap(CardRef* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CardRef* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CardRef* New() const final {
    return CreateMaybeMessage<CardRef>(nullptr);
  }

  CardRef* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CardRef>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CardRef& from);
  void MergeFrom(const CardRef& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CardRef* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GameState.CardRef";
  }
  protected:
  explicit CardRef(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GameState_2eproto);
    return ::descriptor_table_GameState_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectPathFieldNumber = 1,
  };
  // .GameState.Path ObjectPath = 1;
  bool has_objectpath() const;
  private:
  bool _internal_has_objectpath() const;
  public:
  void clear_objectpath();
  const ::GameState::Path& objectpath() const;
  ::GameState::Path* release_objectpath();
  ::GameState::Path* mutable_objectpath();
  void set_allocated_objectpath(::GameState::Path* objectpath);
  private:
  const ::GameState::Path& _internal_objectpath() const;
  ::GameState::Path* _internal_mutable_objectpath();
  public:
  void unsafe_arena_set_allocated_objectpath(
      ::GameState::Path* objectpath);
  ::GameState::Path* unsafe_arena_release_objectpath();

  // @@protoc_insertion_point(class_scope:GameState.CardRef)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::GameState::Path* objectpath_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameState_2eproto;
};
// -------------------------------------------------------------------

class TileRef PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GameState.TileRef) */ {
 public:
  inline TileRef() : TileRef(nullptr) {}
  virtual ~TileRef();

  TileRef(const TileRef& from);
  TileRef(TileRef&& from) noexcept
    : TileRef() {
    *this = ::std::move(from);
  }

  inline TileRef& operator=(const TileRef& from) {
    CopyFrom(from);
    return *this;
  }
  inline TileRef& operator=(TileRef&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TileRef& default_instance();

  static inline const TileRef* internal_default_instance() {
    return reinterpret_cast<const TileRef*>(
               &_TileRef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(TileRef& a, TileRef& b) {
    a.Swap(&b);
  }
  inline void Swap(TileRef* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TileRef* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TileRef* New() const final {
    return CreateMaybeMessage<TileRef>(nullptr);
  }

  TileRef* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TileRef>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TileRef& from);
  void MergeFrom(const TileRef& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TileRef* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GameState.TileRef";
  }
  protected:
  explicit TileRef(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GameState_2eproto);
    return ::descriptor_table_GameState_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectPathFieldNumber = 1,
  };
  // .GameState.Path ObjectPath = 1;
  bool has_objectpath() const;
  private:
  bool _internal_has_objectpath() const;
  public:
  void clear_objectpath();
  const ::GameState::Path& objectpath() const;
  ::GameState::Path* release_objectpath();
  ::GameState::Path* mutable_objectpath();
  void set_allocated_objectpath(::GameState::Path* objectpath);
  private:
  const ::GameState::Path& _internal_objectpath() const;
  ::GameState::Path* _internal_mutable_objectpath();
  public:
  void unsafe_arena_set_allocated_objectpath(
      ::GameState::Path* objectpath);
  ::GameState::Path* unsafe_arena_release_objectpath();

  // @@protoc_insertion_point(class_scope:GameState.TileRef)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::GameState::Path* objectpath_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameState_2eproto;
};
// -------------------------------------------------------------------

class IntegerRef PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GameState.IntegerRef) */ {
 public:
  inline IntegerRef() : IntegerRef(nullptr) {}
  virtual ~IntegerRef();

  IntegerRef(const IntegerRef& from);
  IntegerRef(IntegerRef&& from) noexcept
    : IntegerRef() {
    *this = ::std::move(from);
  }

  inline IntegerRef& operator=(const IntegerRef& from) {
    CopyFrom(from);
    return *this;
  }
  inline IntegerRef& operator=(IntegerRef&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const IntegerRef& default_instance();

  static inline const IntegerRef* internal_default_instance() {
    return reinterpret_cast<const IntegerRef*>(
               &_IntegerRef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(IntegerRef& a, IntegerRef& b) {
    a.Swap(&b);
  }
  inline void Swap(IntegerRef* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IntegerRef* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IntegerRef* New() const final {
    return CreateMaybeMessage<IntegerRef>(nullptr);
  }

  IntegerRef* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IntegerRef>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const IntegerRef& from);
  void MergeFrom(const IntegerRef& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IntegerRef* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GameState.IntegerRef";
  }
  protected:
  explicit IntegerRef(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GameState_2eproto);
    return ::descriptor_table_GameState_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectPathFieldNumber = 1,
  };
  // .GameState.Path ObjectPath = 1;
  bool has_objectpath() const;
  private:
  bool _internal_has_objectpath() const;
  public:
  void clear_objectpath();
  const ::GameState::Path& objectpath() const;
  ::GameState::Path* release_objectpath();
  ::GameState::Path* mutable_objectpath();
  void set_allocated_objectpath(::GameState::Path* objectpath);
  private:
  const ::GameState::Path& _internal_objectpath() const;
  ::GameState::Path* _internal_mutable_objectpath();
  public:
  void unsafe_arena_set_allocated_objectpath(
      ::GameState::Path* objectpath);
  ::GameState::Path* unsafe_arena_release_objectpath();

  // @@protoc_insertion_point(class_scope:GameState.IntegerRef)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::GameState::Path* objectpath_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameState_2eproto;
};
// -------------------------------------------------------------------

class Vec2iRef PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GameState.Vec2iRef) */ {
 public:
  inline Vec2iRef() : Vec2iRef(nullptr) {}
  virtual ~Vec2iRef();

  Vec2iRef(const Vec2iRef& from);
  Vec2iRef(Vec2iRef&& from) noexcept
    : Vec2iRef() {
    *this = ::std::move(from);
  }

  inline Vec2iRef& operator=(const Vec2iRef& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vec2iRef& operator=(Vec2iRef&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Vec2iRef& default_instance();

  static inline const Vec2iRef* internal_default_instance() {
    return reinterpret_cast<const Vec2iRef*>(
               &_Vec2iRef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Vec2iRef& a, Vec2iRef& b) {
    a.Swap(&b);
  }
  inline void Swap(Vec2iRef* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vec2iRef* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Vec2iRef* New() const final {
    return CreateMaybeMessage<Vec2iRef>(nullptr);
  }

  Vec2iRef* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Vec2iRef>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Vec2iRef& from);
  void MergeFrom(const Vec2iRef& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vec2iRef* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GameState.Vec2iRef";
  }
  protected:
  explicit Vec2iRef(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GameState_2eproto);
    return ::descriptor_table_GameState_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectPathFieldNumber = 1,
  };
  // .GameState.Path ObjectPath = 1;
  bool has_objectpath() const;
  private:
  bool _internal_has_objectpath() const;
  public:
  void clear_objectpath();
  const ::GameState::Path& objectpath() const;
  ::GameState::Path* release_objectpath();
  ::GameState::Path* mutable_objectpath();
  void set_allocated_objectpath(::GameState::Path* objectpath);
  private:
  const ::GameState::Path& _internal_objectpath() const;
  ::GameState::Path* _internal_mutable_objectpath();
  public:
  void unsafe_arena_set_allocated_objectpath(
      ::GameState::Path* objectpath);
  ::GameState::Path* unsafe_arena_release_objectpath();

  // @@protoc_insertion_point(class_scope:GameState.Vec2iRef)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::GameState::Path* objectpath_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameState_2eproto;
};
// -------------------------------------------------------------------

class IntegerValue PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GameState.IntegerValue) */ {
 public:
  inline IntegerValue() : IntegerValue(nullptr) {}
  virtual ~IntegerValue();

  IntegerValue(const IntegerValue& from);
  IntegerValue(IntegerValue&& from) noexcept
    : IntegerValue() {
    *this = ::std::move(from);
  }

  inline IntegerValue& operator=(const IntegerValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline IntegerValue& operator=(IntegerValue&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const IntegerValue& default_instance();

  enum ValueCase {
    kValue = 1,
    kRef = 2,
    VALUE_NOT_SET = 0,
  };

  static inline const IntegerValue* internal_default_instance() {
    return reinterpret_cast<const IntegerValue*>(
               &_IntegerValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(IntegerValue& a, IntegerValue& b) {
    a.Swap(&b);
  }
  inline void Swap(IntegerValue* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IntegerValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IntegerValue* New() const final {
    return CreateMaybeMessage<IntegerValue>(nullptr);
  }

  IntegerValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IntegerValue>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const IntegerValue& from);
  void MergeFrom(const IntegerValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IntegerValue* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GameState.IntegerValue";
  }
  protected:
  explicit IntegerValue(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GameState_2eproto);
    return ::descriptor_table_GameState_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
    kRefFieldNumber = 2,
  };
  // int32 Value = 1;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  ::PROTOBUF_NAMESPACE_ID::int32 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_value() const;
  void _internal_set_value(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // .GameState.IntegerRef Ref = 2;
  bool has_ref() const;
  private:
  bool _internal_has_ref() const;
  public:
  void clear_ref();
  const ::GameState::IntegerRef& ref() const;
  ::GameState::IntegerRef* release_ref();
  ::GameState::IntegerRef* mutable_ref();
  void set_allocated_ref(::GameState::IntegerRef* ref);
  private:
  const ::GameState::IntegerRef& _internal_ref() const;
  ::GameState::IntegerRef* _internal_mutable_ref();
  public:
  void unsafe_arena_set_allocated_ref(
      ::GameState::IntegerRef* ref);
  ::GameState::IntegerRef* unsafe_arena_release_ref();

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:GameState.IntegerValue)
 private:
  class _Internal;
  void set_has_value();
  void set_has_ref();

  inline bool has_value() const;
  inline void clear_has_value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union ValueUnion {
    ValueUnion() {}
    ::PROTOBUF_NAMESPACE_ID::int32 value_;
    ::GameState::IntegerRef* ref_;
  } value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_GameState_2eproto;
};
// -------------------------------------------------------------------

class Vec2iValue PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GameState.Vec2iValue) */ {
 public:
  inline Vec2iValue() : Vec2iValue(nullptr) {}
  virtual ~Vec2iValue();

  Vec2iValue(const Vec2iValue& from);
  Vec2iValue(Vec2iValue&& from) noexcept
    : Vec2iValue() {
    *this = ::std::move(from);
  }

  inline Vec2iValue& operator=(const Vec2iValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vec2iValue& operator=(Vec2iValue&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Vec2iValue& default_instance();

  enum ValueCase {
    kValue = 1,
    kRef = 2,
    VALUE_NOT_SET = 0,
  };

  static inline const Vec2iValue* internal_default_instance() {
    return reinterpret_cast<const Vec2iValue*>(
               &_Vec2iValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Vec2iValue& a, Vec2iValue& b) {
    a.Swap(&b);
  }
  inline void Swap(Vec2iValue* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vec2iValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Vec2iValue* New() const final {
    return CreateMaybeMessage<Vec2iValue>(nullptr);
  }

  Vec2iValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Vec2iValue>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Vec2iValue& from);
  void MergeFrom(const Vec2iValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vec2iValue* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GameState.Vec2iValue";
  }
  protected:
  explicit Vec2iValue(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GameState_2eproto);
    return ::descriptor_table_GameState_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
    kRefFieldNumber = 2,
  };
  // .GameState.Vec2i Value = 1;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::GameState::Vec2i& value() const;
  ::GameState::Vec2i* release_value();
  ::GameState::Vec2i* mutable_value();
  void set_allocated_value(::GameState::Vec2i* value);
  private:
  const ::GameState::Vec2i& _internal_value() const;
  ::GameState::Vec2i* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::GameState::Vec2i* value);
  ::GameState::Vec2i* unsafe_arena_release_value();

  // .GameState.Vec2iRef Ref = 2;
  bool has_ref() const;
  private:
  bool _internal_has_ref() const;
  public:
  void clear_ref();
  const ::GameState::Vec2iRef& ref() const;
  ::GameState::Vec2iRef* release_ref();
  ::GameState::Vec2iRef* mutable_ref();
  void set_allocated_ref(::GameState::Vec2iRef* ref);
  private:
  const ::GameState::Vec2iRef& _internal_ref() const;
  ::GameState::Vec2iRef* _internal_mutable_ref();
  public:
  void unsafe_arena_set_allocated_ref(
      ::GameState::Vec2iRef* ref);
  ::GameState::Vec2iRef* unsafe_arena_release_ref();

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:GameState.Vec2iValue)
 private:
  class _Internal;
  void set_has_value();
  void set_has_ref();

  inline bool has_value() const;
  inline void clear_has_value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union ValueUnion {
    ValueUnion() {}
    ::GameState::Vec2i* value_;
    ::GameState::Vec2iRef* ref_;
  } value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_GameState_2eproto;
};
// -------------------------------------------------------------------

class EntityRef PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GameState.EntityRef) */ {
 public:
  inline EntityRef() : EntityRef(nullptr) {}
  virtual ~EntityRef();

  EntityRef(const EntityRef& from);
  EntityRef(EntityRef&& from) noexcept
    : EntityRef() {
    *this = ::std::move(from);
  }

  inline EntityRef& operator=(const EntityRef& from) {
    CopyFrom(from);
    return *this;
  }
  inline EntityRef& operator=(EntityRef&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EntityRef& default_instance();

  enum EntityRefCase {
    kPlayer = 1,
    kCard = 2,
    kTile = 3,
    ENTITY_REF_NOT_SET = 0,
  };

  static inline const EntityRef* internal_default_instance() {
    return reinterpret_cast<const EntityRef*>(
               &_EntityRef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(EntityRef& a, EntityRef& b) {
    a.Swap(&b);
  }
  inline void Swap(EntityRef* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EntityRef* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EntityRef* New() const final {
    return CreateMaybeMessage<EntityRef>(nullptr);
  }

  EntityRef* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EntityRef>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EntityRef& from);
  void MergeFrom(const EntityRef& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EntityRef* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GameState.EntityRef";
  }
  protected:
  explicit EntityRef(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GameState_2eproto);
    return ::descriptor_table_GameState_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerFieldNumber = 1,
    kCardFieldNumber = 2,
    kTileFieldNumber = 3,
  };
  // .GameState.PlayerRef Player = 1;
  bool has_player() const;
  private:
  bool _internal_has_player() const;
  public:
  void clear_player();
  const ::GameState::PlayerRef& player() const;
  ::GameState::PlayerRef* release_player();
  ::GameState::PlayerRef* mutable_player();
  void set_allocated_player(::GameState::PlayerRef* player);
  private:
  const ::GameState::PlayerRef& _internal_player() const;
  ::GameState::PlayerRef* _internal_mutable_player();
  public:
  void unsafe_arena_set_allocated_player(
      ::GameState::PlayerRef* player);
  ::GameState::PlayerRef* unsafe_arena_release_player();

  // .GameState.CardRef Card = 2;
  bool has_card() const;
  private:
  bool _internal_has_card() const;
  public:
  void clear_card();
  const ::GameState::CardRef& card() const;
  ::GameState::CardRef* release_card();
  ::GameState::CardRef* mutable_card();
  void set_allocated_card(::GameState::CardRef* card);
  private:
  const ::GameState::CardRef& _internal_card() const;
  ::GameState::CardRef* _internal_mutable_card();
  public:
  void unsafe_arena_set_allocated_card(
      ::GameState::CardRef* card);
  ::GameState::CardRef* unsafe_arena_release_card();

  // .GameState.TileRef Tile = 3;
  bool has_tile() const;
  private:
  bool _internal_has_tile() const;
  public:
  void clear_tile();
  const ::GameState::TileRef& tile() const;
  ::GameState::TileRef* release_tile();
  ::GameState::TileRef* mutable_tile();
  void set_allocated_tile(::GameState::TileRef* tile);
  private:
  const ::GameState::TileRef& _internal_tile() const;
  ::GameState::TileRef* _internal_mutable_tile();
  public:
  void unsafe_arena_set_allocated_tile(
      ::GameState::TileRef* tile);
  ::GameState::TileRef* unsafe_arena_release_tile();

  void clear_entity_ref();
  EntityRefCase entity_ref_case() const;
  // @@protoc_insertion_point(class_scope:GameState.EntityRef)
 private:
  class _Internal;
  void set_has_player();
  void set_has_card();
  void set_has_tile();

  inline bool has_entity_ref() const;
  inline void clear_has_entity_ref();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union EntityRefUnion {
    EntityRefUnion() {}
    ::GameState::PlayerRef* player_;
    ::GameState::CardRef* card_;
    ::GameState::TileRef* tile_;
  } entity_ref_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_GameState_2eproto;
};
// -------------------------------------------------------------------

class EntityValue PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GameState.EntityValue) */ {
 public:
  inline EntityValue() : EntityValue(nullptr) {}
  virtual ~EntityValue();

  EntityValue(const EntityValue& from);
  EntityValue(EntityValue&& from) noexcept
    : EntityValue() {
    *this = ::std::move(from);
  }

  inline EntityValue& operator=(const EntityValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline EntityValue& operator=(EntityValue&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EntityValue& default_instance();

  enum EntityValCase {
    kPlayer = 1,
    kCard = 2,
    kTile = 3,
    kInteger = 4,
    kIntValue = 5,
    kVec2IValue = 6,
    kTerrainValue = 7,
    ENTITY_VAL_NOT_SET = 0,
  };

  static inline const EntityValue* internal_default_instance() {
    return reinterpret_cast<const EntityValue*>(
               &_EntityValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(EntityValue& a, EntityValue& b) {
    a.Swap(&b);
  }
  inline void Swap(EntityValue* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EntityValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EntityValue* New() const final {
    return CreateMaybeMessage<EntityValue>(nullptr);
  }

  EntityValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EntityValue>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EntityValue& from);
  void MergeFrom(const EntityValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EntityValue* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GameState.EntityValue";
  }
  protected:
  explicit EntityValue(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GameState_2eproto);
    return ::descriptor_table_GameState_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerFieldNumber = 1,
    kCardFieldNumber = 2,
    kTileFieldNumber = 3,
    kIntegerFieldNumber = 4,
    kIntValueFieldNumber = 5,
    kVec2IValueFieldNumber = 6,
    kTerrainValueFieldNumber = 7,
  };
  // .GameState.PlayerRef Player = 1;
  bool has_player() const;
  private:
  bool _internal_has_player() const;
  public:
  void clear_player();
  const ::GameState::PlayerRef& player() const;
  ::GameState::PlayerRef* release_player();
  ::GameState::PlayerRef* mutable_player();
  void set_allocated_player(::GameState::PlayerRef* player);
  private:
  const ::GameState::PlayerRef& _internal_player() const;
  ::GameState::PlayerRef* _internal_mutable_player();
  public:
  void unsafe_arena_set_allocated_player(
      ::GameState::PlayerRef* player);
  ::GameState::PlayerRef* unsafe_arena_release_player();

  // .GameState.CardRef Card = 2;
  bool has_card() const;
  private:
  bool _internal_has_card() const;
  public:
  void clear_card();
  const ::GameState::CardRef& card() const;
  ::GameState::CardRef* release_card();
  ::GameState::CardRef* mutable_card();
  void set_allocated_card(::GameState::CardRef* card);
  private:
  const ::GameState::CardRef& _internal_card() const;
  ::GameState::CardRef* _internal_mutable_card();
  public:
  void unsafe_arena_set_allocated_card(
      ::GameState::CardRef* card);
  ::GameState::CardRef* unsafe_arena_release_card();

  // .GameState.TileRef Tile = 3;
  bool has_tile() const;
  private:
  bool _internal_has_tile() const;
  public:
  void clear_tile();
  const ::GameState::TileRef& tile() const;
  ::GameState::TileRef* release_tile();
  ::GameState::TileRef* mutable_tile();
  void set_allocated_tile(::GameState::TileRef* tile);
  private:
  const ::GameState::TileRef& _internal_tile() const;
  ::GameState::TileRef* _internal_mutable_tile();
  public:
  void unsafe_arena_set_allocated_tile(
      ::GameState::TileRef* tile);
  ::GameState::TileRef* unsafe_arena_release_tile();

  // .GameState.IntegerRef Integer = 4;
  bool has_integer() const;
  private:
  bool _internal_has_integer() const;
  public:
  void clear_integer();
  const ::GameState::IntegerRef& integer() const;
  ::GameState::IntegerRef* release_integer();
  ::GameState::IntegerRef* mutable_integer();
  void set_allocated_integer(::GameState::IntegerRef* integer);
  private:
  const ::GameState::IntegerRef& _internal_integer() const;
  ::GameState::IntegerRef* _internal_mutable_integer();
  public:
  void unsafe_arena_set_allocated_integer(
      ::GameState::IntegerRef* integer);
  ::GameState::IntegerRef* unsafe_arena_release_integer();

  // int32 IntValue = 5;
  private:
  bool _internal_has_intvalue() const;
  public:
  void clear_intvalue();
  ::PROTOBUF_NAMESPACE_ID::int32 intvalue() const;
  void set_intvalue(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_intvalue() const;
  void _internal_set_intvalue(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // .GameState.Vec2i Vec2iValue = 6;
  bool has_vec2ivalue() const;
  private:
  bool _internal_has_vec2ivalue() const;
  public:
  void clear_vec2ivalue();
  const ::GameState::Vec2i& vec2ivalue() const;
  ::GameState::Vec2i* release_vec2ivalue();
  ::GameState::Vec2i* mutable_vec2ivalue();
  void set_allocated_vec2ivalue(::GameState::Vec2i* vec2ivalue);
  private:
  const ::GameState::Vec2i& _internal_vec2ivalue() const;
  ::GameState::Vec2i* _internal_mutable_vec2ivalue();
  public:
  void unsafe_arena_set_allocated_vec2ivalue(
      ::GameState::Vec2i* vec2ivalue);
  ::GameState::Vec2i* unsafe_arena_release_vec2ivalue();

  // .Types.TerrainType TerrainValue = 7;
  private:
  bool _internal_has_terrainvalue() const;
  public:
  void clear_terrainvalue();
  ::Types::TerrainType terrainvalue() const;
  void set_terrainvalue(::Types::TerrainType value);
  private:
  ::Types::TerrainType _internal_terrainvalue() const;
  void _internal_set_terrainvalue(::Types::TerrainType value);
  public:

  void clear_entity_val();
  EntityValCase entity_val_case() const;
  // @@protoc_insertion_point(class_scope:GameState.EntityValue)
 private:
  class _Internal;
  void set_has_player();
  void set_has_card();
  void set_has_tile();
  void set_has_integer();
  void set_has_intvalue();
  void set_has_vec2ivalue();
  void set_has_terrainvalue();

  inline bool has_entity_val() const;
  inline void clear_has_entity_val();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union EntityValUnion {
    EntityValUnion() {}
    ::GameState::PlayerRef* player_;
    ::GameState::CardRef* card_;
    ::GameState::TileRef* tile_;
    ::GameState::IntegerRef* integer_;
    ::PROTOBUF_NAMESPACE_ID::int32 intvalue_;
    ::GameState::Vec2i* vec2ivalue_;
    int terrainvalue_;
  } entity_val_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_GameState_2eproto;
};
// -------------------------------------------------------------------

class Player_Stats PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GameState.Player.Stats) */ {
 public:
  inline Player_Stats() : Player_Stats(nullptr) {}
  virtual ~Player_Stats();

  Player_Stats(const Player_Stats& from);
  Player_Stats(Player_Stats&& from) noexcept
    : Player_Stats() {
    *this = ::std::move(from);
  }

  inline Player_Stats& operator=(const Player_Stats& from) {
    CopyFrom(from);
    return *this;
  }
  inline Player_Stats& operator=(Player_Stats&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Player_Stats& default_instance();

  static inline const Player_Stats* internal_default_instance() {
    return reinterpret_cast<const Player_Stats*>(
               &_Player_Stats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Player_Stats& a, Player_Stats& b) {
    a.Swap(&b);
  }
  inline void Swap(Player_Stats* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Player_Stats* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Player_Stats* New() const final {
    return CreateMaybeMessage<Player_Stats>(nullptr);
  }

  Player_Stats* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Player_Stats>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Player_Stats& from);
  void MergeFrom(const Player_Stats& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Player_Stats* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GameState.Player.Stats";
  }
  protected:
  explicit Player_Stats(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GameState_2eproto);
    return ::descriptor_table_GameState_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHealthFieldNumber = 1,
    kActionsFieldNumber = 2,
    kPowerFieldNumber = 3,
    kSlowFieldNumber = 4,
    kSilenceFieldNumber = 5,
    kDisarmFieldNumber = 6,
    kInitiativeFieldNumber = 7,
  };
  // .GameState.IntegerRef Health = 1;
  bool has_health() const;
  private:
  bool _internal_has_health() const;
  public:
  void clear_health();
  const ::GameState::IntegerRef& health() const;
  ::GameState::IntegerRef* release_health();
  ::GameState::IntegerRef* mutable_health();
  void set_allocated_health(::GameState::IntegerRef* health);
  private:
  const ::GameState::IntegerRef& _internal_health() const;
  ::GameState::IntegerRef* _internal_mutable_health();
  public:
  void unsafe_arena_set_allocated_health(
      ::GameState::IntegerRef* health);
  ::GameState::IntegerRef* unsafe_arena_release_health();

  // .GameState.IntegerRef Actions = 2;
  bool has_actions() const;
  private:
  bool _internal_has_actions() const;
  public:
  void clear_actions();
  const ::GameState::IntegerRef& actions() const;
  ::GameState::IntegerRef* release_actions();
  ::GameState::IntegerRef* mutable_actions();
  void set_allocated_actions(::GameState::IntegerRef* actions);
  private:
  const ::GameState::IntegerRef& _internal_actions() const;
  ::GameState::IntegerRef* _internal_mutable_actions();
  public:
  void unsafe_arena_set_allocated_actions(
      ::GameState::IntegerRef* actions);
  ::GameState::IntegerRef* unsafe_arena_release_actions();

  // .GameState.IntegerRef Power = 3;
  bool has_power() const;
  private:
  bool _internal_has_power() const;
  public:
  void clear_power();
  const ::GameState::IntegerRef& power() const;
  ::GameState::IntegerRef* release_power();
  ::GameState::IntegerRef* mutable_power();
  void set_allocated_power(::GameState::IntegerRef* power);
  private:
  const ::GameState::IntegerRef& _internal_power() const;
  ::GameState::IntegerRef* _internal_mutable_power();
  public:
  void unsafe_arena_set_allocated_power(
      ::GameState::IntegerRef* power);
  ::GameState::IntegerRef* unsafe_arena_release_power();

  // .GameState.IntegerRef Slow = 4;
  bool has_slow() const;
  private:
  bool _internal_has_slow() const;
  public:
  void clear_slow();
  const ::GameState::IntegerRef& slow() const;
  ::GameState::IntegerRef* release_slow();
  ::GameState::IntegerRef* mutable_slow();
  void set_allocated_slow(::GameState::IntegerRef* slow);
  private:
  const ::GameState::IntegerRef& _internal_slow() const;
  ::GameState::IntegerRef* _internal_mutable_slow();
  public:
  void unsafe_arena_set_allocated_slow(
      ::GameState::IntegerRef* slow);
  ::GameState::IntegerRef* unsafe_arena_release_slow();

  // .GameState.IntegerRef Silence = 5;
  bool has_silence() const;
  private:
  bool _internal_has_silence() const;
  public:
  void clear_silence();
  const ::GameState::IntegerRef& silence() const;
  ::GameState::IntegerRef* release_silence();
  ::GameState::IntegerRef* mutable_silence();
  void set_allocated_silence(::GameState::IntegerRef* silence);
  private:
  const ::GameState::IntegerRef& _internal_silence() const;
  ::GameState::IntegerRef* _internal_mutable_silence();
  public:
  void unsafe_arena_set_allocated_silence(
      ::GameState::IntegerRef* silence);
  ::GameState::IntegerRef* unsafe_arena_release_silence();

  // .GameState.IntegerRef Disarm = 6;
  bool has_disarm() const;
  private:
  bool _internal_has_disarm() const;
  public:
  void clear_disarm();
  const ::GameState::IntegerRef& disarm() const;
  ::GameState::IntegerRef* release_disarm();
  ::GameState::IntegerRef* mutable_disarm();
  void set_allocated_disarm(::GameState::IntegerRef* disarm);
  private:
  const ::GameState::IntegerRef& _internal_disarm() const;
  ::GameState::IntegerRef* _internal_mutable_disarm();
  public:
  void unsafe_arena_set_allocated_disarm(
      ::GameState::IntegerRef* disarm);
  ::GameState::IntegerRef* unsafe_arena_release_disarm();

  // .GameState.IntegerRef Initiative = 7;
  bool has_initiative() const;
  private:
  bool _internal_has_initiative() const;
  public:
  void clear_initiative();
  const ::GameState::IntegerRef& initiative() const;
  ::GameState::IntegerRef* release_initiative();
  ::GameState::IntegerRef* mutable_initiative();
  void set_allocated_initiative(::GameState::IntegerRef* initiative);
  private:
  const ::GameState::IntegerRef& _internal_initiative() const;
  ::GameState::IntegerRef* _internal_mutable_initiative();
  public:
  void unsafe_arena_set_allocated_initiative(
      ::GameState::IntegerRef* initiative);
  ::GameState::IntegerRef* unsafe_arena_release_initiative();

  // @@protoc_insertion_point(class_scope:GameState.Player.Stats)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::GameState::IntegerRef* health_;
  ::GameState::IntegerRef* actions_;
  ::GameState::IntegerRef* power_;
  ::GameState::IntegerRef* slow_;
  ::GameState::IntegerRef* silence_;
  ::GameState::IntegerRef* disarm_;
  ::GameState::IntegerRef* initiative_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameState_2eproto;
};
// -------------------------------------------------------------------

class Player PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GameState.Player) */ {
 public:
  inline Player() : Player(nullptr) {}
  virtual ~Player();

  Player(const Player& from);
  Player(Player&& from) noexcept
    : Player() {
    *this = ::std::move(from);
  }

  inline Player& operator=(const Player& from) {
    CopyFrom(from);
    return *this;
  }
  inline Player& operator=(Player&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Player& default_instance();

  static inline const Player* internal_default_instance() {
    return reinterpret_cast<const Player*>(
               &_Player_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Player& a, Player& b) {
    a.Swap(&b);
  }
  inline void Swap(Player* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Player* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Player* New() const final {
    return CreateMaybeMessage<Player>(nullptr);
  }

  Player* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Player>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Player& from);
  void MergeFrom(const Player& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Player* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GameState.Player";
  }
  protected:
  explicit Player(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GameState_2eproto);
    return ::descriptor_table_GameState_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Player_Stats Stats;

  // accessors -------------------------------------------------------

  enum : int {
    kFieldFieldNumber = 3,
    kHandFieldNumber = 4,
    kDeckFieldNumber = 5,
    kDiscardFieldNumber = 6,
    kFeatsFieldNumber = 7,
    kDisplayNameFieldNumber = 1,
    kUIDFieldNumber = 2,
    kStateFieldNumber = 8,
    kMaxStateFieldNumber = 9,
    kPositionFieldNumber = 10,
  };
  // repeated .GameState.CardRef Field = 3;
  int field_size() const;
  private:
  int _internal_field_size() const;
  public:
  void clear_field();
  ::GameState::CardRef* mutable_field(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::CardRef >*
      mutable_field();
  private:
  const ::GameState::CardRef& _internal_field(int index) const;
  ::GameState::CardRef* _internal_add_field();
  public:
  const ::GameState::CardRef& field(int index) const;
  ::GameState::CardRef* add_field();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::CardRef >&
      field() const;

  // repeated .GameState.CardRef Hand = 4;
  int hand_size() const;
  private:
  int _internal_hand_size() const;
  public:
  void clear_hand();
  ::GameState::CardRef* mutable_hand(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::CardRef >*
      mutable_hand();
  private:
  const ::GameState::CardRef& _internal_hand(int index) const;
  ::GameState::CardRef* _internal_add_hand();
  public:
  const ::GameState::CardRef& hand(int index) const;
  ::GameState::CardRef* add_hand();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::CardRef >&
      hand() const;

  // repeated .GameState.CardRef Deck = 5;
  int deck_size() const;
  private:
  int _internal_deck_size() const;
  public:
  void clear_deck();
  ::GameState::CardRef* mutable_deck(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::CardRef >*
      mutable_deck();
  private:
  const ::GameState::CardRef& _internal_deck(int index) const;
  ::GameState::CardRef* _internal_add_deck();
  public:
  const ::GameState::CardRef& deck(int index) const;
  ::GameState::CardRef* add_deck();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::CardRef >&
      deck() const;

  // repeated .GameState.CardRef Discard = 6;
  int discard_size() const;
  private:
  int _internal_discard_size() const;
  public:
  void clear_discard();
  ::GameState::CardRef* mutable_discard(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::CardRef >*
      mutable_discard();
  private:
  const ::GameState::CardRef& _internal_discard(int index) const;
  ::GameState::CardRef* _internal_add_discard();
  public:
  const ::GameState::CardRef& discard(int index) const;
  ::GameState::CardRef* add_discard();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::CardRef >&
      discard() const;

  // repeated .GameState.CardRef Feats = 7;
  int feats_size() const;
  private:
  int _internal_feats_size() const;
  public:
  void clear_feats();
  ::GameState::CardRef* mutable_feats(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::CardRef >*
      mutable_feats();
  private:
  const ::GameState::CardRef& _internal_feats(int index) const;
  ::GameState::CardRef* _internal_add_feats();
  public:
  const ::GameState::CardRef& feats(int index) const;
  ::GameState::CardRef* add_feats();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::CardRef >&
      feats() const;

  // string DisplayName = 1;
  void clear_displayname();
  const std::string& displayname() const;
  void set_displayname(const std::string& value);
  void set_displayname(std::string&& value);
  void set_displayname(const char* value);
  void set_displayname(const char* value, size_t size);
  std::string* mutable_displayname();
  std::string* release_displayname();
  void set_allocated_displayname(std::string* displayname);
  private:
  const std::string& _internal_displayname() const;
  void _internal_set_displayname(const std::string& value);
  std::string* _internal_mutable_displayname();
  public:

  // string UID = 2;
  void clear_uid();
  const std::string& uid() const;
  void set_uid(const std::string& value);
  void set_uid(std::string&& value);
  void set_uid(const char* value);
  void set_uid(const char* value, size_t size);
  std::string* mutable_uid();
  std::string* release_uid();
  void set_allocated_uid(std::string* uid);
  private:
  const std::string& _internal_uid() const;
  void _internal_set_uid(const std::string& value);
  std::string* _internal_mutable_uid();
  public:

  // .GameState.Player.Stats State = 8;
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  const ::GameState::Player_Stats& state() const;
  ::GameState::Player_Stats* release_state();
  ::GameState::Player_Stats* mutable_state();
  void set_allocated_state(::GameState::Player_Stats* state);
  private:
  const ::GameState::Player_Stats& _internal_state() const;
  ::GameState::Player_Stats* _internal_mutable_state();
  public:
  void unsafe_arena_set_allocated_state(
      ::GameState::Player_Stats* state);
  ::GameState::Player_Stats* unsafe_arena_release_state();

  // .GameState.Player.Stats MaxState = 9;
  bool has_maxstate() const;
  private:
  bool _internal_has_maxstate() const;
  public:
  void clear_maxstate();
  const ::GameState::Player_Stats& maxstate() const;
  ::GameState::Player_Stats* release_maxstate();
  ::GameState::Player_Stats* mutable_maxstate();
  void set_allocated_maxstate(::GameState::Player_Stats* maxstate);
  private:
  const ::GameState::Player_Stats& _internal_maxstate() const;
  ::GameState::Player_Stats* _internal_mutable_maxstate();
  public:
  void unsafe_arena_set_allocated_maxstate(
      ::GameState::Player_Stats* maxstate);
  ::GameState::Player_Stats* unsafe_arena_release_maxstate();

  // .GameState.Vec2iRef Position = 10;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::GameState::Vec2iRef& position() const;
  ::GameState::Vec2iRef* release_position();
  ::GameState::Vec2iRef* mutable_position();
  void set_allocated_position(::GameState::Vec2iRef* position);
  private:
  const ::GameState::Vec2iRef& _internal_position() const;
  ::GameState::Vec2iRef* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::GameState::Vec2iRef* position);
  ::GameState::Vec2iRef* unsafe_arena_release_position();

  // @@protoc_insertion_point(class_scope:GameState.Player)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::CardRef > field_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::CardRef > hand_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::CardRef > deck_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::CardRef > discard_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::CardRef > feats_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr displayname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uid_;
  ::GameState::Player_Stats* state_;
  ::GameState::Player_Stats* maxstate_;
  ::GameState::Vec2iRef* position_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameState_2eproto;
};
// -------------------------------------------------------------------

class Tile PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GameState.Tile) */ {
 public:
  inline Tile() : Tile(nullptr) {}
  virtual ~Tile();

  Tile(const Tile& from);
  Tile(Tile&& from) noexcept
    : Tile() {
    *this = ::std::move(from);
  }

  inline Tile& operator=(const Tile& from) {
    CopyFrom(from);
    return *this;
  }
  inline Tile& operator=(Tile&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Tile& default_instance();

  static inline const Tile* internal_default_instance() {
    return reinterpret_cast<const Tile*>(
               &_Tile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Tile& a, Tile& b) {
    a.Swap(&b);
  }
  inline void Swap(Tile* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Tile* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Tile* New() const final {
    return CreateMaybeMessage<Tile>(nullptr);
  }

  Tile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Tile>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Tile& from);
  void MergeFrom(const Tile& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Tile* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GameState.Tile";
  }
  protected:
  explicit Tile(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GameState_2eproto);
    return ::descriptor_table_GameState_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayersFieldNumber = 3,
    kCardsFieldNumber = 4,
    kPositionFieldNumber = 1,
    kTerrainFieldNumber = 2,
  };
  // repeated .GameState.PlayerRef Players = 3;
  int players_size() const;
  private:
  int _internal_players_size() const;
  public:
  void clear_players();
  ::GameState::PlayerRef* mutable_players(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::PlayerRef >*
      mutable_players();
  private:
  const ::GameState::PlayerRef& _internal_players(int index) const;
  ::GameState::PlayerRef* _internal_add_players();
  public:
  const ::GameState::PlayerRef& players(int index) const;
  ::GameState::PlayerRef* add_players();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::PlayerRef >&
      players() const;

  // repeated .GameState.CardRef Cards = 4;
  int cards_size() const;
  private:
  int _internal_cards_size() const;
  public:
  void clear_cards();
  ::GameState::CardRef* mutable_cards(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::CardRef >*
      mutable_cards();
  private:
  const ::GameState::CardRef& _internal_cards(int index) const;
  ::GameState::CardRef* _internal_add_cards();
  public:
  const ::GameState::CardRef& cards(int index) const;
  ::GameState::CardRef* add_cards();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::CardRef >&
      cards() const;

  // .GameState.Vec2i Position = 1;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::GameState::Vec2i& position() const;
  ::GameState::Vec2i* release_position();
  ::GameState::Vec2i* mutable_position();
  void set_allocated_position(::GameState::Vec2i* position);
  private:
  const ::GameState::Vec2i& _internal_position() const;
  ::GameState::Vec2i* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::GameState::Vec2i* position);
  ::GameState::Vec2i* unsafe_arena_release_position();

  // .Types.TerrainType Terrain = 2;
  void clear_terrain();
  ::Types::TerrainType terrain() const;
  void set_terrain(::Types::TerrainType value);
  private:
  ::Types::TerrainType _internal_terrain() const;
  void _internal_set_terrain(::Types::TerrainType value);
  public:

  // @@protoc_insertion_point(class_scope:GameState.Tile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::PlayerRef > players_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::CardRef > cards_;
  ::GameState::Vec2i* position_;
  int terrain_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameState_2eproto;
};
// -------------------------------------------------------------------

class Card PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GameState.Card) */ {
 public:
  inline Card() : Card(nullptr) {}
  virtual ~Card();

  Card(const Card& from);
  Card(Card&& from) noexcept
    : Card() {
    *this = ::std::move(from);
  }

  inline Card& operator=(const Card& from) {
    CopyFrom(from);
    return *this;
  }
  inline Card& operator=(Card&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Card& default_instance();

  static inline const Card* internal_default_instance() {
    return reinterpret_cast<const Card*>(
               &_Card_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Card& a, Card& b) {
    a.Swap(&b);
  }
  inline void Swap(Card* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Card* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Card* New() const final {
    return CreateMaybeMessage<Card>(nullptr);
  }

  Card* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Card>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Card& from);
  void MergeFrom(const Card& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Card* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GameState.Card";
  }
  protected:
  explicit Card(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GameState_2eproto);
    return ::descriptor_table_GameState_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Card_Color Color;
  static constexpr Color GRAY =
    Card_Color_GRAY;
  static constexpr Color BLACK =
    Card_Color_BLACK;
  static constexpr Color RED =
    Card_Color_RED;
  static constexpr Color GREEN =
    Card_Color_GREEN;
  static constexpr Color BLUE =
    Card_Color_BLUE;
  static constexpr Color WHITE =
    Card_Color_WHITE;
  static inline bool Color_IsValid(int value) {
    return Card_Color_IsValid(value);
  }
  static constexpr Color Color_MIN =
    Card_Color_Color_MIN;
  static constexpr Color Color_MAX =
    Card_Color_Color_MAX;
  static constexpr int Color_ARRAYSIZE =
    Card_Color_Color_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Color_descriptor() {
    return Card_Color_descriptor();
  }
  template<typename T>
  static inline const std::string& Color_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Color>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Color_Name.");
    return Card_Color_Name(enum_t_value);
  }
  static inline bool Color_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Color* value) {
    return Card_Color_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kColorsFieldNumber = 6,
    kNameFieldNumber = 1,
    kArchetypeFieldNumber = 2,
    kOwnerFieldNumber = 7,
    kControllerFieldNumber = 8,
    kActionCostFieldNumber = 9,
    kPowerCostFieldNumber = 10,
    kRangeFieldNumber = 11,
    kAttachedFieldNumber = 12,
    kAffectedBySlowFieldNumber = 13,
    kAffectedBySilenceFieldNumber = 14,
    kAffectedByDisarmFieldNumber = 15,
    kOmniPresentEffectFieldNumber = 16,
    kPassiveEffectFieldNumber = 17,
    kFeatEffectFieldNumber = 18,
    kPlayEffectFieldNumber = 19,
    kResolveEffectFieldNumber = 20,
    kUltimateFieldNumber = 3,
    kFeatFieldNumber = 4,
    kBasicActionFieldNumber = 5,
  };
  // repeated .GameState.Card.Color Colors = 6;
  int colors_size() const;
  private:
  int _internal_colors_size() const;
  public:
  void clear_colors();
  private:
  ::GameState::Card_Color _internal_colors(int index) const;
  void _internal_add_colors(::GameState::Card_Color value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_colors();
  public:
  ::GameState::Card_Color colors(int index) const;
  void set_colors(int index, ::GameState::Card_Color value);
  void add_colors(::GameState::Card_Color value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& colors() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_colors();

  // string Name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string Archetype = 2;
  void clear_archetype();
  const std::string& archetype() const;
  void set_archetype(const std::string& value);
  void set_archetype(std::string&& value);
  void set_archetype(const char* value);
  void set_archetype(const char* value, size_t size);
  std::string* mutable_archetype();
  std::string* release_archetype();
  void set_allocated_archetype(std::string* archetype);
  private:
  const std::string& _internal_archetype() const;
  void _internal_set_archetype(const std::string& value);
  std::string* _internal_mutable_archetype();
  public:

  // .GameState.PlayerRef Owner = 7;
  bool has_owner() const;
  private:
  bool _internal_has_owner() const;
  public:
  void clear_owner();
  const ::GameState::PlayerRef& owner() const;
  ::GameState::PlayerRef* release_owner();
  ::GameState::PlayerRef* mutable_owner();
  void set_allocated_owner(::GameState::PlayerRef* owner);
  private:
  const ::GameState::PlayerRef& _internal_owner() const;
  ::GameState::PlayerRef* _internal_mutable_owner();
  public:
  void unsafe_arena_set_allocated_owner(
      ::GameState::PlayerRef* owner);
  ::GameState::PlayerRef* unsafe_arena_release_owner();

  // .GameState.PlayerRef Controller = 8;
  bool has_controller() const;
  private:
  bool _internal_has_controller() const;
  public:
  void clear_controller();
  const ::GameState::PlayerRef& controller() const;
  ::GameState::PlayerRef* release_controller();
  ::GameState::PlayerRef* mutable_controller();
  void set_allocated_controller(::GameState::PlayerRef* controller);
  private:
  const ::GameState::PlayerRef& _internal_controller() const;
  ::GameState::PlayerRef* _internal_mutable_controller();
  public:
  void unsafe_arena_set_allocated_controller(
      ::GameState::PlayerRef* controller);
  ::GameState::PlayerRef* unsafe_arena_release_controller();

  // .GameState.IntegerRef ActionCost = 9;
  bool has_actioncost() const;
  private:
  bool _internal_has_actioncost() const;
  public:
  void clear_actioncost();
  const ::GameState::IntegerRef& actioncost() const;
  ::GameState::IntegerRef* release_actioncost();
  ::GameState::IntegerRef* mutable_actioncost();
  void set_allocated_actioncost(::GameState::IntegerRef* actioncost);
  private:
  const ::GameState::IntegerRef& _internal_actioncost() const;
  ::GameState::IntegerRef* _internal_mutable_actioncost();
  public:
  void unsafe_arena_set_allocated_actioncost(
      ::GameState::IntegerRef* actioncost);
  ::GameState::IntegerRef* unsafe_arena_release_actioncost();

  // .GameState.IntegerRef PowerCost = 10;
  bool has_powercost() const;
  private:
  bool _internal_has_powercost() const;
  public:
  void clear_powercost();
  const ::GameState::IntegerRef& powercost() const;
  ::GameState::IntegerRef* release_powercost();
  ::GameState::IntegerRef* mutable_powercost();
  void set_allocated_powercost(::GameState::IntegerRef* powercost);
  private:
  const ::GameState::IntegerRef& _internal_powercost() const;
  ::GameState::IntegerRef* _internal_mutable_powercost();
  public:
  void unsafe_arena_set_allocated_powercost(
      ::GameState::IntegerRef* powercost);
  ::GameState::IntegerRef* unsafe_arena_release_powercost();

  // .GameState.IntegerRef Range = 11;
  bool has_range() const;
  private:
  bool _internal_has_range() const;
  public:
  void clear_range();
  const ::GameState::IntegerRef& range() const;
  ::GameState::IntegerRef* release_range();
  ::GameState::IntegerRef* mutable_range();
  void set_allocated_range(::GameState::IntegerRef* range);
  private:
  const ::GameState::IntegerRef& _internal_range() const;
  ::GameState::IntegerRef* _internal_mutable_range();
  public:
  void unsafe_arena_set_allocated_range(
      ::GameState::IntegerRef* range);
  ::GameState::IntegerRef* unsafe_arena_release_range();

  // .GameState.EntityRef Attached = 12;
  bool has_attached() const;
  private:
  bool _internal_has_attached() const;
  public:
  void clear_attached();
  const ::GameState::EntityRef& attached() const;
  ::GameState::EntityRef* release_attached();
  ::GameState::EntityRef* mutable_attached();
  void set_allocated_attached(::GameState::EntityRef* attached);
  private:
  const ::GameState::EntityRef& _internal_attached() const;
  ::GameState::EntityRef* _internal_mutable_attached();
  public:
  void unsafe_arena_set_allocated_attached(
      ::GameState::EntityRef* attached);
  ::GameState::EntityRef* unsafe_arena_release_attached();

  // .GameState.IntegerRef AffectedBySlow = 13;
  bool has_affectedbyslow() const;
  private:
  bool _internal_has_affectedbyslow() const;
  public:
  void clear_affectedbyslow();
  const ::GameState::IntegerRef& affectedbyslow() const;
  ::GameState::IntegerRef* release_affectedbyslow();
  ::GameState::IntegerRef* mutable_affectedbyslow();
  void set_allocated_affectedbyslow(::GameState::IntegerRef* affectedbyslow);
  private:
  const ::GameState::IntegerRef& _internal_affectedbyslow() const;
  ::GameState::IntegerRef* _internal_mutable_affectedbyslow();
  public:
  void unsafe_arena_set_allocated_affectedbyslow(
      ::GameState::IntegerRef* affectedbyslow);
  ::GameState::IntegerRef* unsafe_arena_release_affectedbyslow();

  // .GameState.IntegerRef AffectedBySilence = 14;
  bool has_affectedbysilence() const;
  private:
  bool _internal_has_affectedbysilence() const;
  public:
  void clear_affectedbysilence();
  const ::GameState::IntegerRef& affectedbysilence() const;
  ::GameState::IntegerRef* release_affectedbysilence();
  ::GameState::IntegerRef* mutable_affectedbysilence();
  void set_allocated_affectedbysilence(::GameState::IntegerRef* affectedbysilence);
  private:
  const ::GameState::IntegerRef& _internal_affectedbysilence() const;
  ::GameState::IntegerRef* _internal_mutable_affectedbysilence();
  public:
  void unsafe_arena_set_allocated_affectedbysilence(
      ::GameState::IntegerRef* affectedbysilence);
  ::GameState::IntegerRef* unsafe_arena_release_affectedbysilence();

  // .GameState.IntegerRef AffectedByDisarm = 15;
  bool has_affectedbydisarm() const;
  private:
  bool _internal_has_affectedbydisarm() const;
  public:
  void clear_affectedbydisarm();
  const ::GameState::IntegerRef& affectedbydisarm() const;
  ::GameState::IntegerRef* release_affectedbydisarm();
  ::GameState::IntegerRef* mutable_affectedbydisarm();
  void set_allocated_affectedbydisarm(::GameState::IntegerRef* affectedbydisarm);
  private:
  const ::GameState::IntegerRef& _internal_affectedbydisarm() const;
  ::GameState::IntegerRef* _internal_mutable_affectedbydisarm();
  public:
  void unsafe_arena_set_allocated_affectedbydisarm(
      ::GameState::IntegerRef* affectedbydisarm);
  ::GameState::IntegerRef* unsafe_arena_release_affectedbydisarm();

  // .Effects.CardEffect OmniPresentEffect = 16;
  bool has_omnipresenteffect() const;
  private:
  bool _internal_has_omnipresenteffect() const;
  public:
  void clear_omnipresenteffect();
  const ::Effects::CardEffect& omnipresenteffect() const;
  ::Effects::CardEffect* release_omnipresenteffect();
  ::Effects::CardEffect* mutable_omnipresenteffect();
  void set_allocated_omnipresenteffect(::Effects::CardEffect* omnipresenteffect);
  private:
  const ::Effects::CardEffect& _internal_omnipresenteffect() const;
  ::Effects::CardEffect* _internal_mutable_omnipresenteffect();
  public:
  void unsafe_arena_set_allocated_omnipresenteffect(
      ::Effects::CardEffect* omnipresenteffect);
  ::Effects::CardEffect* unsafe_arena_release_omnipresenteffect();

  // .Effects.CardEffect PassiveEffect = 17;
  bool has_passiveeffect() const;
  private:
  bool _internal_has_passiveeffect() const;
  public:
  void clear_passiveeffect();
  const ::Effects::CardEffect& passiveeffect() const;
  ::Effects::CardEffect* release_passiveeffect();
  ::Effects::CardEffect* mutable_passiveeffect();
  void set_allocated_passiveeffect(::Effects::CardEffect* passiveeffect);
  private:
  const ::Effects::CardEffect& _internal_passiveeffect() const;
  ::Effects::CardEffect* _internal_mutable_passiveeffect();
  public:
  void unsafe_arena_set_allocated_passiveeffect(
      ::Effects::CardEffect* passiveeffect);
  ::Effects::CardEffect* unsafe_arena_release_passiveeffect();

  // .Effects.CardEffect FeatEffect = 18;
  bool has_feateffect() const;
  private:
  bool _internal_has_feateffect() const;
  public:
  void clear_feateffect();
  const ::Effects::CardEffect& feateffect() const;
  ::Effects::CardEffect* release_feateffect();
  ::Effects::CardEffect* mutable_feateffect();
  void set_allocated_feateffect(::Effects::CardEffect* feateffect);
  private:
  const ::Effects::CardEffect& _internal_feateffect() const;
  ::Effects::CardEffect* _internal_mutable_feateffect();
  public:
  void unsafe_arena_set_allocated_feateffect(
      ::Effects::CardEffect* feateffect);
  ::Effects::CardEffect* unsafe_arena_release_feateffect();

  // .Effects.CardEffect PlayEffect = 19;
  bool has_playeffect() const;
  private:
  bool _internal_has_playeffect() const;
  public:
  void clear_playeffect();
  const ::Effects::CardEffect& playeffect() const;
  ::Effects::CardEffect* release_playeffect();
  ::Effects::CardEffect* mutable_playeffect();
  void set_allocated_playeffect(::Effects::CardEffect* playeffect);
  private:
  const ::Effects::CardEffect& _internal_playeffect() const;
  ::Effects::CardEffect* _internal_mutable_playeffect();
  public:
  void unsafe_arena_set_allocated_playeffect(
      ::Effects::CardEffect* playeffect);
  ::Effects::CardEffect* unsafe_arena_release_playeffect();

  // .Effects.CardEffect ResolveEffect = 20;
  bool has_resolveeffect() const;
  private:
  bool _internal_has_resolveeffect() const;
  public:
  void clear_resolveeffect();
  const ::Effects::CardEffect& resolveeffect() const;
  ::Effects::CardEffect* release_resolveeffect();
  ::Effects::CardEffect* mutable_resolveeffect();
  void set_allocated_resolveeffect(::Effects::CardEffect* resolveeffect);
  private:
  const ::Effects::CardEffect& _internal_resolveeffect() const;
  ::Effects::CardEffect* _internal_mutable_resolveeffect();
  public:
  void unsafe_arena_set_allocated_resolveeffect(
      ::Effects::CardEffect* resolveeffect);
  ::Effects::CardEffect* unsafe_arena_release_resolveeffect();

  // bool Ultimate = 3;
  void clear_ultimate();
  bool ultimate() const;
  void set_ultimate(bool value);
  private:
  bool _internal_ultimate() const;
  void _internal_set_ultimate(bool value);
  public:

  // bool Feat = 4;
  void clear_feat();
  bool feat() const;
  void set_feat(bool value);
  private:
  bool _internal_feat() const;
  void _internal_set_feat(bool value);
  public:

  // bool BasicAction = 5;
  void clear_basicaction();
  bool basicaction() const;
  void set_basicaction(bool value);
  private:
  bool _internal_basicaction() const;
  void _internal_set_basicaction(bool value);
  public:

  // @@protoc_insertion_point(class_scope:GameState.Card)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> colors_;
  mutable std::atomic<int> _colors_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr archetype_;
  ::GameState::PlayerRef* owner_;
  ::GameState::PlayerRef* controller_;
  ::GameState::IntegerRef* actioncost_;
  ::GameState::IntegerRef* powercost_;
  ::GameState::IntegerRef* range_;
  ::GameState::EntityRef* attached_;
  ::GameState::IntegerRef* affectedbyslow_;
  ::GameState::IntegerRef* affectedbysilence_;
  ::GameState::IntegerRef* affectedbydisarm_;
  ::Effects::CardEffect* omnipresenteffect_;
  ::Effects::CardEffect* passiveeffect_;
  ::Effects::CardEffect* feateffect_;
  ::Effects::CardEffect* playeffect_;
  ::Effects::CardEffect* resolveeffect_;
  bool ultimate_;
  bool feat_;
  bool basicaction_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameState_2eproto;
};
// -------------------------------------------------------------------

class Team PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GameState.Team) */ {
 public:
  inline Team() : Team(nullptr) {}
  virtual ~Team();

  Team(const Team& from);
  Team(Team&& from) noexcept
    : Team() {
    *this = ::std::move(from);
  }

  inline Team& operator=(const Team& from) {
    CopyFrom(from);
    return *this;
  }
  inline Team& operator=(Team&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Team& default_instance();

  static inline const Team* internal_default_instance() {
    return reinterpret_cast<const Team*>(
               &_Team_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(Team& a, Team& b) {
    a.Swap(&b);
  }
  inline void Swap(Team* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Team* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Team* New() const final {
    return CreateMaybeMessage<Team>(nullptr);
  }

  Team* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Team>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Team& from);
  void MergeFrom(const Team& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Team* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GameState.Team";
  }
  protected:
  explicit Team(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GameState_2eproto);
    return ::descriptor_table_GameState_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayersFieldNumber = 1,
  };
  // repeated .GameState.PlayerRef Players = 1;
  int players_size() const;
  private:
  int _internal_players_size() const;
  public:
  void clear_players();
  ::GameState::PlayerRef* mutable_players(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::PlayerRef >*
      mutable_players();
  private:
  const ::GameState::PlayerRef& _internal_players(int index) const;
  ::GameState::PlayerRef* _internal_add_players();
  public:
  const ::GameState::PlayerRef& players(int index) const;
  ::GameState::PlayerRef* add_players();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::PlayerRef >&
      players() const;

  // @@protoc_insertion_point(class_scope:GameState.Team)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::PlayerRef > players_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameState_2eproto;
};
// -------------------------------------------------------------------

class SetMutation PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GameState.SetMutation) */ {
 public:
  inline SetMutation() : SetMutation(nullptr) {}
  virtual ~SetMutation();

  SetMutation(const SetMutation& from);
  SetMutation(SetMutation&& from) noexcept
    : SetMutation() {
    *this = ::std::move(from);
  }

  inline SetMutation& operator=(const SetMutation& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetMutation& operator=(SetMutation&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SetMutation& default_instance();

  static inline const SetMutation* internal_default_instance() {
    return reinterpret_cast<const SetMutation*>(
               &_SetMutation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(SetMutation& a, SetMutation& b) {
    a.Swap(&b);
  }
  inline void Swap(SetMutation* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetMutation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SetMutation* New() const final {
    return CreateMaybeMessage<SetMutation>(nullptr);
  }

  SetMutation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SetMutation>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SetMutation& from);
  void MergeFrom(const SetMutation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetMutation* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GameState.SetMutation";
  }
  protected:
  explicit SetMutation(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GameState_2eproto);
    return ::descriptor_table_GameState_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectFieldNumber = 1,
    kNewValueFieldNumber = 2,
    kOldValueFieldNumber = 3,
  };
  // .GameState.EntityRef Object = 1;
  bool has_object() const;
  private:
  bool _internal_has_object() const;
  public:
  void clear_object();
  const ::GameState::EntityRef& object() const;
  ::GameState::EntityRef* release_object();
  ::GameState::EntityRef* mutable_object();
  void set_allocated_object(::GameState::EntityRef* object);
  private:
  const ::GameState::EntityRef& _internal_object() const;
  ::GameState::EntityRef* _internal_mutable_object();
  public:
  void unsafe_arena_set_allocated_object(
      ::GameState::EntityRef* object);
  ::GameState::EntityRef* unsafe_arena_release_object();

  // .GameState.EntityValue NewValue = 2;
  bool has_newvalue() const;
  private:
  bool _internal_has_newvalue() const;
  public:
  void clear_newvalue();
  const ::GameState::EntityValue& newvalue() const;
  ::GameState::EntityValue* release_newvalue();
  ::GameState::EntityValue* mutable_newvalue();
  void set_allocated_newvalue(::GameState::EntityValue* newvalue);
  private:
  const ::GameState::EntityValue& _internal_newvalue() const;
  ::GameState::EntityValue* _internal_mutable_newvalue();
  public:
  void unsafe_arena_set_allocated_newvalue(
      ::GameState::EntityValue* newvalue);
  ::GameState::EntityValue* unsafe_arena_release_newvalue();

  // .GameState.EntityValue OldValue = 3;
  bool has_oldvalue() const;
  private:
  bool _internal_has_oldvalue() const;
  public:
  void clear_oldvalue();
  const ::GameState::EntityValue& oldvalue() const;
  ::GameState::EntityValue* release_oldvalue();
  ::GameState::EntityValue* mutable_oldvalue();
  void set_allocated_oldvalue(::GameState::EntityValue* oldvalue);
  private:
  const ::GameState::EntityValue& _internal_oldvalue() const;
  ::GameState::EntityValue* _internal_mutable_oldvalue();
  public:
  void unsafe_arena_set_allocated_oldvalue(
      ::GameState::EntityValue* oldvalue);
  ::GameState::EntityValue* unsafe_arena_release_oldvalue();

  // @@protoc_insertion_point(class_scope:GameState.SetMutation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::GameState::EntityRef* object_;
  ::GameState::EntityValue* newvalue_;
  ::GameState::EntityValue* oldvalue_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameState_2eproto;
};
// -------------------------------------------------------------------

class RemoveMutation PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GameState.RemoveMutation) */ {
 public:
  inline RemoveMutation() : RemoveMutation(nullptr) {}
  virtual ~RemoveMutation();

  RemoveMutation(const RemoveMutation& from);
  RemoveMutation(RemoveMutation&& from) noexcept
    : RemoveMutation() {
    *this = ::std::move(from);
  }

  inline RemoveMutation& operator=(const RemoveMutation& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoveMutation& operator=(RemoveMutation&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RemoveMutation& default_instance();

  static inline const RemoveMutation* internal_default_instance() {
    return reinterpret_cast<const RemoveMutation*>(
               &_RemoveMutation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(RemoveMutation& a, RemoveMutation& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoveMutation* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoveMutation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RemoveMutation* New() const final {
    return CreateMaybeMessage<RemoveMutation>(nullptr);
  }

  RemoveMutation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RemoveMutation>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RemoveMutation& from);
  void MergeFrom(const RemoveMutation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoveMutation* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GameState.RemoveMutation";
  }
  protected:
  explicit RemoveMutation(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GameState_2eproto);
    return ::descriptor_table_GameState_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectFieldNumber = 1,
    kOldValueFieldNumber = 2,
  };
  // .GameState.EntityRef Object = 1;
  bool has_object() const;
  private:
  bool _internal_has_object() const;
  public:
  void clear_object();
  const ::GameState::EntityRef& object() const;
  ::GameState::EntityRef* release_object();
  ::GameState::EntityRef* mutable_object();
  void set_allocated_object(::GameState::EntityRef* object);
  private:
  const ::GameState::EntityRef& _internal_object() const;
  ::GameState::EntityRef* _internal_mutable_object();
  public:
  void unsafe_arena_set_allocated_object(
      ::GameState::EntityRef* object);
  ::GameState::EntityRef* unsafe_arena_release_object();

  // .GameState.EntityValue OldValue = 2;
  bool has_oldvalue() const;
  private:
  bool _internal_has_oldvalue() const;
  public:
  void clear_oldvalue();
  const ::GameState::EntityValue& oldvalue() const;
  ::GameState::EntityValue* release_oldvalue();
  ::GameState::EntityValue* mutable_oldvalue();
  void set_allocated_oldvalue(::GameState::EntityValue* oldvalue);
  private:
  const ::GameState::EntityValue& _internal_oldvalue() const;
  ::GameState::EntityValue* _internal_mutable_oldvalue();
  public:
  void unsafe_arena_set_allocated_oldvalue(
      ::GameState::EntityValue* oldvalue);
  ::GameState::EntityValue* unsafe_arena_release_oldvalue();

  // @@protoc_insertion_point(class_scope:GameState.RemoveMutation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::GameState::EntityRef* object_;
  ::GameState::EntityValue* oldvalue_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameState_2eproto;
};
// -------------------------------------------------------------------

class InsertMutation PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GameState.InsertMutation) */ {
 public:
  inline InsertMutation() : InsertMutation(nullptr) {}
  virtual ~InsertMutation();

  InsertMutation(const InsertMutation& from);
  InsertMutation(InsertMutation&& from) noexcept
    : InsertMutation() {
    *this = ::std::move(from);
  }

  inline InsertMutation& operator=(const InsertMutation& from) {
    CopyFrom(from);
    return *this;
  }
  inline InsertMutation& operator=(InsertMutation&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const InsertMutation& default_instance();

  static inline const InsertMutation* internal_default_instance() {
    return reinterpret_cast<const InsertMutation*>(
               &_InsertMutation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(InsertMutation& a, InsertMutation& b) {
    a.Swap(&b);
  }
  inline void Swap(InsertMutation* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InsertMutation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InsertMutation* New() const final {
    return CreateMaybeMessage<InsertMutation>(nullptr);
  }

  InsertMutation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InsertMutation>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const InsertMutation& from);
  void MergeFrom(const InsertMutation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InsertMutation* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GameState.InsertMutation";
  }
  protected:
  explicit InsertMutation(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GameState_2eproto);
    return ::descriptor_table_GameState_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectFieldNumber = 1,
    kNewValueFieldNumber = 2,
  };
  // .GameState.EntityRef Object = 1;
  bool has_object() const;
  private:
  bool _internal_has_object() const;
  public:
  void clear_object();
  const ::GameState::EntityRef& object() const;
  ::GameState::EntityRef* release_object();
  ::GameState::EntityRef* mutable_object();
  void set_allocated_object(::GameState::EntityRef* object);
  private:
  const ::GameState::EntityRef& _internal_object() const;
  ::GameState::EntityRef* _internal_mutable_object();
  public:
  void unsafe_arena_set_allocated_object(
      ::GameState::EntityRef* object);
  ::GameState::EntityRef* unsafe_arena_release_object();

  // .GameState.EntityValue NewValue = 2;
  bool has_newvalue() const;
  private:
  bool _internal_has_newvalue() const;
  public:
  void clear_newvalue();
  const ::GameState::EntityValue& newvalue() const;
  ::GameState::EntityValue* release_newvalue();
  ::GameState::EntityValue* mutable_newvalue();
  void set_allocated_newvalue(::GameState::EntityValue* newvalue);
  private:
  const ::GameState::EntityValue& _internal_newvalue() const;
  ::GameState::EntityValue* _internal_mutable_newvalue();
  public:
  void unsafe_arena_set_allocated_newvalue(
      ::GameState::EntityValue* newvalue);
  ::GameState::EntityValue* unsafe_arena_release_newvalue();

  // @@protoc_insertion_point(class_scope:GameState.InsertMutation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::GameState::EntityRef* object_;
  ::GameState::EntityValue* newvalue_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameState_2eproto;
};
// -------------------------------------------------------------------

class Mutation PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GameState.Mutation) */ {
 public:
  inline Mutation() : Mutation(nullptr) {}
  virtual ~Mutation();

  Mutation(const Mutation& from);
  Mutation(Mutation&& from) noexcept
    : Mutation() {
    *this = ::std::move(from);
  }

  inline Mutation& operator=(const Mutation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Mutation& operator=(Mutation&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Mutation& default_instance();

  enum MutationCase {
    kSet = 1,
    kRemove = 2,
    kInsert = 3,
    MUTATION_NOT_SET = 0,
  };

  static inline const Mutation* internal_default_instance() {
    return reinterpret_cast<const Mutation*>(
               &_Mutation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(Mutation& a, Mutation& b) {
    a.Swap(&b);
  }
  inline void Swap(Mutation* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Mutation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Mutation* New() const final {
    return CreateMaybeMessage<Mutation>(nullptr);
  }

  Mutation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Mutation>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Mutation& from);
  void MergeFrom(const Mutation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Mutation* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GameState.Mutation";
  }
  protected:
  explicit Mutation(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GameState_2eproto);
    return ::descriptor_table_GameState_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSetFieldNumber = 1,
    kRemoveFieldNumber = 2,
    kInsertFieldNumber = 3,
  };
  // .GameState.SetMutation Set = 1;
  bool has_set() const;
  private:
  bool _internal_has_set() const;
  public:
  void clear_set();
  const ::GameState::SetMutation& set() const;
  ::GameState::SetMutation* release_set();
  ::GameState::SetMutation* mutable_set();
  void set_allocated_set(::GameState::SetMutation* set);
  private:
  const ::GameState::SetMutation& _internal_set() const;
  ::GameState::SetMutation* _internal_mutable_set();
  public:
  void unsafe_arena_set_allocated_set(
      ::GameState::SetMutation* set);
  ::GameState::SetMutation* unsafe_arena_release_set();

  // .GameState.RemoveMutation Remove = 2;
  bool has_remove() const;
  private:
  bool _internal_has_remove() const;
  public:
  void clear_remove();
  const ::GameState::RemoveMutation& remove() const;
  ::GameState::RemoveMutation* release_remove();
  ::GameState::RemoveMutation* mutable_remove();
  void set_allocated_remove(::GameState::RemoveMutation* remove);
  private:
  const ::GameState::RemoveMutation& _internal_remove() const;
  ::GameState::RemoveMutation* _internal_mutable_remove();
  public:
  void unsafe_arena_set_allocated_remove(
      ::GameState::RemoveMutation* remove);
  ::GameState::RemoveMutation* unsafe_arena_release_remove();

  // .GameState.InsertMutation Insert = 3;
  bool has_insert() const;
  private:
  bool _internal_has_insert() const;
  public:
  void clear_insert();
  const ::GameState::InsertMutation& insert() const;
  ::GameState::InsertMutation* release_insert();
  ::GameState::InsertMutation* mutable_insert();
  void set_allocated_insert(::GameState::InsertMutation* insert);
  private:
  const ::GameState::InsertMutation& _internal_insert() const;
  ::GameState::InsertMutation* _internal_mutable_insert();
  public:
  void unsafe_arena_set_allocated_insert(
      ::GameState::InsertMutation* insert);
  ::GameState::InsertMutation* unsafe_arena_release_insert();

  void clear_mutation();
  MutationCase mutation_case() const;
  // @@protoc_insertion_point(class_scope:GameState.Mutation)
 private:
  class _Internal;
  void set_has_set();
  void set_has_remove();
  void set_has_insert();

  inline bool has_mutation() const;
  inline void clear_has_mutation();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union MutationUnion {
    MutationUnion() {}
    ::GameState::SetMutation* set_;
    ::GameState::RemoveMutation* remove_;
    ::GameState::InsertMutation* insert_;
  } mutation_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_GameState_2eproto;
};
// -------------------------------------------------------------------

class GameState PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GameState.GameState) */ {
 public:
  inline GameState() : GameState(nullptr) {}
  virtual ~GameState();

  GameState(const GameState& from);
  GameState(GameState&& from) noexcept
    : GameState() {
    *this = ::std::move(from);
  }

  inline GameState& operator=(const GameState& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameState& operator=(GameState&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GameState& default_instance();

  static inline const GameState* internal_default_instance() {
    return reinterpret_cast<const GameState*>(
               &_GameState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(GameState& a, GameState& b) {
    a.Swap(&b);
  }
  inline void Swap(GameState* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GameState* New() const final {
    return CreateMaybeMessage<GameState>(nullptr);
  }

  GameState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GameState>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GameState& from);
  void MergeFrom(const GameState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GameState.GameState";
  }
  protected:
  explicit GameState(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GameState_2eproto);
    return ::descriptor_table_GameState_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayersFieldNumber = 1,
    kCardsFieldNumber = 2,
    kTilesFieldNumber = 3,
    kTeamsFieldNumber = 4,
    kStackFieldNumber = 7,
    kTurnNumberFieldNumber = 6,
  };
  // repeated .GameState.Player Players = 1;
  int players_size() const;
  private:
  int _internal_players_size() const;
  public:
  void clear_players();
  ::GameState::Player* mutable_players(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::Player >*
      mutable_players();
  private:
  const ::GameState::Player& _internal_players(int index) const;
  ::GameState::Player* _internal_add_players();
  public:
  const ::GameState::Player& players(int index) const;
  ::GameState::Player* add_players();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::Player >&
      players() const;

  // repeated .GameState.Card Cards = 2;
  int cards_size() const;
  private:
  int _internal_cards_size() const;
  public:
  void clear_cards();
  ::GameState::Card* mutable_cards(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::Card >*
      mutable_cards();
  private:
  const ::GameState::Card& _internal_cards(int index) const;
  ::GameState::Card* _internal_add_cards();
  public:
  const ::GameState::Card& cards(int index) const;
  ::GameState::Card* add_cards();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::Card >&
      cards() const;

  // repeated .GameState.Tile Tiles = 3;
  int tiles_size() const;
  private:
  int _internal_tiles_size() const;
  public:
  void clear_tiles();
  ::GameState::Tile* mutable_tiles(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::Tile >*
      mutable_tiles();
  private:
  const ::GameState::Tile& _internal_tiles(int index) const;
  ::GameState::Tile* _internal_add_tiles();
  public:
  const ::GameState::Tile& tiles(int index) const;
  ::GameState::Tile* add_tiles();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::Tile >&
      tiles() const;

  // repeated .GameState.Team Teams = 4;
  int teams_size() const;
  private:
  int _internal_teams_size() const;
  public:
  void clear_teams();
  ::GameState::Team* mutable_teams(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::Team >*
      mutable_teams();
  private:
  const ::GameState::Team& _internal_teams(int index) const;
  ::GameState::Team* _internal_add_teams();
  public:
  const ::GameState::Team& teams(int index) const;
  ::GameState::Team* add_teams();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::Team >&
      teams() const;

  // repeated .GameState.Card Stack = 7;
  int stack_size() const;
  private:
  int _internal_stack_size() const;
  public:
  void clear_stack();
  ::GameState::Card* mutable_stack(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::Card >*
      mutable_stack();
  private:
  const ::GameState::Card& _internal_stack(int index) const;
  ::GameState::Card* _internal_add_stack();
  public:
  const ::GameState::Card& stack(int index) const;
  ::GameState::Card* add_stack();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::Card >&
      stack() const;

  // .GameState.Integer TurnNumber = 6;
  bool has_turnnumber() const;
  private:
  bool _internal_has_turnnumber() const;
  public:
  void clear_turnnumber();
  const ::GameState::Integer& turnnumber() const;
  ::GameState::Integer* release_turnnumber();
  ::GameState::Integer* mutable_turnnumber();
  void set_allocated_turnnumber(::GameState::Integer* turnnumber);
  private:
  const ::GameState::Integer& _internal_turnnumber() const;
  ::GameState::Integer* _internal_mutable_turnnumber();
  public:
  void unsafe_arena_set_allocated_turnnumber(
      ::GameState::Integer* turnnumber);
  ::GameState::Integer* unsafe_arena_release_turnnumber();

  // @@protoc_insertion_point(class_scope:GameState.GameState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::Player > players_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::Card > cards_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::Tile > tiles_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::Team > teams_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::Card > stack_;
  ::GameState::Integer* turnnumber_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameState_2eproto;
};
// -------------------------------------------------------------------

class GameInstance PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GameState.GameInstance) */ {
 public:
  inline GameInstance() : GameInstance(nullptr) {}
  virtual ~GameInstance();

  GameInstance(const GameInstance& from);
  GameInstance(GameInstance&& from) noexcept
    : GameInstance() {
    *this = ::std::move(from);
  }

  inline GameInstance& operator=(const GameInstance& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameInstance& operator=(GameInstance&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GameInstance& default_instance();

  static inline const GameInstance* internal_default_instance() {
    return reinterpret_cast<const GameInstance*>(
               &_GameInstance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(GameInstance& a, GameInstance& b) {
    a.Swap(&b);
  }
  inline void Swap(GameInstance* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameInstance* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GameInstance* New() const final {
    return CreateMaybeMessage<GameInstance>(nullptr);
  }

  GameInstance* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GameInstance>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GameInstance& from);
  void MergeFrom(const GameInstance& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameInstance* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GameState.GameInstance";
  }
  protected:
  explicit GameInstance(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GameState_2eproto);
    return ::descriptor_table_GameState_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHistoryFieldNumber = 2,
    kGameStateFieldNumber = 1,
  };
  // repeated .GameState.Mutation History = 2;
  int history_size() const;
  private:
  int _internal_history_size() const;
  public:
  void clear_history();
  ::GameState::Mutation* mutable_history(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::Mutation >*
      mutable_history();
  private:
  const ::GameState::Mutation& _internal_history(int index) const;
  ::GameState::Mutation* _internal_add_history();
  public:
  const ::GameState::Mutation& history(int index) const;
  ::GameState::Mutation* add_history();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::Mutation >&
      history() const;

  // .GameState.GameState GameState = 1;
  bool has_gamestate() const;
  private:
  bool _internal_has_gamestate() const;
  public:
  void clear_gamestate();
  const ::GameState::GameState& gamestate() const;
  ::GameState::GameState* release_gamestate();
  ::GameState::GameState* mutable_gamestate();
  void set_allocated_gamestate(::GameState::GameState* gamestate);
  private:
  const ::GameState::GameState& _internal_gamestate() const;
  ::GameState::GameState* _internal_mutable_gamestate();
  public:
  void unsafe_arena_set_allocated_gamestate(
      ::GameState::GameState* gamestate);
  ::GameState::GameState* unsafe_arena_release_gamestate();

  // @@protoc_insertion_point(class_scope:GameState.GameInstance)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::Mutation > history_;
  ::GameState::GameState* gamestate_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameState_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Path

// repeated int32 FieldIndex = 1;
inline int Path::_internal_fieldindex_size() const {
  return fieldindex_.size();
}
inline int Path::fieldindex_size() const {
  return _internal_fieldindex_size();
}
inline void Path::clear_fieldindex() {
  fieldindex_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Path::_internal_fieldindex(int index) const {
  return fieldindex_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Path::fieldindex(int index) const {
  // @@protoc_insertion_point(field_get:GameState.Path.FieldIndex)
  return _internal_fieldindex(index);
}
inline void Path::set_fieldindex(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  fieldindex_.Set(index, value);
  // @@protoc_insertion_point(field_set:GameState.Path.FieldIndex)
}
inline void Path::_internal_add_fieldindex(::PROTOBUF_NAMESPACE_ID::int32 value) {
  fieldindex_.Add(value);
}
inline void Path::add_fieldindex(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_fieldindex(value);
  // @@protoc_insertion_point(field_add:GameState.Path.FieldIndex)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
Path::_internal_fieldindex() const {
  return fieldindex_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
Path::fieldindex() const {
  // @@protoc_insertion_point(field_list:GameState.Path.FieldIndex)
  return _internal_fieldindex();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
Path::_internal_mutable_fieldindex() {
  return &fieldindex_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
Path::mutable_fieldindex() {
  // @@protoc_insertion_point(field_mutable_list:GameState.Path.FieldIndex)
  return _internal_mutable_fieldindex();
}

// -------------------------------------------------------------------

// Integer

// int32 Value = 1;
inline void Integer::clear_value() {
  value_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Integer::_internal_value() const {
  return value_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Integer::value() const {
  // @@protoc_insertion_point(field_get:GameState.Integer.Value)
  return _internal_value();
}
inline void Integer::_internal_set_value(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  value_ = value;
}
inline void Integer::set_value(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:GameState.Integer.Value)
}

// -------------------------------------------------------------------

// Vec2i

// int32 X = 1;
inline void Vec2i::clear_x() {
  x_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Vec2i::_internal_x() const {
  return x_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Vec2i::x() const {
  // @@protoc_insertion_point(field_get:GameState.Vec2i.X)
  return _internal_x();
}
inline void Vec2i::_internal_set_x(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  x_ = value;
}
inline void Vec2i::set_x(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:GameState.Vec2i.X)
}

// int32 Y = 2;
inline void Vec2i::clear_y() {
  y_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Vec2i::_internal_y() const {
  return y_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Vec2i::y() const {
  // @@protoc_insertion_point(field_get:GameState.Vec2i.Y)
  return _internal_y();
}
inline void Vec2i::_internal_set_y(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  y_ = value;
}
inline void Vec2i::set_y(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:GameState.Vec2i.Y)
}

// -------------------------------------------------------------------

// PlayerRef

// .GameState.Path ObjectPath = 1;
inline bool PlayerRef::_internal_has_objectpath() const {
  return this != internal_default_instance() && objectpath_ != nullptr;
}
inline bool PlayerRef::has_objectpath() const {
  return _internal_has_objectpath();
}
inline void PlayerRef::clear_objectpath() {
  if (GetArena() == nullptr && objectpath_ != nullptr) {
    delete objectpath_;
  }
  objectpath_ = nullptr;
}
inline const ::GameState::Path& PlayerRef::_internal_objectpath() const {
  const ::GameState::Path* p = objectpath_;
  return p != nullptr ? *p : reinterpret_cast<const ::GameState::Path&>(
      ::GameState::_Path_default_instance_);
}
inline const ::GameState::Path& PlayerRef::objectpath() const {
  // @@protoc_insertion_point(field_get:GameState.PlayerRef.ObjectPath)
  return _internal_objectpath();
}
inline void PlayerRef::unsafe_arena_set_allocated_objectpath(
    ::GameState::Path* objectpath) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(objectpath_);
  }
  objectpath_ = objectpath;
  if (objectpath) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.PlayerRef.ObjectPath)
}
inline ::GameState::Path* PlayerRef::release_objectpath() {
  
  ::GameState::Path* temp = objectpath_;
  objectpath_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::GameState::Path* PlayerRef::unsafe_arena_release_objectpath() {
  // @@protoc_insertion_point(field_release:GameState.PlayerRef.ObjectPath)
  
  ::GameState::Path* temp = objectpath_;
  objectpath_ = nullptr;
  return temp;
}
inline ::GameState::Path* PlayerRef::_internal_mutable_objectpath() {
  
  if (objectpath_ == nullptr) {
    auto* p = CreateMaybeMessage<::GameState::Path>(GetArena());
    objectpath_ = p;
  }
  return objectpath_;
}
inline ::GameState::Path* PlayerRef::mutable_objectpath() {
  // @@protoc_insertion_point(field_mutable:GameState.PlayerRef.ObjectPath)
  return _internal_mutable_objectpath();
}
inline void PlayerRef::set_allocated_objectpath(::GameState::Path* objectpath) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete objectpath_;
  }
  if (objectpath) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(objectpath);
    if (message_arena != submessage_arena) {
      objectpath = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, objectpath, submessage_arena);
    }
    
  } else {
    
  }
  objectpath_ = objectpath;
  // @@protoc_insertion_point(field_set_allocated:GameState.PlayerRef.ObjectPath)
}

// -------------------------------------------------------------------

// CardRef

// .GameState.Path ObjectPath = 1;
inline bool CardRef::_internal_has_objectpath() const {
  return this != internal_default_instance() && objectpath_ != nullptr;
}
inline bool CardRef::has_objectpath() const {
  return _internal_has_objectpath();
}
inline void CardRef::clear_objectpath() {
  if (GetArena() == nullptr && objectpath_ != nullptr) {
    delete objectpath_;
  }
  objectpath_ = nullptr;
}
inline const ::GameState::Path& CardRef::_internal_objectpath() const {
  const ::GameState::Path* p = objectpath_;
  return p != nullptr ? *p : reinterpret_cast<const ::GameState::Path&>(
      ::GameState::_Path_default_instance_);
}
inline const ::GameState::Path& CardRef::objectpath() const {
  // @@protoc_insertion_point(field_get:GameState.CardRef.ObjectPath)
  return _internal_objectpath();
}
inline void CardRef::unsafe_arena_set_allocated_objectpath(
    ::GameState::Path* objectpath) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(objectpath_);
  }
  objectpath_ = objectpath;
  if (objectpath) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.CardRef.ObjectPath)
}
inline ::GameState::Path* CardRef::release_objectpath() {
  
  ::GameState::Path* temp = objectpath_;
  objectpath_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::GameState::Path* CardRef::unsafe_arena_release_objectpath() {
  // @@protoc_insertion_point(field_release:GameState.CardRef.ObjectPath)
  
  ::GameState::Path* temp = objectpath_;
  objectpath_ = nullptr;
  return temp;
}
inline ::GameState::Path* CardRef::_internal_mutable_objectpath() {
  
  if (objectpath_ == nullptr) {
    auto* p = CreateMaybeMessage<::GameState::Path>(GetArena());
    objectpath_ = p;
  }
  return objectpath_;
}
inline ::GameState::Path* CardRef::mutable_objectpath() {
  // @@protoc_insertion_point(field_mutable:GameState.CardRef.ObjectPath)
  return _internal_mutable_objectpath();
}
inline void CardRef::set_allocated_objectpath(::GameState::Path* objectpath) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete objectpath_;
  }
  if (objectpath) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(objectpath);
    if (message_arena != submessage_arena) {
      objectpath = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, objectpath, submessage_arena);
    }
    
  } else {
    
  }
  objectpath_ = objectpath;
  // @@protoc_insertion_point(field_set_allocated:GameState.CardRef.ObjectPath)
}

// -------------------------------------------------------------------

// TileRef

// .GameState.Path ObjectPath = 1;
inline bool TileRef::_internal_has_objectpath() const {
  return this != internal_default_instance() && objectpath_ != nullptr;
}
inline bool TileRef::has_objectpath() const {
  return _internal_has_objectpath();
}
inline void TileRef::clear_objectpath() {
  if (GetArena() == nullptr && objectpath_ != nullptr) {
    delete objectpath_;
  }
  objectpath_ = nullptr;
}
inline const ::GameState::Path& TileRef::_internal_objectpath() const {
  const ::GameState::Path* p = objectpath_;
  return p != nullptr ? *p : reinterpret_cast<const ::GameState::Path&>(
      ::GameState::_Path_default_instance_);
}
inline const ::GameState::Path& TileRef::objectpath() const {
  // @@protoc_insertion_point(field_get:GameState.TileRef.ObjectPath)
  return _internal_objectpath();
}
inline void TileRef::unsafe_arena_set_allocated_objectpath(
    ::GameState::Path* objectpath) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(objectpath_);
  }
  objectpath_ = objectpath;
  if (objectpath) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.TileRef.ObjectPath)
}
inline ::GameState::Path* TileRef::release_objectpath() {
  
  ::GameState::Path* temp = objectpath_;
  objectpath_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::GameState::Path* TileRef::unsafe_arena_release_objectpath() {
  // @@protoc_insertion_point(field_release:GameState.TileRef.ObjectPath)
  
  ::GameState::Path* temp = objectpath_;
  objectpath_ = nullptr;
  return temp;
}
inline ::GameState::Path* TileRef::_internal_mutable_objectpath() {
  
  if (objectpath_ == nullptr) {
    auto* p = CreateMaybeMessage<::GameState::Path>(GetArena());
    objectpath_ = p;
  }
  return objectpath_;
}
inline ::GameState::Path* TileRef::mutable_objectpath() {
  // @@protoc_insertion_point(field_mutable:GameState.TileRef.ObjectPath)
  return _internal_mutable_objectpath();
}
inline void TileRef::set_allocated_objectpath(::GameState::Path* objectpath) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete objectpath_;
  }
  if (objectpath) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(objectpath);
    if (message_arena != submessage_arena) {
      objectpath = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, objectpath, submessage_arena);
    }
    
  } else {
    
  }
  objectpath_ = objectpath;
  // @@protoc_insertion_point(field_set_allocated:GameState.TileRef.ObjectPath)
}

// -------------------------------------------------------------------

// IntegerRef

// .GameState.Path ObjectPath = 1;
inline bool IntegerRef::_internal_has_objectpath() const {
  return this != internal_default_instance() && objectpath_ != nullptr;
}
inline bool IntegerRef::has_objectpath() const {
  return _internal_has_objectpath();
}
inline void IntegerRef::clear_objectpath() {
  if (GetArena() == nullptr && objectpath_ != nullptr) {
    delete objectpath_;
  }
  objectpath_ = nullptr;
}
inline const ::GameState::Path& IntegerRef::_internal_objectpath() const {
  const ::GameState::Path* p = objectpath_;
  return p != nullptr ? *p : reinterpret_cast<const ::GameState::Path&>(
      ::GameState::_Path_default_instance_);
}
inline const ::GameState::Path& IntegerRef::objectpath() const {
  // @@protoc_insertion_point(field_get:GameState.IntegerRef.ObjectPath)
  return _internal_objectpath();
}
inline void IntegerRef::unsafe_arena_set_allocated_objectpath(
    ::GameState::Path* objectpath) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(objectpath_);
  }
  objectpath_ = objectpath;
  if (objectpath) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.IntegerRef.ObjectPath)
}
inline ::GameState::Path* IntegerRef::release_objectpath() {
  
  ::GameState::Path* temp = objectpath_;
  objectpath_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::GameState::Path* IntegerRef::unsafe_arena_release_objectpath() {
  // @@protoc_insertion_point(field_release:GameState.IntegerRef.ObjectPath)
  
  ::GameState::Path* temp = objectpath_;
  objectpath_ = nullptr;
  return temp;
}
inline ::GameState::Path* IntegerRef::_internal_mutable_objectpath() {
  
  if (objectpath_ == nullptr) {
    auto* p = CreateMaybeMessage<::GameState::Path>(GetArena());
    objectpath_ = p;
  }
  return objectpath_;
}
inline ::GameState::Path* IntegerRef::mutable_objectpath() {
  // @@protoc_insertion_point(field_mutable:GameState.IntegerRef.ObjectPath)
  return _internal_mutable_objectpath();
}
inline void IntegerRef::set_allocated_objectpath(::GameState::Path* objectpath) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete objectpath_;
  }
  if (objectpath) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(objectpath);
    if (message_arena != submessage_arena) {
      objectpath = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, objectpath, submessage_arena);
    }
    
  } else {
    
  }
  objectpath_ = objectpath;
  // @@protoc_insertion_point(field_set_allocated:GameState.IntegerRef.ObjectPath)
}

// -------------------------------------------------------------------

// Vec2iRef

// .GameState.Path ObjectPath = 1;
inline bool Vec2iRef::_internal_has_objectpath() const {
  return this != internal_default_instance() && objectpath_ != nullptr;
}
inline bool Vec2iRef::has_objectpath() const {
  return _internal_has_objectpath();
}
inline void Vec2iRef::clear_objectpath() {
  if (GetArena() == nullptr && objectpath_ != nullptr) {
    delete objectpath_;
  }
  objectpath_ = nullptr;
}
inline const ::GameState::Path& Vec2iRef::_internal_objectpath() const {
  const ::GameState::Path* p = objectpath_;
  return p != nullptr ? *p : reinterpret_cast<const ::GameState::Path&>(
      ::GameState::_Path_default_instance_);
}
inline const ::GameState::Path& Vec2iRef::objectpath() const {
  // @@protoc_insertion_point(field_get:GameState.Vec2iRef.ObjectPath)
  return _internal_objectpath();
}
inline void Vec2iRef::unsafe_arena_set_allocated_objectpath(
    ::GameState::Path* objectpath) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(objectpath_);
  }
  objectpath_ = objectpath;
  if (objectpath) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.Vec2iRef.ObjectPath)
}
inline ::GameState::Path* Vec2iRef::release_objectpath() {
  
  ::GameState::Path* temp = objectpath_;
  objectpath_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::GameState::Path* Vec2iRef::unsafe_arena_release_objectpath() {
  // @@protoc_insertion_point(field_release:GameState.Vec2iRef.ObjectPath)
  
  ::GameState::Path* temp = objectpath_;
  objectpath_ = nullptr;
  return temp;
}
inline ::GameState::Path* Vec2iRef::_internal_mutable_objectpath() {
  
  if (objectpath_ == nullptr) {
    auto* p = CreateMaybeMessage<::GameState::Path>(GetArena());
    objectpath_ = p;
  }
  return objectpath_;
}
inline ::GameState::Path* Vec2iRef::mutable_objectpath() {
  // @@protoc_insertion_point(field_mutable:GameState.Vec2iRef.ObjectPath)
  return _internal_mutable_objectpath();
}
inline void Vec2iRef::set_allocated_objectpath(::GameState::Path* objectpath) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete objectpath_;
  }
  if (objectpath) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(objectpath);
    if (message_arena != submessage_arena) {
      objectpath = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, objectpath, submessage_arena);
    }
    
  } else {
    
  }
  objectpath_ = objectpath;
  // @@protoc_insertion_point(field_set_allocated:GameState.Vec2iRef.ObjectPath)
}

// -------------------------------------------------------------------

// IntegerValue

// int32 Value = 1;
inline bool IntegerValue::_internal_has_value() const {
  return value_case() == kValue;
}
inline void IntegerValue::set_has_value() {
  _oneof_case_[0] = kValue;
}
inline void IntegerValue::clear_value() {
  if (_internal_has_value()) {
    value_.value_ = 0;
    clear_has_value();
  }
}
inline ::PROTOBUF_NAMESPACE_ID::int32 IntegerValue::_internal_value() const {
  if (_internal_has_value()) {
    return value_.value_;
  }
  return 0;
}
inline void IntegerValue::_internal_set_value(::PROTOBUF_NAMESPACE_ID::int32 value) {
  if (!_internal_has_value()) {
    clear_value();
    set_has_value();
  }
  value_.value_ = value;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 IntegerValue::value() const {
  // @@protoc_insertion_point(field_get:GameState.IntegerValue.Value)
  return _internal_value();
}
inline void IntegerValue::set_value(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:GameState.IntegerValue.Value)
}

// .GameState.IntegerRef Ref = 2;
inline bool IntegerValue::_internal_has_ref() const {
  return value_case() == kRef;
}
inline bool IntegerValue::has_ref() const {
  return _internal_has_ref();
}
inline void IntegerValue::set_has_ref() {
  _oneof_case_[0] = kRef;
}
inline void IntegerValue::clear_ref() {
  if (_internal_has_ref()) {
    if (GetArena() == nullptr) {
      delete value_.ref_;
    }
    clear_has_value();
  }
}
inline ::GameState::IntegerRef* IntegerValue::release_ref() {
  // @@protoc_insertion_point(field_release:GameState.IntegerValue.Ref)
  if (_internal_has_ref()) {
    clear_has_value();
      ::GameState::IntegerRef* temp = value_.ref_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.ref_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::GameState::IntegerRef& IntegerValue::_internal_ref() const {
  return _internal_has_ref()
      ? *value_.ref_
      : reinterpret_cast< ::GameState::IntegerRef&>(::GameState::_IntegerRef_default_instance_);
}
inline const ::GameState::IntegerRef& IntegerValue::ref() const {
  // @@protoc_insertion_point(field_get:GameState.IntegerValue.Ref)
  return _internal_ref();
}
inline ::GameState::IntegerRef* IntegerValue::unsafe_arena_release_ref() {
  // @@protoc_insertion_point(field_unsafe_arena_release:GameState.IntegerValue.Ref)
  if (_internal_has_ref()) {
    clear_has_value();
    ::GameState::IntegerRef* temp = value_.ref_;
    value_.ref_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void IntegerValue::unsafe_arena_set_allocated_ref(::GameState::IntegerRef* ref) {
  clear_value();
  if (ref) {
    set_has_ref();
    value_.ref_ = ref;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.IntegerValue.Ref)
}
inline ::GameState::IntegerRef* IntegerValue::_internal_mutable_ref() {
  if (!_internal_has_ref()) {
    clear_value();
    set_has_ref();
    value_.ref_ = CreateMaybeMessage< ::GameState::IntegerRef >(GetArena());
  }
  return value_.ref_;
}
inline ::GameState::IntegerRef* IntegerValue::mutable_ref() {
  // @@protoc_insertion_point(field_mutable:GameState.IntegerValue.Ref)
  return _internal_mutable_ref();
}

inline bool IntegerValue::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void IntegerValue::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline IntegerValue::ValueCase IntegerValue::value_case() const {
  return IntegerValue::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Vec2iValue

// .GameState.Vec2i Value = 1;
inline bool Vec2iValue::_internal_has_value() const {
  return value_case() == kValue;
}
inline bool Vec2iValue::has_value() const {
  return _internal_has_value();
}
inline void Vec2iValue::set_has_value() {
  _oneof_case_[0] = kValue;
}
inline void Vec2iValue::clear_value() {
  if (_internal_has_value()) {
    if (GetArena() == nullptr) {
      delete value_.value_;
    }
    clear_has_value();
  }
}
inline ::GameState::Vec2i* Vec2iValue::release_value() {
  // @@protoc_insertion_point(field_release:GameState.Vec2iValue.Value)
  if (_internal_has_value()) {
    clear_has_value();
      ::GameState::Vec2i* temp = value_.value_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::GameState::Vec2i& Vec2iValue::_internal_value() const {
  return _internal_has_value()
      ? *value_.value_
      : reinterpret_cast< ::GameState::Vec2i&>(::GameState::_Vec2i_default_instance_);
}
inline const ::GameState::Vec2i& Vec2iValue::value() const {
  // @@protoc_insertion_point(field_get:GameState.Vec2iValue.Value)
  return _internal_value();
}
inline ::GameState::Vec2i* Vec2iValue::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:GameState.Vec2iValue.Value)
  if (_internal_has_value()) {
    clear_has_value();
    ::GameState::Vec2i* temp = value_.value_;
    value_.value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Vec2iValue::unsafe_arena_set_allocated_value(::GameState::Vec2i* value) {
  clear_value();
  if (value) {
    set_has_value();
    value_.value_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.Vec2iValue.Value)
}
inline ::GameState::Vec2i* Vec2iValue::_internal_mutable_value() {
  if (!_internal_has_value()) {
    clear_value();
    set_has_value();
    value_.value_ = CreateMaybeMessage< ::GameState::Vec2i >(GetArena());
  }
  return value_.value_;
}
inline ::GameState::Vec2i* Vec2iValue::mutable_value() {
  // @@protoc_insertion_point(field_mutable:GameState.Vec2iValue.Value)
  return _internal_mutable_value();
}

// .GameState.Vec2iRef Ref = 2;
inline bool Vec2iValue::_internal_has_ref() const {
  return value_case() == kRef;
}
inline bool Vec2iValue::has_ref() const {
  return _internal_has_ref();
}
inline void Vec2iValue::set_has_ref() {
  _oneof_case_[0] = kRef;
}
inline void Vec2iValue::clear_ref() {
  if (_internal_has_ref()) {
    if (GetArena() == nullptr) {
      delete value_.ref_;
    }
    clear_has_value();
  }
}
inline ::GameState::Vec2iRef* Vec2iValue::release_ref() {
  // @@protoc_insertion_point(field_release:GameState.Vec2iValue.Ref)
  if (_internal_has_ref()) {
    clear_has_value();
      ::GameState::Vec2iRef* temp = value_.ref_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.ref_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::GameState::Vec2iRef& Vec2iValue::_internal_ref() const {
  return _internal_has_ref()
      ? *value_.ref_
      : reinterpret_cast< ::GameState::Vec2iRef&>(::GameState::_Vec2iRef_default_instance_);
}
inline const ::GameState::Vec2iRef& Vec2iValue::ref() const {
  // @@protoc_insertion_point(field_get:GameState.Vec2iValue.Ref)
  return _internal_ref();
}
inline ::GameState::Vec2iRef* Vec2iValue::unsafe_arena_release_ref() {
  // @@protoc_insertion_point(field_unsafe_arena_release:GameState.Vec2iValue.Ref)
  if (_internal_has_ref()) {
    clear_has_value();
    ::GameState::Vec2iRef* temp = value_.ref_;
    value_.ref_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Vec2iValue::unsafe_arena_set_allocated_ref(::GameState::Vec2iRef* ref) {
  clear_value();
  if (ref) {
    set_has_ref();
    value_.ref_ = ref;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.Vec2iValue.Ref)
}
inline ::GameState::Vec2iRef* Vec2iValue::_internal_mutable_ref() {
  if (!_internal_has_ref()) {
    clear_value();
    set_has_ref();
    value_.ref_ = CreateMaybeMessage< ::GameState::Vec2iRef >(GetArena());
  }
  return value_.ref_;
}
inline ::GameState::Vec2iRef* Vec2iValue::mutable_ref() {
  // @@protoc_insertion_point(field_mutable:GameState.Vec2iValue.Ref)
  return _internal_mutable_ref();
}

inline bool Vec2iValue::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void Vec2iValue::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline Vec2iValue::ValueCase Vec2iValue::value_case() const {
  return Vec2iValue::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// EntityRef

// .GameState.PlayerRef Player = 1;
inline bool EntityRef::_internal_has_player() const {
  return entity_ref_case() == kPlayer;
}
inline bool EntityRef::has_player() const {
  return _internal_has_player();
}
inline void EntityRef::set_has_player() {
  _oneof_case_[0] = kPlayer;
}
inline void EntityRef::clear_player() {
  if (_internal_has_player()) {
    if (GetArena() == nullptr) {
      delete entity_ref_.player_;
    }
    clear_has_entity_ref();
  }
}
inline ::GameState::PlayerRef* EntityRef::release_player() {
  // @@protoc_insertion_point(field_release:GameState.EntityRef.Player)
  if (_internal_has_player()) {
    clear_has_entity_ref();
      ::GameState::PlayerRef* temp = entity_ref_.player_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    entity_ref_.player_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::GameState::PlayerRef& EntityRef::_internal_player() const {
  return _internal_has_player()
      ? *entity_ref_.player_
      : reinterpret_cast< ::GameState::PlayerRef&>(::GameState::_PlayerRef_default_instance_);
}
inline const ::GameState::PlayerRef& EntityRef::player() const {
  // @@protoc_insertion_point(field_get:GameState.EntityRef.Player)
  return _internal_player();
}
inline ::GameState::PlayerRef* EntityRef::unsafe_arena_release_player() {
  // @@protoc_insertion_point(field_unsafe_arena_release:GameState.EntityRef.Player)
  if (_internal_has_player()) {
    clear_has_entity_ref();
    ::GameState::PlayerRef* temp = entity_ref_.player_;
    entity_ref_.player_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EntityRef::unsafe_arena_set_allocated_player(::GameState::PlayerRef* player) {
  clear_entity_ref();
  if (player) {
    set_has_player();
    entity_ref_.player_ = player;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.EntityRef.Player)
}
inline ::GameState::PlayerRef* EntityRef::_internal_mutable_player() {
  if (!_internal_has_player()) {
    clear_entity_ref();
    set_has_player();
    entity_ref_.player_ = CreateMaybeMessage< ::GameState::PlayerRef >(GetArena());
  }
  return entity_ref_.player_;
}
inline ::GameState::PlayerRef* EntityRef::mutable_player() {
  // @@protoc_insertion_point(field_mutable:GameState.EntityRef.Player)
  return _internal_mutable_player();
}

// .GameState.CardRef Card = 2;
inline bool EntityRef::_internal_has_card() const {
  return entity_ref_case() == kCard;
}
inline bool EntityRef::has_card() const {
  return _internal_has_card();
}
inline void EntityRef::set_has_card() {
  _oneof_case_[0] = kCard;
}
inline void EntityRef::clear_card() {
  if (_internal_has_card()) {
    if (GetArena() == nullptr) {
      delete entity_ref_.card_;
    }
    clear_has_entity_ref();
  }
}
inline ::GameState::CardRef* EntityRef::release_card() {
  // @@protoc_insertion_point(field_release:GameState.EntityRef.Card)
  if (_internal_has_card()) {
    clear_has_entity_ref();
      ::GameState::CardRef* temp = entity_ref_.card_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    entity_ref_.card_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::GameState::CardRef& EntityRef::_internal_card() const {
  return _internal_has_card()
      ? *entity_ref_.card_
      : reinterpret_cast< ::GameState::CardRef&>(::GameState::_CardRef_default_instance_);
}
inline const ::GameState::CardRef& EntityRef::card() const {
  // @@protoc_insertion_point(field_get:GameState.EntityRef.Card)
  return _internal_card();
}
inline ::GameState::CardRef* EntityRef::unsafe_arena_release_card() {
  // @@protoc_insertion_point(field_unsafe_arena_release:GameState.EntityRef.Card)
  if (_internal_has_card()) {
    clear_has_entity_ref();
    ::GameState::CardRef* temp = entity_ref_.card_;
    entity_ref_.card_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EntityRef::unsafe_arena_set_allocated_card(::GameState::CardRef* card) {
  clear_entity_ref();
  if (card) {
    set_has_card();
    entity_ref_.card_ = card;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.EntityRef.Card)
}
inline ::GameState::CardRef* EntityRef::_internal_mutable_card() {
  if (!_internal_has_card()) {
    clear_entity_ref();
    set_has_card();
    entity_ref_.card_ = CreateMaybeMessage< ::GameState::CardRef >(GetArena());
  }
  return entity_ref_.card_;
}
inline ::GameState::CardRef* EntityRef::mutable_card() {
  // @@protoc_insertion_point(field_mutable:GameState.EntityRef.Card)
  return _internal_mutable_card();
}

// .GameState.TileRef Tile = 3;
inline bool EntityRef::_internal_has_tile() const {
  return entity_ref_case() == kTile;
}
inline bool EntityRef::has_tile() const {
  return _internal_has_tile();
}
inline void EntityRef::set_has_tile() {
  _oneof_case_[0] = kTile;
}
inline void EntityRef::clear_tile() {
  if (_internal_has_tile()) {
    if (GetArena() == nullptr) {
      delete entity_ref_.tile_;
    }
    clear_has_entity_ref();
  }
}
inline ::GameState::TileRef* EntityRef::release_tile() {
  // @@protoc_insertion_point(field_release:GameState.EntityRef.Tile)
  if (_internal_has_tile()) {
    clear_has_entity_ref();
      ::GameState::TileRef* temp = entity_ref_.tile_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    entity_ref_.tile_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::GameState::TileRef& EntityRef::_internal_tile() const {
  return _internal_has_tile()
      ? *entity_ref_.tile_
      : reinterpret_cast< ::GameState::TileRef&>(::GameState::_TileRef_default_instance_);
}
inline const ::GameState::TileRef& EntityRef::tile() const {
  // @@protoc_insertion_point(field_get:GameState.EntityRef.Tile)
  return _internal_tile();
}
inline ::GameState::TileRef* EntityRef::unsafe_arena_release_tile() {
  // @@protoc_insertion_point(field_unsafe_arena_release:GameState.EntityRef.Tile)
  if (_internal_has_tile()) {
    clear_has_entity_ref();
    ::GameState::TileRef* temp = entity_ref_.tile_;
    entity_ref_.tile_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EntityRef::unsafe_arena_set_allocated_tile(::GameState::TileRef* tile) {
  clear_entity_ref();
  if (tile) {
    set_has_tile();
    entity_ref_.tile_ = tile;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.EntityRef.Tile)
}
inline ::GameState::TileRef* EntityRef::_internal_mutable_tile() {
  if (!_internal_has_tile()) {
    clear_entity_ref();
    set_has_tile();
    entity_ref_.tile_ = CreateMaybeMessage< ::GameState::TileRef >(GetArena());
  }
  return entity_ref_.tile_;
}
inline ::GameState::TileRef* EntityRef::mutable_tile() {
  // @@protoc_insertion_point(field_mutable:GameState.EntityRef.Tile)
  return _internal_mutable_tile();
}

inline bool EntityRef::has_entity_ref() const {
  return entity_ref_case() != ENTITY_REF_NOT_SET;
}
inline void EntityRef::clear_has_entity_ref() {
  _oneof_case_[0] = ENTITY_REF_NOT_SET;
}
inline EntityRef::EntityRefCase EntityRef::entity_ref_case() const {
  return EntityRef::EntityRefCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// EntityValue

// .GameState.PlayerRef Player = 1;
inline bool EntityValue::_internal_has_player() const {
  return entity_val_case() == kPlayer;
}
inline bool EntityValue::has_player() const {
  return _internal_has_player();
}
inline void EntityValue::set_has_player() {
  _oneof_case_[0] = kPlayer;
}
inline void EntityValue::clear_player() {
  if (_internal_has_player()) {
    if (GetArena() == nullptr) {
      delete entity_val_.player_;
    }
    clear_has_entity_val();
  }
}
inline ::GameState::PlayerRef* EntityValue::release_player() {
  // @@protoc_insertion_point(field_release:GameState.EntityValue.Player)
  if (_internal_has_player()) {
    clear_has_entity_val();
      ::GameState::PlayerRef* temp = entity_val_.player_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    entity_val_.player_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::GameState::PlayerRef& EntityValue::_internal_player() const {
  return _internal_has_player()
      ? *entity_val_.player_
      : reinterpret_cast< ::GameState::PlayerRef&>(::GameState::_PlayerRef_default_instance_);
}
inline const ::GameState::PlayerRef& EntityValue::player() const {
  // @@protoc_insertion_point(field_get:GameState.EntityValue.Player)
  return _internal_player();
}
inline ::GameState::PlayerRef* EntityValue::unsafe_arena_release_player() {
  // @@protoc_insertion_point(field_unsafe_arena_release:GameState.EntityValue.Player)
  if (_internal_has_player()) {
    clear_has_entity_val();
    ::GameState::PlayerRef* temp = entity_val_.player_;
    entity_val_.player_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EntityValue::unsafe_arena_set_allocated_player(::GameState::PlayerRef* player) {
  clear_entity_val();
  if (player) {
    set_has_player();
    entity_val_.player_ = player;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.EntityValue.Player)
}
inline ::GameState::PlayerRef* EntityValue::_internal_mutable_player() {
  if (!_internal_has_player()) {
    clear_entity_val();
    set_has_player();
    entity_val_.player_ = CreateMaybeMessage< ::GameState::PlayerRef >(GetArena());
  }
  return entity_val_.player_;
}
inline ::GameState::PlayerRef* EntityValue::mutable_player() {
  // @@protoc_insertion_point(field_mutable:GameState.EntityValue.Player)
  return _internal_mutable_player();
}

// .GameState.CardRef Card = 2;
inline bool EntityValue::_internal_has_card() const {
  return entity_val_case() == kCard;
}
inline bool EntityValue::has_card() const {
  return _internal_has_card();
}
inline void EntityValue::set_has_card() {
  _oneof_case_[0] = kCard;
}
inline void EntityValue::clear_card() {
  if (_internal_has_card()) {
    if (GetArena() == nullptr) {
      delete entity_val_.card_;
    }
    clear_has_entity_val();
  }
}
inline ::GameState::CardRef* EntityValue::release_card() {
  // @@protoc_insertion_point(field_release:GameState.EntityValue.Card)
  if (_internal_has_card()) {
    clear_has_entity_val();
      ::GameState::CardRef* temp = entity_val_.card_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    entity_val_.card_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::GameState::CardRef& EntityValue::_internal_card() const {
  return _internal_has_card()
      ? *entity_val_.card_
      : reinterpret_cast< ::GameState::CardRef&>(::GameState::_CardRef_default_instance_);
}
inline const ::GameState::CardRef& EntityValue::card() const {
  // @@protoc_insertion_point(field_get:GameState.EntityValue.Card)
  return _internal_card();
}
inline ::GameState::CardRef* EntityValue::unsafe_arena_release_card() {
  // @@protoc_insertion_point(field_unsafe_arena_release:GameState.EntityValue.Card)
  if (_internal_has_card()) {
    clear_has_entity_val();
    ::GameState::CardRef* temp = entity_val_.card_;
    entity_val_.card_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EntityValue::unsafe_arena_set_allocated_card(::GameState::CardRef* card) {
  clear_entity_val();
  if (card) {
    set_has_card();
    entity_val_.card_ = card;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.EntityValue.Card)
}
inline ::GameState::CardRef* EntityValue::_internal_mutable_card() {
  if (!_internal_has_card()) {
    clear_entity_val();
    set_has_card();
    entity_val_.card_ = CreateMaybeMessage< ::GameState::CardRef >(GetArena());
  }
  return entity_val_.card_;
}
inline ::GameState::CardRef* EntityValue::mutable_card() {
  // @@protoc_insertion_point(field_mutable:GameState.EntityValue.Card)
  return _internal_mutable_card();
}

// .GameState.TileRef Tile = 3;
inline bool EntityValue::_internal_has_tile() const {
  return entity_val_case() == kTile;
}
inline bool EntityValue::has_tile() const {
  return _internal_has_tile();
}
inline void EntityValue::set_has_tile() {
  _oneof_case_[0] = kTile;
}
inline void EntityValue::clear_tile() {
  if (_internal_has_tile()) {
    if (GetArena() == nullptr) {
      delete entity_val_.tile_;
    }
    clear_has_entity_val();
  }
}
inline ::GameState::TileRef* EntityValue::release_tile() {
  // @@protoc_insertion_point(field_release:GameState.EntityValue.Tile)
  if (_internal_has_tile()) {
    clear_has_entity_val();
      ::GameState::TileRef* temp = entity_val_.tile_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    entity_val_.tile_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::GameState::TileRef& EntityValue::_internal_tile() const {
  return _internal_has_tile()
      ? *entity_val_.tile_
      : reinterpret_cast< ::GameState::TileRef&>(::GameState::_TileRef_default_instance_);
}
inline const ::GameState::TileRef& EntityValue::tile() const {
  // @@protoc_insertion_point(field_get:GameState.EntityValue.Tile)
  return _internal_tile();
}
inline ::GameState::TileRef* EntityValue::unsafe_arena_release_tile() {
  // @@protoc_insertion_point(field_unsafe_arena_release:GameState.EntityValue.Tile)
  if (_internal_has_tile()) {
    clear_has_entity_val();
    ::GameState::TileRef* temp = entity_val_.tile_;
    entity_val_.tile_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EntityValue::unsafe_arena_set_allocated_tile(::GameState::TileRef* tile) {
  clear_entity_val();
  if (tile) {
    set_has_tile();
    entity_val_.tile_ = tile;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.EntityValue.Tile)
}
inline ::GameState::TileRef* EntityValue::_internal_mutable_tile() {
  if (!_internal_has_tile()) {
    clear_entity_val();
    set_has_tile();
    entity_val_.tile_ = CreateMaybeMessage< ::GameState::TileRef >(GetArena());
  }
  return entity_val_.tile_;
}
inline ::GameState::TileRef* EntityValue::mutable_tile() {
  // @@protoc_insertion_point(field_mutable:GameState.EntityValue.Tile)
  return _internal_mutable_tile();
}

// .GameState.IntegerRef Integer = 4;
inline bool EntityValue::_internal_has_integer() const {
  return entity_val_case() == kInteger;
}
inline bool EntityValue::has_integer() const {
  return _internal_has_integer();
}
inline void EntityValue::set_has_integer() {
  _oneof_case_[0] = kInteger;
}
inline void EntityValue::clear_integer() {
  if (_internal_has_integer()) {
    if (GetArena() == nullptr) {
      delete entity_val_.integer_;
    }
    clear_has_entity_val();
  }
}
inline ::GameState::IntegerRef* EntityValue::release_integer() {
  // @@protoc_insertion_point(field_release:GameState.EntityValue.Integer)
  if (_internal_has_integer()) {
    clear_has_entity_val();
      ::GameState::IntegerRef* temp = entity_val_.integer_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    entity_val_.integer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::GameState::IntegerRef& EntityValue::_internal_integer() const {
  return _internal_has_integer()
      ? *entity_val_.integer_
      : reinterpret_cast< ::GameState::IntegerRef&>(::GameState::_IntegerRef_default_instance_);
}
inline const ::GameState::IntegerRef& EntityValue::integer() const {
  // @@protoc_insertion_point(field_get:GameState.EntityValue.Integer)
  return _internal_integer();
}
inline ::GameState::IntegerRef* EntityValue::unsafe_arena_release_integer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:GameState.EntityValue.Integer)
  if (_internal_has_integer()) {
    clear_has_entity_val();
    ::GameState::IntegerRef* temp = entity_val_.integer_;
    entity_val_.integer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EntityValue::unsafe_arena_set_allocated_integer(::GameState::IntegerRef* integer) {
  clear_entity_val();
  if (integer) {
    set_has_integer();
    entity_val_.integer_ = integer;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.EntityValue.Integer)
}
inline ::GameState::IntegerRef* EntityValue::_internal_mutable_integer() {
  if (!_internal_has_integer()) {
    clear_entity_val();
    set_has_integer();
    entity_val_.integer_ = CreateMaybeMessage< ::GameState::IntegerRef >(GetArena());
  }
  return entity_val_.integer_;
}
inline ::GameState::IntegerRef* EntityValue::mutable_integer() {
  // @@protoc_insertion_point(field_mutable:GameState.EntityValue.Integer)
  return _internal_mutable_integer();
}

// int32 IntValue = 5;
inline bool EntityValue::_internal_has_intvalue() const {
  return entity_val_case() == kIntValue;
}
inline void EntityValue::set_has_intvalue() {
  _oneof_case_[0] = kIntValue;
}
inline void EntityValue::clear_intvalue() {
  if (_internal_has_intvalue()) {
    entity_val_.intvalue_ = 0;
    clear_has_entity_val();
  }
}
inline ::PROTOBUF_NAMESPACE_ID::int32 EntityValue::_internal_intvalue() const {
  if (_internal_has_intvalue()) {
    return entity_val_.intvalue_;
  }
  return 0;
}
inline void EntityValue::_internal_set_intvalue(::PROTOBUF_NAMESPACE_ID::int32 value) {
  if (!_internal_has_intvalue()) {
    clear_entity_val();
    set_has_intvalue();
  }
  entity_val_.intvalue_ = value;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 EntityValue::intvalue() const {
  // @@protoc_insertion_point(field_get:GameState.EntityValue.IntValue)
  return _internal_intvalue();
}
inline void EntityValue::set_intvalue(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_intvalue(value);
  // @@protoc_insertion_point(field_set:GameState.EntityValue.IntValue)
}

// .GameState.Vec2i Vec2iValue = 6;
inline bool EntityValue::_internal_has_vec2ivalue() const {
  return entity_val_case() == kVec2IValue;
}
inline bool EntityValue::has_vec2ivalue() const {
  return _internal_has_vec2ivalue();
}
inline void EntityValue::set_has_vec2ivalue() {
  _oneof_case_[0] = kVec2IValue;
}
inline void EntityValue::clear_vec2ivalue() {
  if (_internal_has_vec2ivalue()) {
    if (GetArena() == nullptr) {
      delete entity_val_.vec2ivalue_;
    }
    clear_has_entity_val();
  }
}
inline ::GameState::Vec2i* EntityValue::release_vec2ivalue() {
  // @@protoc_insertion_point(field_release:GameState.EntityValue.Vec2iValue)
  if (_internal_has_vec2ivalue()) {
    clear_has_entity_val();
      ::GameState::Vec2i* temp = entity_val_.vec2ivalue_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    entity_val_.vec2ivalue_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::GameState::Vec2i& EntityValue::_internal_vec2ivalue() const {
  return _internal_has_vec2ivalue()
      ? *entity_val_.vec2ivalue_
      : reinterpret_cast< ::GameState::Vec2i&>(::GameState::_Vec2i_default_instance_);
}
inline const ::GameState::Vec2i& EntityValue::vec2ivalue() const {
  // @@protoc_insertion_point(field_get:GameState.EntityValue.Vec2iValue)
  return _internal_vec2ivalue();
}
inline ::GameState::Vec2i* EntityValue::unsafe_arena_release_vec2ivalue() {
  // @@protoc_insertion_point(field_unsafe_arena_release:GameState.EntityValue.Vec2iValue)
  if (_internal_has_vec2ivalue()) {
    clear_has_entity_val();
    ::GameState::Vec2i* temp = entity_val_.vec2ivalue_;
    entity_val_.vec2ivalue_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EntityValue::unsafe_arena_set_allocated_vec2ivalue(::GameState::Vec2i* vec2ivalue) {
  clear_entity_val();
  if (vec2ivalue) {
    set_has_vec2ivalue();
    entity_val_.vec2ivalue_ = vec2ivalue;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.EntityValue.Vec2iValue)
}
inline ::GameState::Vec2i* EntityValue::_internal_mutable_vec2ivalue() {
  if (!_internal_has_vec2ivalue()) {
    clear_entity_val();
    set_has_vec2ivalue();
    entity_val_.vec2ivalue_ = CreateMaybeMessage< ::GameState::Vec2i >(GetArena());
  }
  return entity_val_.vec2ivalue_;
}
inline ::GameState::Vec2i* EntityValue::mutable_vec2ivalue() {
  // @@protoc_insertion_point(field_mutable:GameState.EntityValue.Vec2iValue)
  return _internal_mutable_vec2ivalue();
}

// .Types.TerrainType TerrainValue = 7;
inline bool EntityValue::_internal_has_terrainvalue() const {
  return entity_val_case() == kTerrainValue;
}
inline void EntityValue::set_has_terrainvalue() {
  _oneof_case_[0] = kTerrainValue;
}
inline void EntityValue::clear_terrainvalue() {
  if (_internal_has_terrainvalue()) {
    entity_val_.terrainvalue_ = 0;
    clear_has_entity_val();
  }
}
inline ::Types::TerrainType EntityValue::_internal_terrainvalue() const {
  if (_internal_has_terrainvalue()) {
    return static_cast< ::Types::TerrainType >(entity_val_.terrainvalue_);
  }
  return static_cast< ::Types::TerrainType >(0);
}
inline ::Types::TerrainType EntityValue::terrainvalue() const {
  // @@protoc_insertion_point(field_get:GameState.EntityValue.TerrainValue)
  return _internal_terrainvalue();
}
inline void EntityValue::_internal_set_terrainvalue(::Types::TerrainType value) {
  if (!_internal_has_terrainvalue()) {
    clear_entity_val();
    set_has_terrainvalue();
  }
  entity_val_.terrainvalue_ = value;
}
inline void EntityValue::set_terrainvalue(::Types::TerrainType value) {
  // @@protoc_insertion_point(field_set:GameState.EntityValue.TerrainValue)
  _internal_set_terrainvalue(value);
}

inline bool EntityValue::has_entity_val() const {
  return entity_val_case() != ENTITY_VAL_NOT_SET;
}
inline void EntityValue::clear_has_entity_val() {
  _oneof_case_[0] = ENTITY_VAL_NOT_SET;
}
inline EntityValue::EntityValCase EntityValue::entity_val_case() const {
  return EntityValue::EntityValCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Player_Stats

// .GameState.IntegerRef Health = 1;
inline bool Player_Stats::_internal_has_health() const {
  return this != internal_default_instance() && health_ != nullptr;
}
inline bool Player_Stats::has_health() const {
  return _internal_has_health();
}
inline void Player_Stats::clear_health() {
  if (GetArena() == nullptr && health_ != nullptr) {
    delete health_;
  }
  health_ = nullptr;
}
inline const ::GameState::IntegerRef& Player_Stats::_internal_health() const {
  const ::GameState::IntegerRef* p = health_;
  return p != nullptr ? *p : reinterpret_cast<const ::GameState::IntegerRef&>(
      ::GameState::_IntegerRef_default_instance_);
}
inline const ::GameState::IntegerRef& Player_Stats::health() const {
  // @@protoc_insertion_point(field_get:GameState.Player.Stats.Health)
  return _internal_health();
}
inline void Player_Stats::unsafe_arena_set_allocated_health(
    ::GameState::IntegerRef* health) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(health_);
  }
  health_ = health;
  if (health) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.Player.Stats.Health)
}
inline ::GameState::IntegerRef* Player_Stats::release_health() {
  
  ::GameState::IntegerRef* temp = health_;
  health_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::GameState::IntegerRef* Player_Stats::unsafe_arena_release_health() {
  // @@protoc_insertion_point(field_release:GameState.Player.Stats.Health)
  
  ::GameState::IntegerRef* temp = health_;
  health_ = nullptr;
  return temp;
}
inline ::GameState::IntegerRef* Player_Stats::_internal_mutable_health() {
  
  if (health_ == nullptr) {
    auto* p = CreateMaybeMessage<::GameState::IntegerRef>(GetArena());
    health_ = p;
  }
  return health_;
}
inline ::GameState::IntegerRef* Player_Stats::mutable_health() {
  // @@protoc_insertion_point(field_mutable:GameState.Player.Stats.Health)
  return _internal_mutable_health();
}
inline void Player_Stats::set_allocated_health(::GameState::IntegerRef* health) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete health_;
  }
  if (health) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(health);
    if (message_arena != submessage_arena) {
      health = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, health, submessage_arena);
    }
    
  } else {
    
  }
  health_ = health;
  // @@protoc_insertion_point(field_set_allocated:GameState.Player.Stats.Health)
}

// .GameState.IntegerRef Actions = 2;
inline bool Player_Stats::_internal_has_actions() const {
  return this != internal_default_instance() && actions_ != nullptr;
}
inline bool Player_Stats::has_actions() const {
  return _internal_has_actions();
}
inline void Player_Stats::clear_actions() {
  if (GetArena() == nullptr && actions_ != nullptr) {
    delete actions_;
  }
  actions_ = nullptr;
}
inline const ::GameState::IntegerRef& Player_Stats::_internal_actions() const {
  const ::GameState::IntegerRef* p = actions_;
  return p != nullptr ? *p : reinterpret_cast<const ::GameState::IntegerRef&>(
      ::GameState::_IntegerRef_default_instance_);
}
inline const ::GameState::IntegerRef& Player_Stats::actions() const {
  // @@protoc_insertion_point(field_get:GameState.Player.Stats.Actions)
  return _internal_actions();
}
inline void Player_Stats::unsafe_arena_set_allocated_actions(
    ::GameState::IntegerRef* actions) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(actions_);
  }
  actions_ = actions;
  if (actions) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.Player.Stats.Actions)
}
inline ::GameState::IntegerRef* Player_Stats::release_actions() {
  
  ::GameState::IntegerRef* temp = actions_;
  actions_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::GameState::IntegerRef* Player_Stats::unsafe_arena_release_actions() {
  // @@protoc_insertion_point(field_release:GameState.Player.Stats.Actions)
  
  ::GameState::IntegerRef* temp = actions_;
  actions_ = nullptr;
  return temp;
}
inline ::GameState::IntegerRef* Player_Stats::_internal_mutable_actions() {
  
  if (actions_ == nullptr) {
    auto* p = CreateMaybeMessage<::GameState::IntegerRef>(GetArena());
    actions_ = p;
  }
  return actions_;
}
inline ::GameState::IntegerRef* Player_Stats::mutable_actions() {
  // @@protoc_insertion_point(field_mutable:GameState.Player.Stats.Actions)
  return _internal_mutable_actions();
}
inline void Player_Stats::set_allocated_actions(::GameState::IntegerRef* actions) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete actions_;
  }
  if (actions) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(actions);
    if (message_arena != submessage_arena) {
      actions = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, actions, submessage_arena);
    }
    
  } else {
    
  }
  actions_ = actions;
  // @@protoc_insertion_point(field_set_allocated:GameState.Player.Stats.Actions)
}

// .GameState.IntegerRef Power = 3;
inline bool Player_Stats::_internal_has_power() const {
  return this != internal_default_instance() && power_ != nullptr;
}
inline bool Player_Stats::has_power() const {
  return _internal_has_power();
}
inline void Player_Stats::clear_power() {
  if (GetArena() == nullptr && power_ != nullptr) {
    delete power_;
  }
  power_ = nullptr;
}
inline const ::GameState::IntegerRef& Player_Stats::_internal_power() const {
  const ::GameState::IntegerRef* p = power_;
  return p != nullptr ? *p : reinterpret_cast<const ::GameState::IntegerRef&>(
      ::GameState::_IntegerRef_default_instance_);
}
inline const ::GameState::IntegerRef& Player_Stats::power() const {
  // @@protoc_insertion_point(field_get:GameState.Player.Stats.Power)
  return _internal_power();
}
inline void Player_Stats::unsafe_arena_set_allocated_power(
    ::GameState::IntegerRef* power) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(power_);
  }
  power_ = power;
  if (power) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.Player.Stats.Power)
}
inline ::GameState::IntegerRef* Player_Stats::release_power() {
  
  ::GameState::IntegerRef* temp = power_;
  power_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::GameState::IntegerRef* Player_Stats::unsafe_arena_release_power() {
  // @@protoc_insertion_point(field_release:GameState.Player.Stats.Power)
  
  ::GameState::IntegerRef* temp = power_;
  power_ = nullptr;
  return temp;
}
inline ::GameState::IntegerRef* Player_Stats::_internal_mutable_power() {
  
  if (power_ == nullptr) {
    auto* p = CreateMaybeMessage<::GameState::IntegerRef>(GetArena());
    power_ = p;
  }
  return power_;
}
inline ::GameState::IntegerRef* Player_Stats::mutable_power() {
  // @@protoc_insertion_point(field_mutable:GameState.Player.Stats.Power)
  return _internal_mutable_power();
}
inline void Player_Stats::set_allocated_power(::GameState::IntegerRef* power) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete power_;
  }
  if (power) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(power);
    if (message_arena != submessage_arena) {
      power = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, power, submessage_arena);
    }
    
  } else {
    
  }
  power_ = power;
  // @@protoc_insertion_point(field_set_allocated:GameState.Player.Stats.Power)
}

// .GameState.IntegerRef Slow = 4;
inline bool Player_Stats::_internal_has_slow() const {
  return this != internal_default_instance() && slow_ != nullptr;
}
inline bool Player_Stats::has_slow() const {
  return _internal_has_slow();
}
inline void Player_Stats::clear_slow() {
  if (GetArena() == nullptr && slow_ != nullptr) {
    delete slow_;
  }
  slow_ = nullptr;
}
inline const ::GameState::IntegerRef& Player_Stats::_internal_slow() const {
  const ::GameState::IntegerRef* p = slow_;
  return p != nullptr ? *p : reinterpret_cast<const ::GameState::IntegerRef&>(
      ::GameState::_IntegerRef_default_instance_);
}
inline const ::GameState::IntegerRef& Player_Stats::slow() const {
  // @@protoc_insertion_point(field_get:GameState.Player.Stats.Slow)
  return _internal_slow();
}
inline void Player_Stats::unsafe_arena_set_allocated_slow(
    ::GameState::IntegerRef* slow) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(slow_);
  }
  slow_ = slow;
  if (slow) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.Player.Stats.Slow)
}
inline ::GameState::IntegerRef* Player_Stats::release_slow() {
  
  ::GameState::IntegerRef* temp = slow_;
  slow_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::GameState::IntegerRef* Player_Stats::unsafe_arena_release_slow() {
  // @@protoc_insertion_point(field_release:GameState.Player.Stats.Slow)
  
  ::GameState::IntegerRef* temp = slow_;
  slow_ = nullptr;
  return temp;
}
inline ::GameState::IntegerRef* Player_Stats::_internal_mutable_slow() {
  
  if (slow_ == nullptr) {
    auto* p = CreateMaybeMessage<::GameState::IntegerRef>(GetArena());
    slow_ = p;
  }
  return slow_;
}
inline ::GameState::IntegerRef* Player_Stats::mutable_slow() {
  // @@protoc_insertion_point(field_mutable:GameState.Player.Stats.Slow)
  return _internal_mutable_slow();
}
inline void Player_Stats::set_allocated_slow(::GameState::IntegerRef* slow) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete slow_;
  }
  if (slow) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(slow);
    if (message_arena != submessage_arena) {
      slow = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, slow, submessage_arena);
    }
    
  } else {
    
  }
  slow_ = slow;
  // @@protoc_insertion_point(field_set_allocated:GameState.Player.Stats.Slow)
}

// .GameState.IntegerRef Silence = 5;
inline bool Player_Stats::_internal_has_silence() const {
  return this != internal_default_instance() && silence_ != nullptr;
}
inline bool Player_Stats::has_silence() const {
  return _internal_has_silence();
}
inline void Player_Stats::clear_silence() {
  if (GetArena() == nullptr && silence_ != nullptr) {
    delete silence_;
  }
  silence_ = nullptr;
}
inline const ::GameState::IntegerRef& Player_Stats::_internal_silence() const {
  const ::GameState::IntegerRef* p = silence_;
  return p != nullptr ? *p : reinterpret_cast<const ::GameState::IntegerRef&>(
      ::GameState::_IntegerRef_default_instance_);
}
inline const ::GameState::IntegerRef& Player_Stats::silence() const {
  // @@protoc_insertion_point(field_get:GameState.Player.Stats.Silence)
  return _internal_silence();
}
inline void Player_Stats::unsafe_arena_set_allocated_silence(
    ::GameState::IntegerRef* silence) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(silence_);
  }
  silence_ = silence;
  if (silence) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.Player.Stats.Silence)
}
inline ::GameState::IntegerRef* Player_Stats::release_silence() {
  
  ::GameState::IntegerRef* temp = silence_;
  silence_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::GameState::IntegerRef* Player_Stats::unsafe_arena_release_silence() {
  // @@protoc_insertion_point(field_release:GameState.Player.Stats.Silence)
  
  ::GameState::IntegerRef* temp = silence_;
  silence_ = nullptr;
  return temp;
}
inline ::GameState::IntegerRef* Player_Stats::_internal_mutable_silence() {
  
  if (silence_ == nullptr) {
    auto* p = CreateMaybeMessage<::GameState::IntegerRef>(GetArena());
    silence_ = p;
  }
  return silence_;
}
inline ::GameState::IntegerRef* Player_Stats::mutable_silence() {
  // @@protoc_insertion_point(field_mutable:GameState.Player.Stats.Silence)
  return _internal_mutable_silence();
}
inline void Player_Stats::set_allocated_silence(::GameState::IntegerRef* silence) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete silence_;
  }
  if (silence) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(silence);
    if (message_arena != submessage_arena) {
      silence = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, silence, submessage_arena);
    }
    
  } else {
    
  }
  silence_ = silence;
  // @@protoc_insertion_point(field_set_allocated:GameState.Player.Stats.Silence)
}

// .GameState.IntegerRef Disarm = 6;
inline bool Player_Stats::_internal_has_disarm() const {
  return this != internal_default_instance() && disarm_ != nullptr;
}
inline bool Player_Stats::has_disarm() const {
  return _internal_has_disarm();
}
inline void Player_Stats::clear_disarm() {
  if (GetArena() == nullptr && disarm_ != nullptr) {
    delete disarm_;
  }
  disarm_ = nullptr;
}
inline const ::GameState::IntegerRef& Player_Stats::_internal_disarm() const {
  const ::GameState::IntegerRef* p = disarm_;
  return p != nullptr ? *p : reinterpret_cast<const ::GameState::IntegerRef&>(
      ::GameState::_IntegerRef_default_instance_);
}
inline const ::GameState::IntegerRef& Player_Stats::disarm() const {
  // @@protoc_insertion_point(field_get:GameState.Player.Stats.Disarm)
  return _internal_disarm();
}
inline void Player_Stats::unsafe_arena_set_allocated_disarm(
    ::GameState::IntegerRef* disarm) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(disarm_);
  }
  disarm_ = disarm;
  if (disarm) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.Player.Stats.Disarm)
}
inline ::GameState::IntegerRef* Player_Stats::release_disarm() {
  
  ::GameState::IntegerRef* temp = disarm_;
  disarm_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::GameState::IntegerRef* Player_Stats::unsafe_arena_release_disarm() {
  // @@protoc_insertion_point(field_release:GameState.Player.Stats.Disarm)
  
  ::GameState::IntegerRef* temp = disarm_;
  disarm_ = nullptr;
  return temp;
}
inline ::GameState::IntegerRef* Player_Stats::_internal_mutable_disarm() {
  
  if (disarm_ == nullptr) {
    auto* p = CreateMaybeMessage<::GameState::IntegerRef>(GetArena());
    disarm_ = p;
  }
  return disarm_;
}
inline ::GameState::IntegerRef* Player_Stats::mutable_disarm() {
  // @@protoc_insertion_point(field_mutable:GameState.Player.Stats.Disarm)
  return _internal_mutable_disarm();
}
inline void Player_Stats::set_allocated_disarm(::GameState::IntegerRef* disarm) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete disarm_;
  }
  if (disarm) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(disarm);
    if (message_arena != submessage_arena) {
      disarm = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, disarm, submessage_arena);
    }
    
  } else {
    
  }
  disarm_ = disarm;
  // @@protoc_insertion_point(field_set_allocated:GameState.Player.Stats.Disarm)
}

// .GameState.IntegerRef Initiative = 7;
inline bool Player_Stats::_internal_has_initiative() const {
  return this != internal_default_instance() && initiative_ != nullptr;
}
inline bool Player_Stats::has_initiative() const {
  return _internal_has_initiative();
}
inline void Player_Stats::clear_initiative() {
  if (GetArena() == nullptr && initiative_ != nullptr) {
    delete initiative_;
  }
  initiative_ = nullptr;
}
inline const ::GameState::IntegerRef& Player_Stats::_internal_initiative() const {
  const ::GameState::IntegerRef* p = initiative_;
  return p != nullptr ? *p : reinterpret_cast<const ::GameState::IntegerRef&>(
      ::GameState::_IntegerRef_default_instance_);
}
inline const ::GameState::IntegerRef& Player_Stats::initiative() const {
  // @@protoc_insertion_point(field_get:GameState.Player.Stats.Initiative)
  return _internal_initiative();
}
inline void Player_Stats::unsafe_arena_set_allocated_initiative(
    ::GameState::IntegerRef* initiative) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(initiative_);
  }
  initiative_ = initiative;
  if (initiative) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.Player.Stats.Initiative)
}
inline ::GameState::IntegerRef* Player_Stats::release_initiative() {
  
  ::GameState::IntegerRef* temp = initiative_;
  initiative_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::GameState::IntegerRef* Player_Stats::unsafe_arena_release_initiative() {
  // @@protoc_insertion_point(field_release:GameState.Player.Stats.Initiative)
  
  ::GameState::IntegerRef* temp = initiative_;
  initiative_ = nullptr;
  return temp;
}
inline ::GameState::IntegerRef* Player_Stats::_internal_mutable_initiative() {
  
  if (initiative_ == nullptr) {
    auto* p = CreateMaybeMessage<::GameState::IntegerRef>(GetArena());
    initiative_ = p;
  }
  return initiative_;
}
inline ::GameState::IntegerRef* Player_Stats::mutable_initiative() {
  // @@protoc_insertion_point(field_mutable:GameState.Player.Stats.Initiative)
  return _internal_mutable_initiative();
}
inline void Player_Stats::set_allocated_initiative(::GameState::IntegerRef* initiative) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete initiative_;
  }
  if (initiative) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(initiative);
    if (message_arena != submessage_arena) {
      initiative = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, initiative, submessage_arena);
    }
    
  } else {
    
  }
  initiative_ = initiative;
  // @@protoc_insertion_point(field_set_allocated:GameState.Player.Stats.Initiative)
}

// -------------------------------------------------------------------

// Player

// string DisplayName = 1;
inline void Player::clear_displayname() {
  displayname_.ClearToEmpty();
}
inline const std::string& Player::displayname() const {
  // @@protoc_insertion_point(field_get:GameState.Player.DisplayName)
  return _internal_displayname();
}
inline void Player::set_displayname(const std::string& value) {
  _internal_set_displayname(value);
  // @@protoc_insertion_point(field_set:GameState.Player.DisplayName)
}
inline std::string* Player::mutable_displayname() {
  // @@protoc_insertion_point(field_mutable:GameState.Player.DisplayName)
  return _internal_mutable_displayname();
}
inline const std::string& Player::_internal_displayname() const {
  return displayname_.Get();
}
inline void Player::_internal_set_displayname(const std::string& value) {
  
  displayname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Player::set_displayname(std::string&& value) {
  
  displayname_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:GameState.Player.DisplayName)
}
inline void Player::set_displayname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  displayname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:GameState.Player.DisplayName)
}
inline void Player::set_displayname(const char* value,
    size_t size) {
  
  displayname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:GameState.Player.DisplayName)
}
inline std::string* Player::_internal_mutable_displayname() {
  
  return displayname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Player::release_displayname() {
  // @@protoc_insertion_point(field_release:GameState.Player.DisplayName)
  return displayname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Player::set_allocated_displayname(std::string* displayname) {
  if (displayname != nullptr) {
    
  } else {
    
  }
  displayname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), displayname,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:GameState.Player.DisplayName)
}

// string UID = 2;
inline void Player::clear_uid() {
  uid_.ClearToEmpty();
}
inline const std::string& Player::uid() const {
  // @@protoc_insertion_point(field_get:GameState.Player.UID)
  return _internal_uid();
}
inline void Player::set_uid(const std::string& value) {
  _internal_set_uid(value);
  // @@protoc_insertion_point(field_set:GameState.Player.UID)
}
inline std::string* Player::mutable_uid() {
  // @@protoc_insertion_point(field_mutable:GameState.Player.UID)
  return _internal_mutable_uid();
}
inline const std::string& Player::_internal_uid() const {
  return uid_.Get();
}
inline void Player::_internal_set_uid(const std::string& value) {
  
  uid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Player::set_uid(std::string&& value) {
  
  uid_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:GameState.Player.UID)
}
inline void Player::set_uid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  uid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:GameState.Player.UID)
}
inline void Player::set_uid(const char* value,
    size_t size) {
  
  uid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:GameState.Player.UID)
}
inline std::string* Player::_internal_mutable_uid() {
  
  return uid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Player::release_uid() {
  // @@protoc_insertion_point(field_release:GameState.Player.UID)
  return uid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Player::set_allocated_uid(std::string* uid) {
  if (uid != nullptr) {
    
  } else {
    
  }
  uid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:GameState.Player.UID)
}

// repeated .GameState.CardRef Field = 3;
inline int Player::_internal_field_size() const {
  return field_.size();
}
inline int Player::field_size() const {
  return _internal_field_size();
}
inline void Player::clear_field() {
  field_.Clear();
}
inline ::GameState::CardRef* Player::mutable_field(int index) {
  // @@protoc_insertion_point(field_mutable:GameState.Player.Field)
  return field_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::CardRef >*
Player::mutable_field() {
  // @@protoc_insertion_point(field_mutable_list:GameState.Player.Field)
  return &field_;
}
inline const ::GameState::CardRef& Player::_internal_field(int index) const {
  return field_.Get(index);
}
inline const ::GameState::CardRef& Player::field(int index) const {
  // @@protoc_insertion_point(field_get:GameState.Player.Field)
  return _internal_field(index);
}
inline ::GameState::CardRef* Player::_internal_add_field() {
  return field_.Add();
}
inline ::GameState::CardRef* Player::add_field() {
  // @@protoc_insertion_point(field_add:GameState.Player.Field)
  return _internal_add_field();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::CardRef >&
Player::field() const {
  // @@protoc_insertion_point(field_list:GameState.Player.Field)
  return field_;
}

// repeated .GameState.CardRef Hand = 4;
inline int Player::_internal_hand_size() const {
  return hand_.size();
}
inline int Player::hand_size() const {
  return _internal_hand_size();
}
inline void Player::clear_hand() {
  hand_.Clear();
}
inline ::GameState::CardRef* Player::mutable_hand(int index) {
  // @@protoc_insertion_point(field_mutable:GameState.Player.Hand)
  return hand_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::CardRef >*
Player::mutable_hand() {
  // @@protoc_insertion_point(field_mutable_list:GameState.Player.Hand)
  return &hand_;
}
inline const ::GameState::CardRef& Player::_internal_hand(int index) const {
  return hand_.Get(index);
}
inline const ::GameState::CardRef& Player::hand(int index) const {
  // @@protoc_insertion_point(field_get:GameState.Player.Hand)
  return _internal_hand(index);
}
inline ::GameState::CardRef* Player::_internal_add_hand() {
  return hand_.Add();
}
inline ::GameState::CardRef* Player::add_hand() {
  // @@protoc_insertion_point(field_add:GameState.Player.Hand)
  return _internal_add_hand();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::CardRef >&
Player::hand() const {
  // @@protoc_insertion_point(field_list:GameState.Player.Hand)
  return hand_;
}

// repeated .GameState.CardRef Deck = 5;
inline int Player::_internal_deck_size() const {
  return deck_.size();
}
inline int Player::deck_size() const {
  return _internal_deck_size();
}
inline void Player::clear_deck() {
  deck_.Clear();
}
inline ::GameState::CardRef* Player::mutable_deck(int index) {
  // @@protoc_insertion_point(field_mutable:GameState.Player.Deck)
  return deck_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::CardRef >*
Player::mutable_deck() {
  // @@protoc_insertion_point(field_mutable_list:GameState.Player.Deck)
  return &deck_;
}
inline const ::GameState::CardRef& Player::_internal_deck(int index) const {
  return deck_.Get(index);
}
inline const ::GameState::CardRef& Player::deck(int index) const {
  // @@protoc_insertion_point(field_get:GameState.Player.Deck)
  return _internal_deck(index);
}
inline ::GameState::CardRef* Player::_internal_add_deck() {
  return deck_.Add();
}
inline ::GameState::CardRef* Player::add_deck() {
  // @@protoc_insertion_point(field_add:GameState.Player.Deck)
  return _internal_add_deck();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::CardRef >&
Player::deck() const {
  // @@protoc_insertion_point(field_list:GameState.Player.Deck)
  return deck_;
}

// repeated .GameState.CardRef Discard = 6;
inline int Player::_internal_discard_size() const {
  return discard_.size();
}
inline int Player::discard_size() const {
  return _internal_discard_size();
}
inline void Player::clear_discard() {
  discard_.Clear();
}
inline ::GameState::CardRef* Player::mutable_discard(int index) {
  // @@protoc_insertion_point(field_mutable:GameState.Player.Discard)
  return discard_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::CardRef >*
Player::mutable_discard() {
  // @@protoc_insertion_point(field_mutable_list:GameState.Player.Discard)
  return &discard_;
}
inline const ::GameState::CardRef& Player::_internal_discard(int index) const {
  return discard_.Get(index);
}
inline const ::GameState::CardRef& Player::discard(int index) const {
  // @@protoc_insertion_point(field_get:GameState.Player.Discard)
  return _internal_discard(index);
}
inline ::GameState::CardRef* Player::_internal_add_discard() {
  return discard_.Add();
}
inline ::GameState::CardRef* Player::add_discard() {
  // @@protoc_insertion_point(field_add:GameState.Player.Discard)
  return _internal_add_discard();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::CardRef >&
Player::discard() const {
  // @@protoc_insertion_point(field_list:GameState.Player.Discard)
  return discard_;
}

// repeated .GameState.CardRef Feats = 7;
inline int Player::_internal_feats_size() const {
  return feats_.size();
}
inline int Player::feats_size() const {
  return _internal_feats_size();
}
inline void Player::clear_feats() {
  feats_.Clear();
}
inline ::GameState::CardRef* Player::mutable_feats(int index) {
  // @@protoc_insertion_point(field_mutable:GameState.Player.Feats)
  return feats_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::CardRef >*
Player::mutable_feats() {
  // @@protoc_insertion_point(field_mutable_list:GameState.Player.Feats)
  return &feats_;
}
inline const ::GameState::CardRef& Player::_internal_feats(int index) const {
  return feats_.Get(index);
}
inline const ::GameState::CardRef& Player::feats(int index) const {
  // @@protoc_insertion_point(field_get:GameState.Player.Feats)
  return _internal_feats(index);
}
inline ::GameState::CardRef* Player::_internal_add_feats() {
  return feats_.Add();
}
inline ::GameState::CardRef* Player::add_feats() {
  // @@protoc_insertion_point(field_add:GameState.Player.Feats)
  return _internal_add_feats();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::CardRef >&
Player::feats() const {
  // @@protoc_insertion_point(field_list:GameState.Player.Feats)
  return feats_;
}

// .GameState.Player.Stats State = 8;
inline bool Player::_internal_has_state() const {
  return this != internal_default_instance() && state_ != nullptr;
}
inline bool Player::has_state() const {
  return _internal_has_state();
}
inline void Player::clear_state() {
  if (GetArena() == nullptr && state_ != nullptr) {
    delete state_;
  }
  state_ = nullptr;
}
inline const ::GameState::Player_Stats& Player::_internal_state() const {
  const ::GameState::Player_Stats* p = state_;
  return p != nullptr ? *p : reinterpret_cast<const ::GameState::Player_Stats&>(
      ::GameState::_Player_Stats_default_instance_);
}
inline const ::GameState::Player_Stats& Player::state() const {
  // @@protoc_insertion_point(field_get:GameState.Player.State)
  return _internal_state();
}
inline void Player::unsafe_arena_set_allocated_state(
    ::GameState::Player_Stats* state) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(state_);
  }
  state_ = state;
  if (state) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.Player.State)
}
inline ::GameState::Player_Stats* Player::release_state() {
  
  ::GameState::Player_Stats* temp = state_;
  state_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::GameState::Player_Stats* Player::unsafe_arena_release_state() {
  // @@protoc_insertion_point(field_release:GameState.Player.State)
  
  ::GameState::Player_Stats* temp = state_;
  state_ = nullptr;
  return temp;
}
inline ::GameState::Player_Stats* Player::_internal_mutable_state() {
  
  if (state_ == nullptr) {
    auto* p = CreateMaybeMessage<::GameState::Player_Stats>(GetArena());
    state_ = p;
  }
  return state_;
}
inline ::GameState::Player_Stats* Player::mutable_state() {
  // @@protoc_insertion_point(field_mutable:GameState.Player.State)
  return _internal_mutable_state();
}
inline void Player::set_allocated_state(::GameState::Player_Stats* state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete state_;
  }
  if (state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(state);
    if (message_arena != submessage_arena) {
      state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    
  } else {
    
  }
  state_ = state;
  // @@protoc_insertion_point(field_set_allocated:GameState.Player.State)
}

// .GameState.Player.Stats MaxState = 9;
inline bool Player::_internal_has_maxstate() const {
  return this != internal_default_instance() && maxstate_ != nullptr;
}
inline bool Player::has_maxstate() const {
  return _internal_has_maxstate();
}
inline void Player::clear_maxstate() {
  if (GetArena() == nullptr && maxstate_ != nullptr) {
    delete maxstate_;
  }
  maxstate_ = nullptr;
}
inline const ::GameState::Player_Stats& Player::_internal_maxstate() const {
  const ::GameState::Player_Stats* p = maxstate_;
  return p != nullptr ? *p : reinterpret_cast<const ::GameState::Player_Stats&>(
      ::GameState::_Player_Stats_default_instance_);
}
inline const ::GameState::Player_Stats& Player::maxstate() const {
  // @@protoc_insertion_point(field_get:GameState.Player.MaxState)
  return _internal_maxstate();
}
inline void Player::unsafe_arena_set_allocated_maxstate(
    ::GameState::Player_Stats* maxstate) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(maxstate_);
  }
  maxstate_ = maxstate;
  if (maxstate) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.Player.MaxState)
}
inline ::GameState::Player_Stats* Player::release_maxstate() {
  
  ::GameState::Player_Stats* temp = maxstate_;
  maxstate_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::GameState::Player_Stats* Player::unsafe_arena_release_maxstate() {
  // @@protoc_insertion_point(field_release:GameState.Player.MaxState)
  
  ::GameState::Player_Stats* temp = maxstate_;
  maxstate_ = nullptr;
  return temp;
}
inline ::GameState::Player_Stats* Player::_internal_mutable_maxstate() {
  
  if (maxstate_ == nullptr) {
    auto* p = CreateMaybeMessage<::GameState::Player_Stats>(GetArena());
    maxstate_ = p;
  }
  return maxstate_;
}
inline ::GameState::Player_Stats* Player::mutable_maxstate() {
  // @@protoc_insertion_point(field_mutable:GameState.Player.MaxState)
  return _internal_mutable_maxstate();
}
inline void Player::set_allocated_maxstate(::GameState::Player_Stats* maxstate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete maxstate_;
  }
  if (maxstate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(maxstate);
    if (message_arena != submessage_arena) {
      maxstate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, maxstate, submessage_arena);
    }
    
  } else {
    
  }
  maxstate_ = maxstate;
  // @@protoc_insertion_point(field_set_allocated:GameState.Player.MaxState)
}

// .GameState.Vec2iRef Position = 10;
inline bool Player::_internal_has_position() const {
  return this != internal_default_instance() && position_ != nullptr;
}
inline bool Player::has_position() const {
  return _internal_has_position();
}
inline void Player::clear_position() {
  if (GetArena() == nullptr && position_ != nullptr) {
    delete position_;
  }
  position_ = nullptr;
}
inline const ::GameState::Vec2iRef& Player::_internal_position() const {
  const ::GameState::Vec2iRef* p = position_;
  return p != nullptr ? *p : reinterpret_cast<const ::GameState::Vec2iRef&>(
      ::GameState::_Vec2iRef_default_instance_);
}
inline const ::GameState::Vec2iRef& Player::position() const {
  // @@protoc_insertion_point(field_get:GameState.Player.Position)
  return _internal_position();
}
inline void Player::unsafe_arena_set_allocated_position(
    ::GameState::Vec2iRef* position) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.Player.Position)
}
inline ::GameState::Vec2iRef* Player::release_position() {
  
  ::GameState::Vec2iRef* temp = position_;
  position_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::GameState::Vec2iRef* Player::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:GameState.Player.Position)
  
  ::GameState::Vec2iRef* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::GameState::Vec2iRef* Player::_internal_mutable_position() {
  
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::GameState::Vec2iRef>(GetArena());
    position_ = p;
  }
  return position_;
}
inline ::GameState::Vec2iRef* Player::mutable_position() {
  // @@protoc_insertion_point(field_mutable:GameState.Player.Position)
  return _internal_mutable_position();
}
inline void Player::set_allocated_position(::GameState::Vec2iRef* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:GameState.Player.Position)
}

// -------------------------------------------------------------------

// Tile

// .GameState.Vec2i Position = 1;
inline bool Tile::_internal_has_position() const {
  return this != internal_default_instance() && position_ != nullptr;
}
inline bool Tile::has_position() const {
  return _internal_has_position();
}
inline void Tile::clear_position() {
  if (GetArena() == nullptr && position_ != nullptr) {
    delete position_;
  }
  position_ = nullptr;
}
inline const ::GameState::Vec2i& Tile::_internal_position() const {
  const ::GameState::Vec2i* p = position_;
  return p != nullptr ? *p : reinterpret_cast<const ::GameState::Vec2i&>(
      ::GameState::_Vec2i_default_instance_);
}
inline const ::GameState::Vec2i& Tile::position() const {
  // @@protoc_insertion_point(field_get:GameState.Tile.Position)
  return _internal_position();
}
inline void Tile::unsafe_arena_set_allocated_position(
    ::GameState::Vec2i* position) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.Tile.Position)
}
inline ::GameState::Vec2i* Tile::release_position() {
  
  ::GameState::Vec2i* temp = position_;
  position_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::GameState::Vec2i* Tile::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:GameState.Tile.Position)
  
  ::GameState::Vec2i* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::GameState::Vec2i* Tile::_internal_mutable_position() {
  
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::GameState::Vec2i>(GetArena());
    position_ = p;
  }
  return position_;
}
inline ::GameState::Vec2i* Tile::mutable_position() {
  // @@protoc_insertion_point(field_mutable:GameState.Tile.Position)
  return _internal_mutable_position();
}
inline void Tile::set_allocated_position(::GameState::Vec2i* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:GameState.Tile.Position)
}

// .Types.TerrainType Terrain = 2;
inline void Tile::clear_terrain() {
  terrain_ = 0;
}
inline ::Types::TerrainType Tile::_internal_terrain() const {
  return static_cast< ::Types::TerrainType >(terrain_);
}
inline ::Types::TerrainType Tile::terrain() const {
  // @@protoc_insertion_point(field_get:GameState.Tile.Terrain)
  return _internal_terrain();
}
inline void Tile::_internal_set_terrain(::Types::TerrainType value) {
  
  terrain_ = value;
}
inline void Tile::set_terrain(::Types::TerrainType value) {
  _internal_set_terrain(value);
  // @@protoc_insertion_point(field_set:GameState.Tile.Terrain)
}

// repeated .GameState.PlayerRef Players = 3;
inline int Tile::_internal_players_size() const {
  return players_.size();
}
inline int Tile::players_size() const {
  return _internal_players_size();
}
inline void Tile::clear_players() {
  players_.Clear();
}
inline ::GameState::PlayerRef* Tile::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:GameState.Tile.Players)
  return players_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::PlayerRef >*
Tile::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:GameState.Tile.Players)
  return &players_;
}
inline const ::GameState::PlayerRef& Tile::_internal_players(int index) const {
  return players_.Get(index);
}
inline const ::GameState::PlayerRef& Tile::players(int index) const {
  // @@protoc_insertion_point(field_get:GameState.Tile.Players)
  return _internal_players(index);
}
inline ::GameState::PlayerRef* Tile::_internal_add_players() {
  return players_.Add();
}
inline ::GameState::PlayerRef* Tile::add_players() {
  // @@protoc_insertion_point(field_add:GameState.Tile.Players)
  return _internal_add_players();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::PlayerRef >&
Tile::players() const {
  // @@protoc_insertion_point(field_list:GameState.Tile.Players)
  return players_;
}

// repeated .GameState.CardRef Cards = 4;
inline int Tile::_internal_cards_size() const {
  return cards_.size();
}
inline int Tile::cards_size() const {
  return _internal_cards_size();
}
inline void Tile::clear_cards() {
  cards_.Clear();
}
inline ::GameState::CardRef* Tile::mutable_cards(int index) {
  // @@protoc_insertion_point(field_mutable:GameState.Tile.Cards)
  return cards_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::CardRef >*
Tile::mutable_cards() {
  // @@protoc_insertion_point(field_mutable_list:GameState.Tile.Cards)
  return &cards_;
}
inline const ::GameState::CardRef& Tile::_internal_cards(int index) const {
  return cards_.Get(index);
}
inline const ::GameState::CardRef& Tile::cards(int index) const {
  // @@protoc_insertion_point(field_get:GameState.Tile.Cards)
  return _internal_cards(index);
}
inline ::GameState::CardRef* Tile::_internal_add_cards() {
  return cards_.Add();
}
inline ::GameState::CardRef* Tile::add_cards() {
  // @@protoc_insertion_point(field_add:GameState.Tile.Cards)
  return _internal_add_cards();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::CardRef >&
Tile::cards() const {
  // @@protoc_insertion_point(field_list:GameState.Tile.Cards)
  return cards_;
}

// -------------------------------------------------------------------

// Card

// string Name = 1;
inline void Card::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Card::name() const {
  // @@protoc_insertion_point(field_get:GameState.Card.Name)
  return _internal_name();
}
inline void Card::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:GameState.Card.Name)
}
inline std::string* Card::mutable_name() {
  // @@protoc_insertion_point(field_mutable:GameState.Card.Name)
  return _internal_mutable_name();
}
inline const std::string& Card::_internal_name() const {
  return name_.Get();
}
inline void Card::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Card::set_name(std::string&& value) {
  
  name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:GameState.Card.Name)
}
inline void Card::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:GameState.Card.Name)
}
inline void Card::set_name(const char* value,
    size_t size) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:GameState.Card.Name)
}
inline std::string* Card::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Card::release_name() {
  // @@protoc_insertion_point(field_release:GameState.Card.Name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Card::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:GameState.Card.Name)
}

// string Archetype = 2;
inline void Card::clear_archetype() {
  archetype_.ClearToEmpty();
}
inline const std::string& Card::archetype() const {
  // @@protoc_insertion_point(field_get:GameState.Card.Archetype)
  return _internal_archetype();
}
inline void Card::set_archetype(const std::string& value) {
  _internal_set_archetype(value);
  // @@protoc_insertion_point(field_set:GameState.Card.Archetype)
}
inline std::string* Card::mutable_archetype() {
  // @@protoc_insertion_point(field_mutable:GameState.Card.Archetype)
  return _internal_mutable_archetype();
}
inline const std::string& Card::_internal_archetype() const {
  return archetype_.Get();
}
inline void Card::_internal_set_archetype(const std::string& value) {
  
  archetype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Card::set_archetype(std::string&& value) {
  
  archetype_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:GameState.Card.Archetype)
}
inline void Card::set_archetype(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  archetype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:GameState.Card.Archetype)
}
inline void Card::set_archetype(const char* value,
    size_t size) {
  
  archetype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:GameState.Card.Archetype)
}
inline std::string* Card::_internal_mutable_archetype() {
  
  return archetype_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Card::release_archetype() {
  // @@protoc_insertion_point(field_release:GameState.Card.Archetype)
  return archetype_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Card::set_allocated_archetype(std::string* archetype) {
  if (archetype != nullptr) {
    
  } else {
    
  }
  archetype_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), archetype,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:GameState.Card.Archetype)
}

// bool Ultimate = 3;
inline void Card::clear_ultimate() {
  ultimate_ = false;
}
inline bool Card::_internal_ultimate() const {
  return ultimate_;
}
inline bool Card::ultimate() const {
  // @@protoc_insertion_point(field_get:GameState.Card.Ultimate)
  return _internal_ultimate();
}
inline void Card::_internal_set_ultimate(bool value) {
  
  ultimate_ = value;
}
inline void Card::set_ultimate(bool value) {
  _internal_set_ultimate(value);
  // @@protoc_insertion_point(field_set:GameState.Card.Ultimate)
}

// bool Feat = 4;
inline void Card::clear_feat() {
  feat_ = false;
}
inline bool Card::_internal_feat() const {
  return feat_;
}
inline bool Card::feat() const {
  // @@protoc_insertion_point(field_get:GameState.Card.Feat)
  return _internal_feat();
}
inline void Card::_internal_set_feat(bool value) {
  
  feat_ = value;
}
inline void Card::set_feat(bool value) {
  _internal_set_feat(value);
  // @@protoc_insertion_point(field_set:GameState.Card.Feat)
}

// bool BasicAction = 5;
inline void Card::clear_basicaction() {
  basicaction_ = false;
}
inline bool Card::_internal_basicaction() const {
  return basicaction_;
}
inline bool Card::basicaction() const {
  // @@protoc_insertion_point(field_get:GameState.Card.BasicAction)
  return _internal_basicaction();
}
inline void Card::_internal_set_basicaction(bool value) {
  
  basicaction_ = value;
}
inline void Card::set_basicaction(bool value) {
  _internal_set_basicaction(value);
  // @@protoc_insertion_point(field_set:GameState.Card.BasicAction)
}

// repeated .GameState.Card.Color Colors = 6;
inline int Card::_internal_colors_size() const {
  return colors_.size();
}
inline int Card::colors_size() const {
  return _internal_colors_size();
}
inline void Card::clear_colors() {
  colors_.Clear();
}
inline ::GameState::Card_Color Card::_internal_colors(int index) const {
  return static_cast< ::GameState::Card_Color >(colors_.Get(index));
}
inline ::GameState::Card_Color Card::colors(int index) const {
  // @@protoc_insertion_point(field_get:GameState.Card.Colors)
  return _internal_colors(index);
}
inline void Card::set_colors(int index, ::GameState::Card_Color value) {
  colors_.Set(index, value);
  // @@protoc_insertion_point(field_set:GameState.Card.Colors)
}
inline void Card::_internal_add_colors(::GameState::Card_Color value) {
  colors_.Add(value);
}
inline void Card::add_colors(::GameState::Card_Color value) {
  // @@protoc_insertion_point(field_add:GameState.Card.Colors)
  _internal_add_colors(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
Card::colors() const {
  // @@protoc_insertion_point(field_list:GameState.Card.Colors)
  return colors_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
Card::_internal_mutable_colors() {
  return &colors_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
Card::mutable_colors() {
  // @@protoc_insertion_point(field_mutable_list:GameState.Card.Colors)
  return _internal_mutable_colors();
}

// .GameState.PlayerRef Owner = 7;
inline bool Card::_internal_has_owner() const {
  return this != internal_default_instance() && owner_ != nullptr;
}
inline bool Card::has_owner() const {
  return _internal_has_owner();
}
inline void Card::clear_owner() {
  if (GetArena() == nullptr && owner_ != nullptr) {
    delete owner_;
  }
  owner_ = nullptr;
}
inline const ::GameState::PlayerRef& Card::_internal_owner() const {
  const ::GameState::PlayerRef* p = owner_;
  return p != nullptr ? *p : reinterpret_cast<const ::GameState::PlayerRef&>(
      ::GameState::_PlayerRef_default_instance_);
}
inline const ::GameState::PlayerRef& Card::owner() const {
  // @@protoc_insertion_point(field_get:GameState.Card.Owner)
  return _internal_owner();
}
inline void Card::unsafe_arena_set_allocated_owner(
    ::GameState::PlayerRef* owner) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(owner_);
  }
  owner_ = owner;
  if (owner) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.Card.Owner)
}
inline ::GameState::PlayerRef* Card::release_owner() {
  
  ::GameState::PlayerRef* temp = owner_;
  owner_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::GameState::PlayerRef* Card::unsafe_arena_release_owner() {
  // @@protoc_insertion_point(field_release:GameState.Card.Owner)
  
  ::GameState::PlayerRef* temp = owner_;
  owner_ = nullptr;
  return temp;
}
inline ::GameState::PlayerRef* Card::_internal_mutable_owner() {
  
  if (owner_ == nullptr) {
    auto* p = CreateMaybeMessage<::GameState::PlayerRef>(GetArena());
    owner_ = p;
  }
  return owner_;
}
inline ::GameState::PlayerRef* Card::mutable_owner() {
  // @@protoc_insertion_point(field_mutable:GameState.Card.Owner)
  return _internal_mutable_owner();
}
inline void Card::set_allocated_owner(::GameState::PlayerRef* owner) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete owner_;
  }
  if (owner) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(owner);
    if (message_arena != submessage_arena) {
      owner = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, owner, submessage_arena);
    }
    
  } else {
    
  }
  owner_ = owner;
  // @@protoc_insertion_point(field_set_allocated:GameState.Card.Owner)
}

// .GameState.PlayerRef Controller = 8;
inline bool Card::_internal_has_controller() const {
  return this != internal_default_instance() && controller_ != nullptr;
}
inline bool Card::has_controller() const {
  return _internal_has_controller();
}
inline void Card::clear_controller() {
  if (GetArena() == nullptr && controller_ != nullptr) {
    delete controller_;
  }
  controller_ = nullptr;
}
inline const ::GameState::PlayerRef& Card::_internal_controller() const {
  const ::GameState::PlayerRef* p = controller_;
  return p != nullptr ? *p : reinterpret_cast<const ::GameState::PlayerRef&>(
      ::GameState::_PlayerRef_default_instance_);
}
inline const ::GameState::PlayerRef& Card::controller() const {
  // @@protoc_insertion_point(field_get:GameState.Card.Controller)
  return _internal_controller();
}
inline void Card::unsafe_arena_set_allocated_controller(
    ::GameState::PlayerRef* controller) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(controller_);
  }
  controller_ = controller;
  if (controller) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.Card.Controller)
}
inline ::GameState::PlayerRef* Card::release_controller() {
  
  ::GameState::PlayerRef* temp = controller_;
  controller_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::GameState::PlayerRef* Card::unsafe_arena_release_controller() {
  // @@protoc_insertion_point(field_release:GameState.Card.Controller)
  
  ::GameState::PlayerRef* temp = controller_;
  controller_ = nullptr;
  return temp;
}
inline ::GameState::PlayerRef* Card::_internal_mutable_controller() {
  
  if (controller_ == nullptr) {
    auto* p = CreateMaybeMessage<::GameState::PlayerRef>(GetArena());
    controller_ = p;
  }
  return controller_;
}
inline ::GameState::PlayerRef* Card::mutable_controller() {
  // @@protoc_insertion_point(field_mutable:GameState.Card.Controller)
  return _internal_mutable_controller();
}
inline void Card::set_allocated_controller(::GameState::PlayerRef* controller) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete controller_;
  }
  if (controller) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(controller);
    if (message_arena != submessage_arena) {
      controller = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, controller, submessage_arena);
    }
    
  } else {
    
  }
  controller_ = controller;
  // @@protoc_insertion_point(field_set_allocated:GameState.Card.Controller)
}

// .GameState.IntegerRef ActionCost = 9;
inline bool Card::_internal_has_actioncost() const {
  return this != internal_default_instance() && actioncost_ != nullptr;
}
inline bool Card::has_actioncost() const {
  return _internal_has_actioncost();
}
inline void Card::clear_actioncost() {
  if (GetArena() == nullptr && actioncost_ != nullptr) {
    delete actioncost_;
  }
  actioncost_ = nullptr;
}
inline const ::GameState::IntegerRef& Card::_internal_actioncost() const {
  const ::GameState::IntegerRef* p = actioncost_;
  return p != nullptr ? *p : reinterpret_cast<const ::GameState::IntegerRef&>(
      ::GameState::_IntegerRef_default_instance_);
}
inline const ::GameState::IntegerRef& Card::actioncost() const {
  // @@protoc_insertion_point(field_get:GameState.Card.ActionCost)
  return _internal_actioncost();
}
inline void Card::unsafe_arena_set_allocated_actioncost(
    ::GameState::IntegerRef* actioncost) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(actioncost_);
  }
  actioncost_ = actioncost;
  if (actioncost) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.Card.ActionCost)
}
inline ::GameState::IntegerRef* Card::release_actioncost() {
  
  ::GameState::IntegerRef* temp = actioncost_;
  actioncost_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::GameState::IntegerRef* Card::unsafe_arena_release_actioncost() {
  // @@protoc_insertion_point(field_release:GameState.Card.ActionCost)
  
  ::GameState::IntegerRef* temp = actioncost_;
  actioncost_ = nullptr;
  return temp;
}
inline ::GameState::IntegerRef* Card::_internal_mutable_actioncost() {
  
  if (actioncost_ == nullptr) {
    auto* p = CreateMaybeMessage<::GameState::IntegerRef>(GetArena());
    actioncost_ = p;
  }
  return actioncost_;
}
inline ::GameState::IntegerRef* Card::mutable_actioncost() {
  // @@protoc_insertion_point(field_mutable:GameState.Card.ActionCost)
  return _internal_mutable_actioncost();
}
inline void Card::set_allocated_actioncost(::GameState::IntegerRef* actioncost) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete actioncost_;
  }
  if (actioncost) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(actioncost);
    if (message_arena != submessage_arena) {
      actioncost = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, actioncost, submessage_arena);
    }
    
  } else {
    
  }
  actioncost_ = actioncost;
  // @@protoc_insertion_point(field_set_allocated:GameState.Card.ActionCost)
}

// .GameState.IntegerRef PowerCost = 10;
inline bool Card::_internal_has_powercost() const {
  return this != internal_default_instance() && powercost_ != nullptr;
}
inline bool Card::has_powercost() const {
  return _internal_has_powercost();
}
inline void Card::clear_powercost() {
  if (GetArena() == nullptr && powercost_ != nullptr) {
    delete powercost_;
  }
  powercost_ = nullptr;
}
inline const ::GameState::IntegerRef& Card::_internal_powercost() const {
  const ::GameState::IntegerRef* p = powercost_;
  return p != nullptr ? *p : reinterpret_cast<const ::GameState::IntegerRef&>(
      ::GameState::_IntegerRef_default_instance_);
}
inline const ::GameState::IntegerRef& Card::powercost() const {
  // @@protoc_insertion_point(field_get:GameState.Card.PowerCost)
  return _internal_powercost();
}
inline void Card::unsafe_arena_set_allocated_powercost(
    ::GameState::IntegerRef* powercost) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(powercost_);
  }
  powercost_ = powercost;
  if (powercost) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.Card.PowerCost)
}
inline ::GameState::IntegerRef* Card::release_powercost() {
  
  ::GameState::IntegerRef* temp = powercost_;
  powercost_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::GameState::IntegerRef* Card::unsafe_arena_release_powercost() {
  // @@protoc_insertion_point(field_release:GameState.Card.PowerCost)
  
  ::GameState::IntegerRef* temp = powercost_;
  powercost_ = nullptr;
  return temp;
}
inline ::GameState::IntegerRef* Card::_internal_mutable_powercost() {
  
  if (powercost_ == nullptr) {
    auto* p = CreateMaybeMessage<::GameState::IntegerRef>(GetArena());
    powercost_ = p;
  }
  return powercost_;
}
inline ::GameState::IntegerRef* Card::mutable_powercost() {
  // @@protoc_insertion_point(field_mutable:GameState.Card.PowerCost)
  return _internal_mutable_powercost();
}
inline void Card::set_allocated_powercost(::GameState::IntegerRef* powercost) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete powercost_;
  }
  if (powercost) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(powercost);
    if (message_arena != submessage_arena) {
      powercost = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, powercost, submessage_arena);
    }
    
  } else {
    
  }
  powercost_ = powercost;
  // @@protoc_insertion_point(field_set_allocated:GameState.Card.PowerCost)
}

// .GameState.IntegerRef Range = 11;
inline bool Card::_internal_has_range() const {
  return this != internal_default_instance() && range_ != nullptr;
}
inline bool Card::has_range() const {
  return _internal_has_range();
}
inline void Card::clear_range() {
  if (GetArena() == nullptr && range_ != nullptr) {
    delete range_;
  }
  range_ = nullptr;
}
inline const ::GameState::IntegerRef& Card::_internal_range() const {
  const ::GameState::IntegerRef* p = range_;
  return p != nullptr ? *p : reinterpret_cast<const ::GameState::IntegerRef&>(
      ::GameState::_IntegerRef_default_instance_);
}
inline const ::GameState::IntegerRef& Card::range() const {
  // @@protoc_insertion_point(field_get:GameState.Card.Range)
  return _internal_range();
}
inline void Card::unsafe_arena_set_allocated_range(
    ::GameState::IntegerRef* range) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(range_);
  }
  range_ = range;
  if (range) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.Card.Range)
}
inline ::GameState::IntegerRef* Card::release_range() {
  
  ::GameState::IntegerRef* temp = range_;
  range_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::GameState::IntegerRef* Card::unsafe_arena_release_range() {
  // @@protoc_insertion_point(field_release:GameState.Card.Range)
  
  ::GameState::IntegerRef* temp = range_;
  range_ = nullptr;
  return temp;
}
inline ::GameState::IntegerRef* Card::_internal_mutable_range() {
  
  if (range_ == nullptr) {
    auto* p = CreateMaybeMessage<::GameState::IntegerRef>(GetArena());
    range_ = p;
  }
  return range_;
}
inline ::GameState::IntegerRef* Card::mutable_range() {
  // @@protoc_insertion_point(field_mutable:GameState.Card.Range)
  return _internal_mutable_range();
}
inline void Card::set_allocated_range(::GameState::IntegerRef* range) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete range_;
  }
  if (range) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(range);
    if (message_arena != submessage_arena) {
      range = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, range, submessage_arena);
    }
    
  } else {
    
  }
  range_ = range;
  // @@protoc_insertion_point(field_set_allocated:GameState.Card.Range)
}

// .GameState.EntityRef Attached = 12;
inline bool Card::_internal_has_attached() const {
  return this != internal_default_instance() && attached_ != nullptr;
}
inline bool Card::has_attached() const {
  return _internal_has_attached();
}
inline void Card::clear_attached() {
  if (GetArena() == nullptr && attached_ != nullptr) {
    delete attached_;
  }
  attached_ = nullptr;
}
inline const ::GameState::EntityRef& Card::_internal_attached() const {
  const ::GameState::EntityRef* p = attached_;
  return p != nullptr ? *p : reinterpret_cast<const ::GameState::EntityRef&>(
      ::GameState::_EntityRef_default_instance_);
}
inline const ::GameState::EntityRef& Card::attached() const {
  // @@protoc_insertion_point(field_get:GameState.Card.Attached)
  return _internal_attached();
}
inline void Card::unsafe_arena_set_allocated_attached(
    ::GameState::EntityRef* attached) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(attached_);
  }
  attached_ = attached;
  if (attached) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.Card.Attached)
}
inline ::GameState::EntityRef* Card::release_attached() {
  
  ::GameState::EntityRef* temp = attached_;
  attached_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::GameState::EntityRef* Card::unsafe_arena_release_attached() {
  // @@protoc_insertion_point(field_release:GameState.Card.Attached)
  
  ::GameState::EntityRef* temp = attached_;
  attached_ = nullptr;
  return temp;
}
inline ::GameState::EntityRef* Card::_internal_mutable_attached() {
  
  if (attached_ == nullptr) {
    auto* p = CreateMaybeMessage<::GameState::EntityRef>(GetArena());
    attached_ = p;
  }
  return attached_;
}
inline ::GameState::EntityRef* Card::mutable_attached() {
  // @@protoc_insertion_point(field_mutable:GameState.Card.Attached)
  return _internal_mutable_attached();
}
inline void Card::set_allocated_attached(::GameState::EntityRef* attached) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete attached_;
  }
  if (attached) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(attached);
    if (message_arena != submessage_arena) {
      attached = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, attached, submessage_arena);
    }
    
  } else {
    
  }
  attached_ = attached;
  // @@protoc_insertion_point(field_set_allocated:GameState.Card.Attached)
}

// .GameState.IntegerRef AffectedBySlow = 13;
inline bool Card::_internal_has_affectedbyslow() const {
  return this != internal_default_instance() && affectedbyslow_ != nullptr;
}
inline bool Card::has_affectedbyslow() const {
  return _internal_has_affectedbyslow();
}
inline void Card::clear_affectedbyslow() {
  if (GetArena() == nullptr && affectedbyslow_ != nullptr) {
    delete affectedbyslow_;
  }
  affectedbyslow_ = nullptr;
}
inline const ::GameState::IntegerRef& Card::_internal_affectedbyslow() const {
  const ::GameState::IntegerRef* p = affectedbyslow_;
  return p != nullptr ? *p : reinterpret_cast<const ::GameState::IntegerRef&>(
      ::GameState::_IntegerRef_default_instance_);
}
inline const ::GameState::IntegerRef& Card::affectedbyslow() const {
  // @@protoc_insertion_point(field_get:GameState.Card.AffectedBySlow)
  return _internal_affectedbyslow();
}
inline void Card::unsafe_arena_set_allocated_affectedbyslow(
    ::GameState::IntegerRef* affectedbyslow) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(affectedbyslow_);
  }
  affectedbyslow_ = affectedbyslow;
  if (affectedbyslow) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.Card.AffectedBySlow)
}
inline ::GameState::IntegerRef* Card::release_affectedbyslow() {
  
  ::GameState::IntegerRef* temp = affectedbyslow_;
  affectedbyslow_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::GameState::IntegerRef* Card::unsafe_arena_release_affectedbyslow() {
  // @@protoc_insertion_point(field_release:GameState.Card.AffectedBySlow)
  
  ::GameState::IntegerRef* temp = affectedbyslow_;
  affectedbyslow_ = nullptr;
  return temp;
}
inline ::GameState::IntegerRef* Card::_internal_mutable_affectedbyslow() {
  
  if (affectedbyslow_ == nullptr) {
    auto* p = CreateMaybeMessage<::GameState::IntegerRef>(GetArena());
    affectedbyslow_ = p;
  }
  return affectedbyslow_;
}
inline ::GameState::IntegerRef* Card::mutable_affectedbyslow() {
  // @@protoc_insertion_point(field_mutable:GameState.Card.AffectedBySlow)
  return _internal_mutable_affectedbyslow();
}
inline void Card::set_allocated_affectedbyslow(::GameState::IntegerRef* affectedbyslow) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete affectedbyslow_;
  }
  if (affectedbyslow) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(affectedbyslow);
    if (message_arena != submessage_arena) {
      affectedbyslow = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, affectedbyslow, submessage_arena);
    }
    
  } else {
    
  }
  affectedbyslow_ = affectedbyslow;
  // @@protoc_insertion_point(field_set_allocated:GameState.Card.AffectedBySlow)
}

// .GameState.IntegerRef AffectedBySilence = 14;
inline bool Card::_internal_has_affectedbysilence() const {
  return this != internal_default_instance() && affectedbysilence_ != nullptr;
}
inline bool Card::has_affectedbysilence() const {
  return _internal_has_affectedbysilence();
}
inline void Card::clear_affectedbysilence() {
  if (GetArena() == nullptr && affectedbysilence_ != nullptr) {
    delete affectedbysilence_;
  }
  affectedbysilence_ = nullptr;
}
inline const ::GameState::IntegerRef& Card::_internal_affectedbysilence() const {
  const ::GameState::IntegerRef* p = affectedbysilence_;
  return p != nullptr ? *p : reinterpret_cast<const ::GameState::IntegerRef&>(
      ::GameState::_IntegerRef_default_instance_);
}
inline const ::GameState::IntegerRef& Card::affectedbysilence() const {
  // @@protoc_insertion_point(field_get:GameState.Card.AffectedBySilence)
  return _internal_affectedbysilence();
}
inline void Card::unsafe_arena_set_allocated_affectedbysilence(
    ::GameState::IntegerRef* affectedbysilence) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(affectedbysilence_);
  }
  affectedbysilence_ = affectedbysilence;
  if (affectedbysilence) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.Card.AffectedBySilence)
}
inline ::GameState::IntegerRef* Card::release_affectedbysilence() {
  
  ::GameState::IntegerRef* temp = affectedbysilence_;
  affectedbysilence_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::GameState::IntegerRef* Card::unsafe_arena_release_affectedbysilence() {
  // @@protoc_insertion_point(field_release:GameState.Card.AffectedBySilence)
  
  ::GameState::IntegerRef* temp = affectedbysilence_;
  affectedbysilence_ = nullptr;
  return temp;
}
inline ::GameState::IntegerRef* Card::_internal_mutable_affectedbysilence() {
  
  if (affectedbysilence_ == nullptr) {
    auto* p = CreateMaybeMessage<::GameState::IntegerRef>(GetArena());
    affectedbysilence_ = p;
  }
  return affectedbysilence_;
}
inline ::GameState::IntegerRef* Card::mutable_affectedbysilence() {
  // @@protoc_insertion_point(field_mutable:GameState.Card.AffectedBySilence)
  return _internal_mutable_affectedbysilence();
}
inline void Card::set_allocated_affectedbysilence(::GameState::IntegerRef* affectedbysilence) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete affectedbysilence_;
  }
  if (affectedbysilence) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(affectedbysilence);
    if (message_arena != submessage_arena) {
      affectedbysilence = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, affectedbysilence, submessage_arena);
    }
    
  } else {
    
  }
  affectedbysilence_ = affectedbysilence;
  // @@protoc_insertion_point(field_set_allocated:GameState.Card.AffectedBySilence)
}

// .GameState.IntegerRef AffectedByDisarm = 15;
inline bool Card::_internal_has_affectedbydisarm() const {
  return this != internal_default_instance() && affectedbydisarm_ != nullptr;
}
inline bool Card::has_affectedbydisarm() const {
  return _internal_has_affectedbydisarm();
}
inline void Card::clear_affectedbydisarm() {
  if (GetArena() == nullptr && affectedbydisarm_ != nullptr) {
    delete affectedbydisarm_;
  }
  affectedbydisarm_ = nullptr;
}
inline const ::GameState::IntegerRef& Card::_internal_affectedbydisarm() const {
  const ::GameState::IntegerRef* p = affectedbydisarm_;
  return p != nullptr ? *p : reinterpret_cast<const ::GameState::IntegerRef&>(
      ::GameState::_IntegerRef_default_instance_);
}
inline const ::GameState::IntegerRef& Card::affectedbydisarm() const {
  // @@protoc_insertion_point(field_get:GameState.Card.AffectedByDisarm)
  return _internal_affectedbydisarm();
}
inline void Card::unsafe_arena_set_allocated_affectedbydisarm(
    ::GameState::IntegerRef* affectedbydisarm) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(affectedbydisarm_);
  }
  affectedbydisarm_ = affectedbydisarm;
  if (affectedbydisarm) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.Card.AffectedByDisarm)
}
inline ::GameState::IntegerRef* Card::release_affectedbydisarm() {
  
  ::GameState::IntegerRef* temp = affectedbydisarm_;
  affectedbydisarm_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::GameState::IntegerRef* Card::unsafe_arena_release_affectedbydisarm() {
  // @@protoc_insertion_point(field_release:GameState.Card.AffectedByDisarm)
  
  ::GameState::IntegerRef* temp = affectedbydisarm_;
  affectedbydisarm_ = nullptr;
  return temp;
}
inline ::GameState::IntegerRef* Card::_internal_mutable_affectedbydisarm() {
  
  if (affectedbydisarm_ == nullptr) {
    auto* p = CreateMaybeMessage<::GameState::IntegerRef>(GetArena());
    affectedbydisarm_ = p;
  }
  return affectedbydisarm_;
}
inline ::GameState::IntegerRef* Card::mutable_affectedbydisarm() {
  // @@protoc_insertion_point(field_mutable:GameState.Card.AffectedByDisarm)
  return _internal_mutable_affectedbydisarm();
}
inline void Card::set_allocated_affectedbydisarm(::GameState::IntegerRef* affectedbydisarm) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete affectedbydisarm_;
  }
  if (affectedbydisarm) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(affectedbydisarm);
    if (message_arena != submessage_arena) {
      affectedbydisarm = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, affectedbydisarm, submessage_arena);
    }
    
  } else {
    
  }
  affectedbydisarm_ = affectedbydisarm;
  // @@protoc_insertion_point(field_set_allocated:GameState.Card.AffectedByDisarm)
}

// .Effects.CardEffect OmniPresentEffect = 16;
inline bool Card::_internal_has_omnipresenteffect() const {
  return this != internal_default_instance() && omnipresenteffect_ != nullptr;
}
inline bool Card::has_omnipresenteffect() const {
  return _internal_has_omnipresenteffect();
}
inline const ::Effects::CardEffect& Card::_internal_omnipresenteffect() const {
  const ::Effects::CardEffect* p = omnipresenteffect_;
  return p != nullptr ? *p : reinterpret_cast<const ::Effects::CardEffect&>(
      ::Effects::_CardEffect_default_instance_);
}
inline const ::Effects::CardEffect& Card::omnipresenteffect() const {
  // @@protoc_insertion_point(field_get:GameState.Card.OmniPresentEffect)
  return _internal_omnipresenteffect();
}
inline void Card::unsafe_arena_set_allocated_omnipresenteffect(
    ::Effects::CardEffect* omnipresenteffect) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(omnipresenteffect_);
  }
  omnipresenteffect_ = omnipresenteffect;
  if (omnipresenteffect) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.Card.OmniPresentEffect)
}
inline ::Effects::CardEffect* Card::release_omnipresenteffect() {
  
  ::Effects::CardEffect* temp = omnipresenteffect_;
  omnipresenteffect_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Effects::CardEffect* Card::unsafe_arena_release_omnipresenteffect() {
  // @@protoc_insertion_point(field_release:GameState.Card.OmniPresentEffect)
  
  ::Effects::CardEffect* temp = omnipresenteffect_;
  omnipresenteffect_ = nullptr;
  return temp;
}
inline ::Effects::CardEffect* Card::_internal_mutable_omnipresenteffect() {
  
  if (omnipresenteffect_ == nullptr) {
    auto* p = CreateMaybeMessage<::Effects::CardEffect>(GetArena());
    omnipresenteffect_ = p;
  }
  return omnipresenteffect_;
}
inline ::Effects::CardEffect* Card::mutable_omnipresenteffect() {
  // @@protoc_insertion_point(field_mutable:GameState.Card.OmniPresentEffect)
  return _internal_mutable_omnipresenteffect();
}
inline void Card::set_allocated_omnipresenteffect(::Effects::CardEffect* omnipresenteffect) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(omnipresenteffect_);
  }
  if (omnipresenteffect) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(omnipresenteffect)->GetArena();
    if (message_arena != submessage_arena) {
      omnipresenteffect = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, omnipresenteffect, submessage_arena);
    }
    
  } else {
    
  }
  omnipresenteffect_ = omnipresenteffect;
  // @@protoc_insertion_point(field_set_allocated:GameState.Card.OmniPresentEffect)
}

// .Effects.CardEffect PassiveEffect = 17;
inline bool Card::_internal_has_passiveeffect() const {
  return this != internal_default_instance() && passiveeffect_ != nullptr;
}
inline bool Card::has_passiveeffect() const {
  return _internal_has_passiveeffect();
}
inline const ::Effects::CardEffect& Card::_internal_passiveeffect() const {
  const ::Effects::CardEffect* p = passiveeffect_;
  return p != nullptr ? *p : reinterpret_cast<const ::Effects::CardEffect&>(
      ::Effects::_CardEffect_default_instance_);
}
inline const ::Effects::CardEffect& Card::passiveeffect() const {
  // @@protoc_insertion_point(field_get:GameState.Card.PassiveEffect)
  return _internal_passiveeffect();
}
inline void Card::unsafe_arena_set_allocated_passiveeffect(
    ::Effects::CardEffect* passiveeffect) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(passiveeffect_);
  }
  passiveeffect_ = passiveeffect;
  if (passiveeffect) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.Card.PassiveEffect)
}
inline ::Effects::CardEffect* Card::release_passiveeffect() {
  
  ::Effects::CardEffect* temp = passiveeffect_;
  passiveeffect_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Effects::CardEffect* Card::unsafe_arena_release_passiveeffect() {
  // @@protoc_insertion_point(field_release:GameState.Card.PassiveEffect)
  
  ::Effects::CardEffect* temp = passiveeffect_;
  passiveeffect_ = nullptr;
  return temp;
}
inline ::Effects::CardEffect* Card::_internal_mutable_passiveeffect() {
  
  if (passiveeffect_ == nullptr) {
    auto* p = CreateMaybeMessage<::Effects::CardEffect>(GetArena());
    passiveeffect_ = p;
  }
  return passiveeffect_;
}
inline ::Effects::CardEffect* Card::mutable_passiveeffect() {
  // @@protoc_insertion_point(field_mutable:GameState.Card.PassiveEffect)
  return _internal_mutable_passiveeffect();
}
inline void Card::set_allocated_passiveeffect(::Effects::CardEffect* passiveeffect) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(passiveeffect_);
  }
  if (passiveeffect) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(passiveeffect)->GetArena();
    if (message_arena != submessage_arena) {
      passiveeffect = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, passiveeffect, submessage_arena);
    }
    
  } else {
    
  }
  passiveeffect_ = passiveeffect;
  // @@protoc_insertion_point(field_set_allocated:GameState.Card.PassiveEffect)
}

// .Effects.CardEffect FeatEffect = 18;
inline bool Card::_internal_has_feateffect() const {
  return this != internal_default_instance() && feateffect_ != nullptr;
}
inline bool Card::has_feateffect() const {
  return _internal_has_feateffect();
}
inline const ::Effects::CardEffect& Card::_internal_feateffect() const {
  const ::Effects::CardEffect* p = feateffect_;
  return p != nullptr ? *p : reinterpret_cast<const ::Effects::CardEffect&>(
      ::Effects::_CardEffect_default_instance_);
}
inline const ::Effects::CardEffect& Card::feateffect() const {
  // @@protoc_insertion_point(field_get:GameState.Card.FeatEffect)
  return _internal_feateffect();
}
inline void Card::unsafe_arena_set_allocated_feateffect(
    ::Effects::CardEffect* feateffect) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(feateffect_);
  }
  feateffect_ = feateffect;
  if (feateffect) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.Card.FeatEffect)
}
inline ::Effects::CardEffect* Card::release_feateffect() {
  
  ::Effects::CardEffect* temp = feateffect_;
  feateffect_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Effects::CardEffect* Card::unsafe_arena_release_feateffect() {
  // @@protoc_insertion_point(field_release:GameState.Card.FeatEffect)
  
  ::Effects::CardEffect* temp = feateffect_;
  feateffect_ = nullptr;
  return temp;
}
inline ::Effects::CardEffect* Card::_internal_mutable_feateffect() {
  
  if (feateffect_ == nullptr) {
    auto* p = CreateMaybeMessage<::Effects::CardEffect>(GetArena());
    feateffect_ = p;
  }
  return feateffect_;
}
inline ::Effects::CardEffect* Card::mutable_feateffect() {
  // @@protoc_insertion_point(field_mutable:GameState.Card.FeatEffect)
  return _internal_mutable_feateffect();
}
inline void Card::set_allocated_feateffect(::Effects::CardEffect* feateffect) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(feateffect_);
  }
  if (feateffect) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(feateffect)->GetArena();
    if (message_arena != submessage_arena) {
      feateffect = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, feateffect, submessage_arena);
    }
    
  } else {
    
  }
  feateffect_ = feateffect;
  // @@protoc_insertion_point(field_set_allocated:GameState.Card.FeatEffect)
}

// .Effects.CardEffect PlayEffect = 19;
inline bool Card::_internal_has_playeffect() const {
  return this != internal_default_instance() && playeffect_ != nullptr;
}
inline bool Card::has_playeffect() const {
  return _internal_has_playeffect();
}
inline const ::Effects::CardEffect& Card::_internal_playeffect() const {
  const ::Effects::CardEffect* p = playeffect_;
  return p != nullptr ? *p : reinterpret_cast<const ::Effects::CardEffect&>(
      ::Effects::_CardEffect_default_instance_);
}
inline const ::Effects::CardEffect& Card::playeffect() const {
  // @@protoc_insertion_point(field_get:GameState.Card.PlayEffect)
  return _internal_playeffect();
}
inline void Card::unsafe_arena_set_allocated_playeffect(
    ::Effects::CardEffect* playeffect) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(playeffect_);
  }
  playeffect_ = playeffect;
  if (playeffect) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.Card.PlayEffect)
}
inline ::Effects::CardEffect* Card::release_playeffect() {
  
  ::Effects::CardEffect* temp = playeffect_;
  playeffect_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Effects::CardEffect* Card::unsafe_arena_release_playeffect() {
  // @@protoc_insertion_point(field_release:GameState.Card.PlayEffect)
  
  ::Effects::CardEffect* temp = playeffect_;
  playeffect_ = nullptr;
  return temp;
}
inline ::Effects::CardEffect* Card::_internal_mutable_playeffect() {
  
  if (playeffect_ == nullptr) {
    auto* p = CreateMaybeMessage<::Effects::CardEffect>(GetArena());
    playeffect_ = p;
  }
  return playeffect_;
}
inline ::Effects::CardEffect* Card::mutable_playeffect() {
  // @@protoc_insertion_point(field_mutable:GameState.Card.PlayEffect)
  return _internal_mutable_playeffect();
}
inline void Card::set_allocated_playeffect(::Effects::CardEffect* playeffect) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(playeffect_);
  }
  if (playeffect) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(playeffect)->GetArena();
    if (message_arena != submessage_arena) {
      playeffect = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, playeffect, submessage_arena);
    }
    
  } else {
    
  }
  playeffect_ = playeffect;
  // @@protoc_insertion_point(field_set_allocated:GameState.Card.PlayEffect)
}

// .Effects.CardEffect ResolveEffect = 20;
inline bool Card::_internal_has_resolveeffect() const {
  return this != internal_default_instance() && resolveeffect_ != nullptr;
}
inline bool Card::has_resolveeffect() const {
  return _internal_has_resolveeffect();
}
inline const ::Effects::CardEffect& Card::_internal_resolveeffect() const {
  const ::Effects::CardEffect* p = resolveeffect_;
  return p != nullptr ? *p : reinterpret_cast<const ::Effects::CardEffect&>(
      ::Effects::_CardEffect_default_instance_);
}
inline const ::Effects::CardEffect& Card::resolveeffect() const {
  // @@protoc_insertion_point(field_get:GameState.Card.ResolveEffect)
  return _internal_resolveeffect();
}
inline void Card::unsafe_arena_set_allocated_resolveeffect(
    ::Effects::CardEffect* resolveeffect) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(resolveeffect_);
  }
  resolveeffect_ = resolveeffect;
  if (resolveeffect) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.Card.ResolveEffect)
}
inline ::Effects::CardEffect* Card::release_resolveeffect() {
  
  ::Effects::CardEffect* temp = resolveeffect_;
  resolveeffect_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Effects::CardEffect* Card::unsafe_arena_release_resolveeffect() {
  // @@protoc_insertion_point(field_release:GameState.Card.ResolveEffect)
  
  ::Effects::CardEffect* temp = resolveeffect_;
  resolveeffect_ = nullptr;
  return temp;
}
inline ::Effects::CardEffect* Card::_internal_mutable_resolveeffect() {
  
  if (resolveeffect_ == nullptr) {
    auto* p = CreateMaybeMessage<::Effects::CardEffect>(GetArena());
    resolveeffect_ = p;
  }
  return resolveeffect_;
}
inline ::Effects::CardEffect* Card::mutable_resolveeffect() {
  // @@protoc_insertion_point(field_mutable:GameState.Card.ResolveEffect)
  return _internal_mutable_resolveeffect();
}
inline void Card::set_allocated_resolveeffect(::Effects::CardEffect* resolveeffect) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(resolveeffect_);
  }
  if (resolveeffect) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(resolveeffect)->GetArena();
    if (message_arena != submessage_arena) {
      resolveeffect = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, resolveeffect, submessage_arena);
    }
    
  } else {
    
  }
  resolveeffect_ = resolveeffect;
  // @@protoc_insertion_point(field_set_allocated:GameState.Card.ResolveEffect)
}

// -------------------------------------------------------------------

// Team

// repeated .GameState.PlayerRef Players = 1;
inline int Team::_internal_players_size() const {
  return players_.size();
}
inline int Team::players_size() const {
  return _internal_players_size();
}
inline void Team::clear_players() {
  players_.Clear();
}
inline ::GameState::PlayerRef* Team::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:GameState.Team.Players)
  return players_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::PlayerRef >*
Team::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:GameState.Team.Players)
  return &players_;
}
inline const ::GameState::PlayerRef& Team::_internal_players(int index) const {
  return players_.Get(index);
}
inline const ::GameState::PlayerRef& Team::players(int index) const {
  // @@protoc_insertion_point(field_get:GameState.Team.Players)
  return _internal_players(index);
}
inline ::GameState::PlayerRef* Team::_internal_add_players() {
  return players_.Add();
}
inline ::GameState::PlayerRef* Team::add_players() {
  // @@protoc_insertion_point(field_add:GameState.Team.Players)
  return _internal_add_players();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::PlayerRef >&
Team::players() const {
  // @@protoc_insertion_point(field_list:GameState.Team.Players)
  return players_;
}

// -------------------------------------------------------------------

// SetMutation

// .GameState.EntityRef Object = 1;
inline bool SetMutation::_internal_has_object() const {
  return this != internal_default_instance() && object_ != nullptr;
}
inline bool SetMutation::has_object() const {
  return _internal_has_object();
}
inline void SetMutation::clear_object() {
  if (GetArena() == nullptr && object_ != nullptr) {
    delete object_;
  }
  object_ = nullptr;
}
inline const ::GameState::EntityRef& SetMutation::_internal_object() const {
  const ::GameState::EntityRef* p = object_;
  return p != nullptr ? *p : reinterpret_cast<const ::GameState::EntityRef&>(
      ::GameState::_EntityRef_default_instance_);
}
inline const ::GameState::EntityRef& SetMutation::object() const {
  // @@protoc_insertion_point(field_get:GameState.SetMutation.Object)
  return _internal_object();
}
inline void SetMutation::unsafe_arena_set_allocated_object(
    ::GameState::EntityRef* object) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(object_);
  }
  object_ = object;
  if (object) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.SetMutation.Object)
}
inline ::GameState::EntityRef* SetMutation::release_object() {
  
  ::GameState::EntityRef* temp = object_;
  object_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::GameState::EntityRef* SetMutation::unsafe_arena_release_object() {
  // @@protoc_insertion_point(field_release:GameState.SetMutation.Object)
  
  ::GameState::EntityRef* temp = object_;
  object_ = nullptr;
  return temp;
}
inline ::GameState::EntityRef* SetMutation::_internal_mutable_object() {
  
  if (object_ == nullptr) {
    auto* p = CreateMaybeMessage<::GameState::EntityRef>(GetArena());
    object_ = p;
  }
  return object_;
}
inline ::GameState::EntityRef* SetMutation::mutable_object() {
  // @@protoc_insertion_point(field_mutable:GameState.SetMutation.Object)
  return _internal_mutable_object();
}
inline void SetMutation::set_allocated_object(::GameState::EntityRef* object) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete object_;
  }
  if (object) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(object);
    if (message_arena != submessage_arena) {
      object = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, object, submessage_arena);
    }
    
  } else {
    
  }
  object_ = object;
  // @@protoc_insertion_point(field_set_allocated:GameState.SetMutation.Object)
}

// .GameState.EntityValue NewValue = 2;
inline bool SetMutation::_internal_has_newvalue() const {
  return this != internal_default_instance() && newvalue_ != nullptr;
}
inline bool SetMutation::has_newvalue() const {
  return _internal_has_newvalue();
}
inline void SetMutation::clear_newvalue() {
  if (GetArena() == nullptr && newvalue_ != nullptr) {
    delete newvalue_;
  }
  newvalue_ = nullptr;
}
inline const ::GameState::EntityValue& SetMutation::_internal_newvalue() const {
  const ::GameState::EntityValue* p = newvalue_;
  return p != nullptr ? *p : reinterpret_cast<const ::GameState::EntityValue&>(
      ::GameState::_EntityValue_default_instance_);
}
inline const ::GameState::EntityValue& SetMutation::newvalue() const {
  // @@protoc_insertion_point(field_get:GameState.SetMutation.NewValue)
  return _internal_newvalue();
}
inline void SetMutation::unsafe_arena_set_allocated_newvalue(
    ::GameState::EntityValue* newvalue) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(newvalue_);
  }
  newvalue_ = newvalue;
  if (newvalue) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.SetMutation.NewValue)
}
inline ::GameState::EntityValue* SetMutation::release_newvalue() {
  
  ::GameState::EntityValue* temp = newvalue_;
  newvalue_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::GameState::EntityValue* SetMutation::unsafe_arena_release_newvalue() {
  // @@protoc_insertion_point(field_release:GameState.SetMutation.NewValue)
  
  ::GameState::EntityValue* temp = newvalue_;
  newvalue_ = nullptr;
  return temp;
}
inline ::GameState::EntityValue* SetMutation::_internal_mutable_newvalue() {
  
  if (newvalue_ == nullptr) {
    auto* p = CreateMaybeMessage<::GameState::EntityValue>(GetArena());
    newvalue_ = p;
  }
  return newvalue_;
}
inline ::GameState::EntityValue* SetMutation::mutable_newvalue() {
  // @@protoc_insertion_point(field_mutable:GameState.SetMutation.NewValue)
  return _internal_mutable_newvalue();
}
inline void SetMutation::set_allocated_newvalue(::GameState::EntityValue* newvalue) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete newvalue_;
  }
  if (newvalue) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(newvalue);
    if (message_arena != submessage_arena) {
      newvalue = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, newvalue, submessage_arena);
    }
    
  } else {
    
  }
  newvalue_ = newvalue;
  // @@protoc_insertion_point(field_set_allocated:GameState.SetMutation.NewValue)
}

// .GameState.EntityValue OldValue = 3;
inline bool SetMutation::_internal_has_oldvalue() const {
  return this != internal_default_instance() && oldvalue_ != nullptr;
}
inline bool SetMutation::has_oldvalue() const {
  return _internal_has_oldvalue();
}
inline void SetMutation::clear_oldvalue() {
  if (GetArena() == nullptr && oldvalue_ != nullptr) {
    delete oldvalue_;
  }
  oldvalue_ = nullptr;
}
inline const ::GameState::EntityValue& SetMutation::_internal_oldvalue() const {
  const ::GameState::EntityValue* p = oldvalue_;
  return p != nullptr ? *p : reinterpret_cast<const ::GameState::EntityValue&>(
      ::GameState::_EntityValue_default_instance_);
}
inline const ::GameState::EntityValue& SetMutation::oldvalue() const {
  // @@protoc_insertion_point(field_get:GameState.SetMutation.OldValue)
  return _internal_oldvalue();
}
inline void SetMutation::unsafe_arena_set_allocated_oldvalue(
    ::GameState::EntityValue* oldvalue) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(oldvalue_);
  }
  oldvalue_ = oldvalue;
  if (oldvalue) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.SetMutation.OldValue)
}
inline ::GameState::EntityValue* SetMutation::release_oldvalue() {
  
  ::GameState::EntityValue* temp = oldvalue_;
  oldvalue_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::GameState::EntityValue* SetMutation::unsafe_arena_release_oldvalue() {
  // @@protoc_insertion_point(field_release:GameState.SetMutation.OldValue)
  
  ::GameState::EntityValue* temp = oldvalue_;
  oldvalue_ = nullptr;
  return temp;
}
inline ::GameState::EntityValue* SetMutation::_internal_mutable_oldvalue() {
  
  if (oldvalue_ == nullptr) {
    auto* p = CreateMaybeMessage<::GameState::EntityValue>(GetArena());
    oldvalue_ = p;
  }
  return oldvalue_;
}
inline ::GameState::EntityValue* SetMutation::mutable_oldvalue() {
  // @@protoc_insertion_point(field_mutable:GameState.SetMutation.OldValue)
  return _internal_mutable_oldvalue();
}
inline void SetMutation::set_allocated_oldvalue(::GameState::EntityValue* oldvalue) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete oldvalue_;
  }
  if (oldvalue) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(oldvalue);
    if (message_arena != submessage_arena) {
      oldvalue = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, oldvalue, submessage_arena);
    }
    
  } else {
    
  }
  oldvalue_ = oldvalue;
  // @@protoc_insertion_point(field_set_allocated:GameState.SetMutation.OldValue)
}

// -------------------------------------------------------------------

// RemoveMutation

// .GameState.EntityRef Object = 1;
inline bool RemoveMutation::_internal_has_object() const {
  return this != internal_default_instance() && object_ != nullptr;
}
inline bool RemoveMutation::has_object() const {
  return _internal_has_object();
}
inline void RemoveMutation::clear_object() {
  if (GetArena() == nullptr && object_ != nullptr) {
    delete object_;
  }
  object_ = nullptr;
}
inline const ::GameState::EntityRef& RemoveMutation::_internal_object() const {
  const ::GameState::EntityRef* p = object_;
  return p != nullptr ? *p : reinterpret_cast<const ::GameState::EntityRef&>(
      ::GameState::_EntityRef_default_instance_);
}
inline const ::GameState::EntityRef& RemoveMutation::object() const {
  // @@protoc_insertion_point(field_get:GameState.RemoveMutation.Object)
  return _internal_object();
}
inline void RemoveMutation::unsafe_arena_set_allocated_object(
    ::GameState::EntityRef* object) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(object_);
  }
  object_ = object;
  if (object) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.RemoveMutation.Object)
}
inline ::GameState::EntityRef* RemoveMutation::release_object() {
  
  ::GameState::EntityRef* temp = object_;
  object_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::GameState::EntityRef* RemoveMutation::unsafe_arena_release_object() {
  // @@protoc_insertion_point(field_release:GameState.RemoveMutation.Object)
  
  ::GameState::EntityRef* temp = object_;
  object_ = nullptr;
  return temp;
}
inline ::GameState::EntityRef* RemoveMutation::_internal_mutable_object() {
  
  if (object_ == nullptr) {
    auto* p = CreateMaybeMessage<::GameState::EntityRef>(GetArena());
    object_ = p;
  }
  return object_;
}
inline ::GameState::EntityRef* RemoveMutation::mutable_object() {
  // @@protoc_insertion_point(field_mutable:GameState.RemoveMutation.Object)
  return _internal_mutable_object();
}
inline void RemoveMutation::set_allocated_object(::GameState::EntityRef* object) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete object_;
  }
  if (object) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(object);
    if (message_arena != submessage_arena) {
      object = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, object, submessage_arena);
    }
    
  } else {
    
  }
  object_ = object;
  // @@protoc_insertion_point(field_set_allocated:GameState.RemoveMutation.Object)
}

// .GameState.EntityValue OldValue = 2;
inline bool RemoveMutation::_internal_has_oldvalue() const {
  return this != internal_default_instance() && oldvalue_ != nullptr;
}
inline bool RemoveMutation::has_oldvalue() const {
  return _internal_has_oldvalue();
}
inline void RemoveMutation::clear_oldvalue() {
  if (GetArena() == nullptr && oldvalue_ != nullptr) {
    delete oldvalue_;
  }
  oldvalue_ = nullptr;
}
inline const ::GameState::EntityValue& RemoveMutation::_internal_oldvalue() const {
  const ::GameState::EntityValue* p = oldvalue_;
  return p != nullptr ? *p : reinterpret_cast<const ::GameState::EntityValue&>(
      ::GameState::_EntityValue_default_instance_);
}
inline const ::GameState::EntityValue& RemoveMutation::oldvalue() const {
  // @@protoc_insertion_point(field_get:GameState.RemoveMutation.OldValue)
  return _internal_oldvalue();
}
inline void RemoveMutation::unsafe_arena_set_allocated_oldvalue(
    ::GameState::EntityValue* oldvalue) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(oldvalue_);
  }
  oldvalue_ = oldvalue;
  if (oldvalue) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.RemoveMutation.OldValue)
}
inline ::GameState::EntityValue* RemoveMutation::release_oldvalue() {
  
  ::GameState::EntityValue* temp = oldvalue_;
  oldvalue_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::GameState::EntityValue* RemoveMutation::unsafe_arena_release_oldvalue() {
  // @@protoc_insertion_point(field_release:GameState.RemoveMutation.OldValue)
  
  ::GameState::EntityValue* temp = oldvalue_;
  oldvalue_ = nullptr;
  return temp;
}
inline ::GameState::EntityValue* RemoveMutation::_internal_mutable_oldvalue() {
  
  if (oldvalue_ == nullptr) {
    auto* p = CreateMaybeMessage<::GameState::EntityValue>(GetArena());
    oldvalue_ = p;
  }
  return oldvalue_;
}
inline ::GameState::EntityValue* RemoveMutation::mutable_oldvalue() {
  // @@protoc_insertion_point(field_mutable:GameState.RemoveMutation.OldValue)
  return _internal_mutable_oldvalue();
}
inline void RemoveMutation::set_allocated_oldvalue(::GameState::EntityValue* oldvalue) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete oldvalue_;
  }
  if (oldvalue) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(oldvalue);
    if (message_arena != submessage_arena) {
      oldvalue = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, oldvalue, submessage_arena);
    }
    
  } else {
    
  }
  oldvalue_ = oldvalue;
  // @@protoc_insertion_point(field_set_allocated:GameState.RemoveMutation.OldValue)
}

// -------------------------------------------------------------------

// InsertMutation

// .GameState.EntityRef Object = 1;
inline bool InsertMutation::_internal_has_object() const {
  return this != internal_default_instance() && object_ != nullptr;
}
inline bool InsertMutation::has_object() const {
  return _internal_has_object();
}
inline void InsertMutation::clear_object() {
  if (GetArena() == nullptr && object_ != nullptr) {
    delete object_;
  }
  object_ = nullptr;
}
inline const ::GameState::EntityRef& InsertMutation::_internal_object() const {
  const ::GameState::EntityRef* p = object_;
  return p != nullptr ? *p : reinterpret_cast<const ::GameState::EntityRef&>(
      ::GameState::_EntityRef_default_instance_);
}
inline const ::GameState::EntityRef& InsertMutation::object() const {
  // @@protoc_insertion_point(field_get:GameState.InsertMutation.Object)
  return _internal_object();
}
inline void InsertMutation::unsafe_arena_set_allocated_object(
    ::GameState::EntityRef* object) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(object_);
  }
  object_ = object;
  if (object) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.InsertMutation.Object)
}
inline ::GameState::EntityRef* InsertMutation::release_object() {
  
  ::GameState::EntityRef* temp = object_;
  object_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::GameState::EntityRef* InsertMutation::unsafe_arena_release_object() {
  // @@protoc_insertion_point(field_release:GameState.InsertMutation.Object)
  
  ::GameState::EntityRef* temp = object_;
  object_ = nullptr;
  return temp;
}
inline ::GameState::EntityRef* InsertMutation::_internal_mutable_object() {
  
  if (object_ == nullptr) {
    auto* p = CreateMaybeMessage<::GameState::EntityRef>(GetArena());
    object_ = p;
  }
  return object_;
}
inline ::GameState::EntityRef* InsertMutation::mutable_object() {
  // @@protoc_insertion_point(field_mutable:GameState.InsertMutation.Object)
  return _internal_mutable_object();
}
inline void InsertMutation::set_allocated_object(::GameState::EntityRef* object) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete object_;
  }
  if (object) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(object);
    if (message_arena != submessage_arena) {
      object = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, object, submessage_arena);
    }
    
  } else {
    
  }
  object_ = object;
  // @@protoc_insertion_point(field_set_allocated:GameState.InsertMutation.Object)
}

// .GameState.EntityValue NewValue = 2;
inline bool InsertMutation::_internal_has_newvalue() const {
  return this != internal_default_instance() && newvalue_ != nullptr;
}
inline bool InsertMutation::has_newvalue() const {
  return _internal_has_newvalue();
}
inline void InsertMutation::clear_newvalue() {
  if (GetArena() == nullptr && newvalue_ != nullptr) {
    delete newvalue_;
  }
  newvalue_ = nullptr;
}
inline const ::GameState::EntityValue& InsertMutation::_internal_newvalue() const {
  const ::GameState::EntityValue* p = newvalue_;
  return p != nullptr ? *p : reinterpret_cast<const ::GameState::EntityValue&>(
      ::GameState::_EntityValue_default_instance_);
}
inline const ::GameState::EntityValue& InsertMutation::newvalue() const {
  // @@protoc_insertion_point(field_get:GameState.InsertMutation.NewValue)
  return _internal_newvalue();
}
inline void InsertMutation::unsafe_arena_set_allocated_newvalue(
    ::GameState::EntityValue* newvalue) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(newvalue_);
  }
  newvalue_ = newvalue;
  if (newvalue) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.InsertMutation.NewValue)
}
inline ::GameState::EntityValue* InsertMutation::release_newvalue() {
  
  ::GameState::EntityValue* temp = newvalue_;
  newvalue_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::GameState::EntityValue* InsertMutation::unsafe_arena_release_newvalue() {
  // @@protoc_insertion_point(field_release:GameState.InsertMutation.NewValue)
  
  ::GameState::EntityValue* temp = newvalue_;
  newvalue_ = nullptr;
  return temp;
}
inline ::GameState::EntityValue* InsertMutation::_internal_mutable_newvalue() {
  
  if (newvalue_ == nullptr) {
    auto* p = CreateMaybeMessage<::GameState::EntityValue>(GetArena());
    newvalue_ = p;
  }
  return newvalue_;
}
inline ::GameState::EntityValue* InsertMutation::mutable_newvalue() {
  // @@protoc_insertion_point(field_mutable:GameState.InsertMutation.NewValue)
  return _internal_mutable_newvalue();
}
inline void InsertMutation::set_allocated_newvalue(::GameState::EntityValue* newvalue) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete newvalue_;
  }
  if (newvalue) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(newvalue);
    if (message_arena != submessage_arena) {
      newvalue = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, newvalue, submessage_arena);
    }
    
  } else {
    
  }
  newvalue_ = newvalue;
  // @@protoc_insertion_point(field_set_allocated:GameState.InsertMutation.NewValue)
}

// -------------------------------------------------------------------

// Mutation

// .GameState.SetMutation Set = 1;
inline bool Mutation::_internal_has_set() const {
  return mutation_case() == kSet;
}
inline bool Mutation::has_set() const {
  return _internal_has_set();
}
inline void Mutation::set_has_set() {
  _oneof_case_[0] = kSet;
}
inline void Mutation::clear_set() {
  if (_internal_has_set()) {
    if (GetArena() == nullptr) {
      delete mutation_.set_;
    }
    clear_has_mutation();
  }
}
inline ::GameState::SetMutation* Mutation::release_set() {
  // @@protoc_insertion_point(field_release:GameState.Mutation.Set)
  if (_internal_has_set()) {
    clear_has_mutation();
      ::GameState::SetMutation* temp = mutation_.set_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    mutation_.set_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::GameState::SetMutation& Mutation::_internal_set() const {
  return _internal_has_set()
      ? *mutation_.set_
      : reinterpret_cast< ::GameState::SetMutation&>(::GameState::_SetMutation_default_instance_);
}
inline const ::GameState::SetMutation& Mutation::set() const {
  // @@protoc_insertion_point(field_get:GameState.Mutation.Set)
  return _internal_set();
}
inline ::GameState::SetMutation* Mutation::unsafe_arena_release_set() {
  // @@protoc_insertion_point(field_unsafe_arena_release:GameState.Mutation.Set)
  if (_internal_has_set()) {
    clear_has_mutation();
    ::GameState::SetMutation* temp = mutation_.set_;
    mutation_.set_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Mutation::unsafe_arena_set_allocated_set(::GameState::SetMutation* set) {
  clear_mutation();
  if (set) {
    set_has_set();
    mutation_.set_ = set;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.Mutation.Set)
}
inline ::GameState::SetMutation* Mutation::_internal_mutable_set() {
  if (!_internal_has_set()) {
    clear_mutation();
    set_has_set();
    mutation_.set_ = CreateMaybeMessage< ::GameState::SetMutation >(GetArena());
  }
  return mutation_.set_;
}
inline ::GameState::SetMutation* Mutation::mutable_set() {
  // @@protoc_insertion_point(field_mutable:GameState.Mutation.Set)
  return _internal_mutable_set();
}

// .GameState.RemoveMutation Remove = 2;
inline bool Mutation::_internal_has_remove() const {
  return mutation_case() == kRemove;
}
inline bool Mutation::has_remove() const {
  return _internal_has_remove();
}
inline void Mutation::set_has_remove() {
  _oneof_case_[0] = kRemove;
}
inline void Mutation::clear_remove() {
  if (_internal_has_remove()) {
    if (GetArena() == nullptr) {
      delete mutation_.remove_;
    }
    clear_has_mutation();
  }
}
inline ::GameState::RemoveMutation* Mutation::release_remove() {
  // @@protoc_insertion_point(field_release:GameState.Mutation.Remove)
  if (_internal_has_remove()) {
    clear_has_mutation();
      ::GameState::RemoveMutation* temp = mutation_.remove_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    mutation_.remove_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::GameState::RemoveMutation& Mutation::_internal_remove() const {
  return _internal_has_remove()
      ? *mutation_.remove_
      : reinterpret_cast< ::GameState::RemoveMutation&>(::GameState::_RemoveMutation_default_instance_);
}
inline const ::GameState::RemoveMutation& Mutation::remove() const {
  // @@protoc_insertion_point(field_get:GameState.Mutation.Remove)
  return _internal_remove();
}
inline ::GameState::RemoveMutation* Mutation::unsafe_arena_release_remove() {
  // @@protoc_insertion_point(field_unsafe_arena_release:GameState.Mutation.Remove)
  if (_internal_has_remove()) {
    clear_has_mutation();
    ::GameState::RemoveMutation* temp = mutation_.remove_;
    mutation_.remove_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Mutation::unsafe_arena_set_allocated_remove(::GameState::RemoveMutation* remove) {
  clear_mutation();
  if (remove) {
    set_has_remove();
    mutation_.remove_ = remove;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.Mutation.Remove)
}
inline ::GameState::RemoveMutation* Mutation::_internal_mutable_remove() {
  if (!_internal_has_remove()) {
    clear_mutation();
    set_has_remove();
    mutation_.remove_ = CreateMaybeMessage< ::GameState::RemoveMutation >(GetArena());
  }
  return mutation_.remove_;
}
inline ::GameState::RemoveMutation* Mutation::mutable_remove() {
  // @@protoc_insertion_point(field_mutable:GameState.Mutation.Remove)
  return _internal_mutable_remove();
}

// .GameState.InsertMutation Insert = 3;
inline bool Mutation::_internal_has_insert() const {
  return mutation_case() == kInsert;
}
inline bool Mutation::has_insert() const {
  return _internal_has_insert();
}
inline void Mutation::set_has_insert() {
  _oneof_case_[0] = kInsert;
}
inline void Mutation::clear_insert() {
  if (_internal_has_insert()) {
    if (GetArena() == nullptr) {
      delete mutation_.insert_;
    }
    clear_has_mutation();
  }
}
inline ::GameState::InsertMutation* Mutation::release_insert() {
  // @@protoc_insertion_point(field_release:GameState.Mutation.Insert)
  if (_internal_has_insert()) {
    clear_has_mutation();
      ::GameState::InsertMutation* temp = mutation_.insert_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    mutation_.insert_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::GameState::InsertMutation& Mutation::_internal_insert() const {
  return _internal_has_insert()
      ? *mutation_.insert_
      : reinterpret_cast< ::GameState::InsertMutation&>(::GameState::_InsertMutation_default_instance_);
}
inline const ::GameState::InsertMutation& Mutation::insert() const {
  // @@protoc_insertion_point(field_get:GameState.Mutation.Insert)
  return _internal_insert();
}
inline ::GameState::InsertMutation* Mutation::unsafe_arena_release_insert() {
  // @@protoc_insertion_point(field_unsafe_arena_release:GameState.Mutation.Insert)
  if (_internal_has_insert()) {
    clear_has_mutation();
    ::GameState::InsertMutation* temp = mutation_.insert_;
    mutation_.insert_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Mutation::unsafe_arena_set_allocated_insert(::GameState::InsertMutation* insert) {
  clear_mutation();
  if (insert) {
    set_has_insert();
    mutation_.insert_ = insert;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.Mutation.Insert)
}
inline ::GameState::InsertMutation* Mutation::_internal_mutable_insert() {
  if (!_internal_has_insert()) {
    clear_mutation();
    set_has_insert();
    mutation_.insert_ = CreateMaybeMessage< ::GameState::InsertMutation >(GetArena());
  }
  return mutation_.insert_;
}
inline ::GameState::InsertMutation* Mutation::mutable_insert() {
  // @@protoc_insertion_point(field_mutable:GameState.Mutation.Insert)
  return _internal_mutable_insert();
}

inline bool Mutation::has_mutation() const {
  return mutation_case() != MUTATION_NOT_SET;
}
inline void Mutation::clear_has_mutation() {
  _oneof_case_[0] = MUTATION_NOT_SET;
}
inline Mutation::MutationCase Mutation::mutation_case() const {
  return Mutation::MutationCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// GameState

// repeated .GameState.Player Players = 1;
inline int GameState::_internal_players_size() const {
  return players_.size();
}
inline int GameState::players_size() const {
  return _internal_players_size();
}
inline void GameState::clear_players() {
  players_.Clear();
}
inline ::GameState::Player* GameState::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:GameState.GameState.Players)
  return players_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::Player >*
GameState::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:GameState.GameState.Players)
  return &players_;
}
inline const ::GameState::Player& GameState::_internal_players(int index) const {
  return players_.Get(index);
}
inline const ::GameState::Player& GameState::players(int index) const {
  // @@protoc_insertion_point(field_get:GameState.GameState.Players)
  return _internal_players(index);
}
inline ::GameState::Player* GameState::_internal_add_players() {
  return players_.Add();
}
inline ::GameState::Player* GameState::add_players() {
  // @@protoc_insertion_point(field_add:GameState.GameState.Players)
  return _internal_add_players();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::Player >&
GameState::players() const {
  // @@protoc_insertion_point(field_list:GameState.GameState.Players)
  return players_;
}

// repeated .GameState.Card Cards = 2;
inline int GameState::_internal_cards_size() const {
  return cards_.size();
}
inline int GameState::cards_size() const {
  return _internal_cards_size();
}
inline void GameState::clear_cards() {
  cards_.Clear();
}
inline ::GameState::Card* GameState::mutable_cards(int index) {
  // @@protoc_insertion_point(field_mutable:GameState.GameState.Cards)
  return cards_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::Card >*
GameState::mutable_cards() {
  // @@protoc_insertion_point(field_mutable_list:GameState.GameState.Cards)
  return &cards_;
}
inline const ::GameState::Card& GameState::_internal_cards(int index) const {
  return cards_.Get(index);
}
inline const ::GameState::Card& GameState::cards(int index) const {
  // @@protoc_insertion_point(field_get:GameState.GameState.Cards)
  return _internal_cards(index);
}
inline ::GameState::Card* GameState::_internal_add_cards() {
  return cards_.Add();
}
inline ::GameState::Card* GameState::add_cards() {
  // @@protoc_insertion_point(field_add:GameState.GameState.Cards)
  return _internal_add_cards();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::Card >&
GameState::cards() const {
  // @@protoc_insertion_point(field_list:GameState.GameState.Cards)
  return cards_;
}

// repeated .GameState.Tile Tiles = 3;
inline int GameState::_internal_tiles_size() const {
  return tiles_.size();
}
inline int GameState::tiles_size() const {
  return _internal_tiles_size();
}
inline void GameState::clear_tiles() {
  tiles_.Clear();
}
inline ::GameState::Tile* GameState::mutable_tiles(int index) {
  // @@protoc_insertion_point(field_mutable:GameState.GameState.Tiles)
  return tiles_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::Tile >*
GameState::mutable_tiles() {
  // @@protoc_insertion_point(field_mutable_list:GameState.GameState.Tiles)
  return &tiles_;
}
inline const ::GameState::Tile& GameState::_internal_tiles(int index) const {
  return tiles_.Get(index);
}
inline const ::GameState::Tile& GameState::tiles(int index) const {
  // @@protoc_insertion_point(field_get:GameState.GameState.Tiles)
  return _internal_tiles(index);
}
inline ::GameState::Tile* GameState::_internal_add_tiles() {
  return tiles_.Add();
}
inline ::GameState::Tile* GameState::add_tiles() {
  // @@protoc_insertion_point(field_add:GameState.GameState.Tiles)
  return _internal_add_tiles();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::Tile >&
GameState::tiles() const {
  // @@protoc_insertion_point(field_list:GameState.GameState.Tiles)
  return tiles_;
}

// repeated .GameState.Team Teams = 4;
inline int GameState::_internal_teams_size() const {
  return teams_.size();
}
inline int GameState::teams_size() const {
  return _internal_teams_size();
}
inline void GameState::clear_teams() {
  teams_.Clear();
}
inline ::GameState::Team* GameState::mutable_teams(int index) {
  // @@protoc_insertion_point(field_mutable:GameState.GameState.Teams)
  return teams_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::Team >*
GameState::mutable_teams() {
  // @@protoc_insertion_point(field_mutable_list:GameState.GameState.Teams)
  return &teams_;
}
inline const ::GameState::Team& GameState::_internal_teams(int index) const {
  return teams_.Get(index);
}
inline const ::GameState::Team& GameState::teams(int index) const {
  // @@protoc_insertion_point(field_get:GameState.GameState.Teams)
  return _internal_teams(index);
}
inline ::GameState::Team* GameState::_internal_add_teams() {
  return teams_.Add();
}
inline ::GameState::Team* GameState::add_teams() {
  // @@protoc_insertion_point(field_add:GameState.GameState.Teams)
  return _internal_add_teams();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::Team >&
GameState::teams() const {
  // @@protoc_insertion_point(field_list:GameState.GameState.Teams)
  return teams_;
}

// .GameState.Integer TurnNumber = 6;
inline bool GameState::_internal_has_turnnumber() const {
  return this != internal_default_instance() && turnnumber_ != nullptr;
}
inline bool GameState::has_turnnumber() const {
  return _internal_has_turnnumber();
}
inline void GameState::clear_turnnumber() {
  if (GetArena() == nullptr && turnnumber_ != nullptr) {
    delete turnnumber_;
  }
  turnnumber_ = nullptr;
}
inline const ::GameState::Integer& GameState::_internal_turnnumber() const {
  const ::GameState::Integer* p = turnnumber_;
  return p != nullptr ? *p : reinterpret_cast<const ::GameState::Integer&>(
      ::GameState::_Integer_default_instance_);
}
inline const ::GameState::Integer& GameState::turnnumber() const {
  // @@protoc_insertion_point(field_get:GameState.GameState.TurnNumber)
  return _internal_turnnumber();
}
inline void GameState::unsafe_arena_set_allocated_turnnumber(
    ::GameState::Integer* turnnumber) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(turnnumber_);
  }
  turnnumber_ = turnnumber;
  if (turnnumber) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.GameState.TurnNumber)
}
inline ::GameState::Integer* GameState::release_turnnumber() {
  
  ::GameState::Integer* temp = turnnumber_;
  turnnumber_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::GameState::Integer* GameState::unsafe_arena_release_turnnumber() {
  // @@protoc_insertion_point(field_release:GameState.GameState.TurnNumber)
  
  ::GameState::Integer* temp = turnnumber_;
  turnnumber_ = nullptr;
  return temp;
}
inline ::GameState::Integer* GameState::_internal_mutable_turnnumber() {
  
  if (turnnumber_ == nullptr) {
    auto* p = CreateMaybeMessage<::GameState::Integer>(GetArena());
    turnnumber_ = p;
  }
  return turnnumber_;
}
inline ::GameState::Integer* GameState::mutable_turnnumber() {
  // @@protoc_insertion_point(field_mutable:GameState.GameState.TurnNumber)
  return _internal_mutable_turnnumber();
}
inline void GameState::set_allocated_turnnumber(::GameState::Integer* turnnumber) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete turnnumber_;
  }
  if (turnnumber) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(turnnumber);
    if (message_arena != submessage_arena) {
      turnnumber = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, turnnumber, submessage_arena);
    }
    
  } else {
    
  }
  turnnumber_ = turnnumber;
  // @@protoc_insertion_point(field_set_allocated:GameState.GameState.TurnNumber)
}

// repeated .GameState.Card Stack = 7;
inline int GameState::_internal_stack_size() const {
  return stack_.size();
}
inline int GameState::stack_size() const {
  return _internal_stack_size();
}
inline void GameState::clear_stack() {
  stack_.Clear();
}
inline ::GameState::Card* GameState::mutable_stack(int index) {
  // @@protoc_insertion_point(field_mutable:GameState.GameState.Stack)
  return stack_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::Card >*
GameState::mutable_stack() {
  // @@protoc_insertion_point(field_mutable_list:GameState.GameState.Stack)
  return &stack_;
}
inline const ::GameState::Card& GameState::_internal_stack(int index) const {
  return stack_.Get(index);
}
inline const ::GameState::Card& GameState::stack(int index) const {
  // @@protoc_insertion_point(field_get:GameState.GameState.Stack)
  return _internal_stack(index);
}
inline ::GameState::Card* GameState::_internal_add_stack() {
  return stack_.Add();
}
inline ::GameState::Card* GameState::add_stack() {
  // @@protoc_insertion_point(field_add:GameState.GameState.Stack)
  return _internal_add_stack();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::Card >&
GameState::stack() const {
  // @@protoc_insertion_point(field_list:GameState.GameState.Stack)
  return stack_;
}

// -------------------------------------------------------------------

// GameInstance

// .GameState.GameState GameState = 1;
inline bool GameInstance::_internal_has_gamestate() const {
  return this != internal_default_instance() && gamestate_ != nullptr;
}
inline bool GameInstance::has_gamestate() const {
  return _internal_has_gamestate();
}
inline void GameInstance::clear_gamestate() {
  if (GetArena() == nullptr && gamestate_ != nullptr) {
    delete gamestate_;
  }
  gamestate_ = nullptr;
}
inline const ::GameState::GameState& GameInstance::_internal_gamestate() const {
  const ::GameState::GameState* p = gamestate_;
  return p != nullptr ? *p : reinterpret_cast<const ::GameState::GameState&>(
      ::GameState::_GameState_default_instance_);
}
inline const ::GameState::GameState& GameInstance::gamestate() const {
  // @@protoc_insertion_point(field_get:GameState.GameInstance.GameState)
  return _internal_gamestate();
}
inline void GameInstance::unsafe_arena_set_allocated_gamestate(
    ::GameState::GameState* gamestate) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gamestate_);
  }
  gamestate_ = gamestate;
  if (gamestate) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameState.GameInstance.GameState)
}
inline ::GameState::GameState* GameInstance::release_gamestate() {
  
  ::GameState::GameState* temp = gamestate_;
  gamestate_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::GameState::GameState* GameInstance::unsafe_arena_release_gamestate() {
  // @@protoc_insertion_point(field_release:GameState.GameInstance.GameState)
  
  ::GameState::GameState* temp = gamestate_;
  gamestate_ = nullptr;
  return temp;
}
inline ::GameState::GameState* GameInstance::_internal_mutable_gamestate() {
  
  if (gamestate_ == nullptr) {
    auto* p = CreateMaybeMessage<::GameState::GameState>(GetArena());
    gamestate_ = p;
  }
  return gamestate_;
}
inline ::GameState::GameState* GameInstance::mutable_gamestate() {
  // @@protoc_insertion_point(field_mutable:GameState.GameInstance.GameState)
  return _internal_mutable_gamestate();
}
inline void GameInstance::set_allocated_gamestate(::GameState::GameState* gamestate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete gamestate_;
  }
  if (gamestate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(gamestate);
    if (message_arena != submessage_arena) {
      gamestate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gamestate, submessage_arena);
    }
    
  } else {
    
  }
  gamestate_ = gamestate;
  // @@protoc_insertion_point(field_set_allocated:GameState.GameInstance.GameState)
}

// repeated .GameState.Mutation History = 2;
inline int GameInstance::_internal_history_size() const {
  return history_.size();
}
inline int GameInstance::history_size() const {
  return _internal_history_size();
}
inline void GameInstance::clear_history() {
  history_.Clear();
}
inline ::GameState::Mutation* GameInstance::mutable_history(int index) {
  // @@protoc_insertion_point(field_mutable:GameState.GameInstance.History)
  return history_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::Mutation >*
GameInstance::mutable_history() {
  // @@protoc_insertion_point(field_mutable_list:GameState.GameInstance.History)
  return &history_;
}
inline const ::GameState::Mutation& GameInstance::_internal_history(int index) const {
  return history_.Get(index);
}
inline const ::GameState::Mutation& GameInstance::history(int index) const {
  // @@protoc_insertion_point(field_get:GameState.GameInstance.History)
  return _internal_history(index);
}
inline ::GameState::Mutation* GameInstance::_internal_add_history() {
  return history_.Add();
}
inline ::GameState::Mutation* GameInstance::add_history() {
  // @@protoc_insertion_point(field_add:GameState.GameInstance.History)
  return _internal_add_history();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameState::Mutation >&
GameInstance::history() const {
  // @@protoc_insertion_point(field_list:GameState.GameInstance.History)
  return history_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace GameState

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::GameState::Card_Color> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::GameState::Card_Color>() {
  return ::GameState::Card_Color_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_GameState_2eproto
