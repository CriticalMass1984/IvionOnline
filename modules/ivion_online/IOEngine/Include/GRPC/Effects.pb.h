// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Effects.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Effects_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Effects_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3014000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3014000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <GRPC/Types.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Effects_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Effects_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[11]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Effects_2eproto;
namespace Effects {
class CardEffect;
class CardEffectDefaultTypeInternal;
extern CardEffectDefaultTypeInternal _CardEffect_default_instance_;
class CardList;
class CardListDefaultTypeInternal;
extern CardListDefaultTypeInternal _CardList_default_instance_;
class Constant;
class ConstantDefaultTypeInternal;
extern ConstantDefaultTypeInternal _Constant_default_instance_;
class Effect;
class EffectDefaultTypeInternal;
extern EffectDefaultTypeInternal _Effect_default_instance_;
class Filter_Distance;
class Filter_DistanceDefaultTypeInternal;
extern Filter_DistanceDefaultTypeInternal _Filter_Distance_default_instance_;
class Get;
class GetDefaultTypeInternal;
extern GetDefaultTypeInternal _Get_default_instance_;
class Move;
class MoveDefaultTypeInternal;
extern MoveDefaultTypeInternal _Move_default_instance_;
class PlayerList;
class PlayerListDefaultTypeInternal;
extern PlayerListDefaultTypeInternal _PlayerList_default_instance_;
class Select;
class SelectDefaultTypeInternal;
extern SelectDefaultTypeInternal _Select_default_instance_;
class StackVar;
class StackVarDefaultTypeInternal;
extern StackVarDefaultTypeInternal _StackVar_default_instance_;
class TileList;
class TileListDefaultTypeInternal;
extern TileListDefaultTypeInternal _TileList_default_instance_;
}  // namespace Effects
PROTOBUF_NAMESPACE_OPEN
template<> ::Effects::CardEffect* Arena::CreateMaybeMessage<::Effects::CardEffect>(Arena*);
template<> ::Effects::CardList* Arena::CreateMaybeMessage<::Effects::CardList>(Arena*);
template<> ::Effects::Constant* Arena::CreateMaybeMessage<::Effects::Constant>(Arena*);
template<> ::Effects::Effect* Arena::CreateMaybeMessage<::Effects::Effect>(Arena*);
template<> ::Effects::Filter_Distance* Arena::CreateMaybeMessage<::Effects::Filter_Distance>(Arena*);
template<> ::Effects::Get* Arena::CreateMaybeMessage<::Effects::Get>(Arena*);
template<> ::Effects::Move* Arena::CreateMaybeMessage<::Effects::Move>(Arena*);
template<> ::Effects::PlayerList* Arena::CreateMaybeMessage<::Effects::PlayerList>(Arena*);
template<> ::Effects::Select* Arena::CreateMaybeMessage<::Effects::Select>(Arena*);
template<> ::Effects::StackVar* Arena::CreateMaybeMessage<::Effects::StackVar>(Arena*);
template<> ::Effects::TileList* Arena::CreateMaybeMessage<::Effects::TileList>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Effects {

enum Filter_Distance_CompType : int {
  Filter_Distance_CompType_COMP_TYPE_NONE = 0,
  Filter_Distance_CompType_COMP_TYPE_EQUAL = 1,
  Filter_Distance_CompType_COMP_TYPE_LESS_THAN = 2,
  Filter_Distance_CompType_COMP_TYPE_LESS_THAN_EQUAL = 3,
  Filter_Distance_CompType_COMP_TYPE_GREATER_THAN = 4,
  Filter_Distance_CompType_COMP_TYPE_GREATER_THAN_EQUAL = 5,
  Filter_Distance_CompType_Filter_Distance_CompType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Filter_Distance_CompType_Filter_Distance_CompType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Filter_Distance_CompType_IsValid(int value);
constexpr Filter_Distance_CompType Filter_Distance_CompType_CompType_MIN = Filter_Distance_CompType_COMP_TYPE_NONE;
constexpr Filter_Distance_CompType Filter_Distance_CompType_CompType_MAX = Filter_Distance_CompType_COMP_TYPE_GREATER_THAN_EQUAL;
constexpr int Filter_Distance_CompType_CompType_ARRAYSIZE = Filter_Distance_CompType_CompType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Filter_Distance_CompType_descriptor();
template<typename T>
inline const std::string& Filter_Distance_CompType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Filter_Distance_CompType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Filter_Distance_CompType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Filter_Distance_CompType_descriptor(), enum_t_value);
}
inline bool Filter_Distance_CompType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Filter_Distance_CompType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Filter_Distance_CompType>(
    Filter_Distance_CompType_descriptor(), name, value);
}
enum Filter_Distance_GroupType : int {
  Filter_Distance_GroupType_GROUP_TYPE_NONE = 0,
  Filter_Distance_GroupType_GROUP_TYPE_ALL = 1,
  Filter_Distance_GroupType_GROUP_TYPE_AT_LEAST_ONE = 2,
  Filter_Distance_GroupType_GROUP_TYPE_AT_MOST_NONE = 3,
  Filter_Distance_GroupType_Filter_Distance_GroupType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Filter_Distance_GroupType_Filter_Distance_GroupType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Filter_Distance_GroupType_IsValid(int value);
constexpr Filter_Distance_GroupType Filter_Distance_GroupType_GroupType_MIN = Filter_Distance_GroupType_GROUP_TYPE_NONE;
constexpr Filter_Distance_GroupType Filter_Distance_GroupType_GroupType_MAX = Filter_Distance_GroupType_GROUP_TYPE_AT_MOST_NONE;
constexpr int Filter_Distance_GroupType_GroupType_ARRAYSIZE = Filter_Distance_GroupType_GroupType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Filter_Distance_GroupType_descriptor();
template<typename T>
inline const std::string& Filter_Distance_GroupType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Filter_Distance_GroupType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Filter_Distance_GroupType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Filter_Distance_GroupType_descriptor(), enum_t_value);
}
inline bool Filter_Distance_GroupType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Filter_Distance_GroupType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Filter_Distance_GroupType>(
    Filter_Distance_GroupType_descriptor(), name, value);
}
// ===================================================================

class PlayerList PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Effects.PlayerList) */ {
 public:
  inline PlayerList() : PlayerList(nullptr) {}
  virtual ~PlayerList();

  PlayerList(const PlayerList& from);
  PlayerList(PlayerList&& from) noexcept
    : PlayerList() {
    *this = ::std::move(from);
  }

  inline PlayerList& operator=(const PlayerList& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerList& operator=(PlayerList&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PlayerList& default_instance();

  static inline const PlayerList* internal_default_instance() {
    return reinterpret_cast<const PlayerList*>(
               &_PlayerList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(PlayerList& a, PlayerList& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerList* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PlayerList* New() const final {
    return CreateMaybeMessage<PlayerList>(nullptr);
  }

  PlayerList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PlayerList>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PlayerList& from);
  void MergeFrom(const PlayerList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Effects.PlayerList";
  }
  protected:
  explicit PlayerList(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Effects_2eproto);
    return ::descriptor_table_Effects_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayersFieldNumber = 1,
  };
  // repeated .Types.Path Players = 1;
  int players_size() const;
  private:
  int _internal_players_size() const;
  public:
  void clear_players();
  ::Types::Path* mutable_players(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Types::Path >*
      mutable_players();
  private:
  const ::Types::Path& _internal_players(int index) const;
  ::Types::Path* _internal_add_players();
  public:
  const ::Types::Path& players(int index) const;
  ::Types::Path* add_players();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Types::Path >&
      players() const;

  // @@protoc_insertion_point(class_scope:Effects.PlayerList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Types::Path > players_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Effects_2eproto;
};
// -------------------------------------------------------------------

class CardList PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Effects.CardList) */ {
 public:
  inline CardList() : CardList(nullptr) {}
  virtual ~CardList();

  CardList(const CardList& from);
  CardList(CardList&& from) noexcept
    : CardList() {
    *this = ::std::move(from);
  }

  inline CardList& operator=(const CardList& from) {
    CopyFrom(from);
    return *this;
  }
  inline CardList& operator=(CardList&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CardList& default_instance();

  static inline const CardList* internal_default_instance() {
    return reinterpret_cast<const CardList*>(
               &_CardList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CardList& a, CardList& b) {
    a.Swap(&b);
  }
  inline void Swap(CardList* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CardList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CardList* New() const final {
    return CreateMaybeMessage<CardList>(nullptr);
  }

  CardList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CardList>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CardList& from);
  void MergeFrom(const CardList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CardList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Effects.CardList";
  }
  protected:
  explicit CardList(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Effects_2eproto);
    return ::descriptor_table_Effects_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCardsFieldNumber = 1,
  };
  // repeated .Types.Path Cards = 1;
  int cards_size() const;
  private:
  int _internal_cards_size() const;
  public:
  void clear_cards();
  ::Types::Path* mutable_cards(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Types::Path >*
      mutable_cards();
  private:
  const ::Types::Path& _internal_cards(int index) const;
  ::Types::Path* _internal_add_cards();
  public:
  const ::Types::Path& cards(int index) const;
  ::Types::Path* add_cards();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Types::Path >&
      cards() const;

  // @@protoc_insertion_point(class_scope:Effects.CardList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Types::Path > cards_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Effects_2eproto;
};
// -------------------------------------------------------------------

class TileList PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Effects.TileList) */ {
 public:
  inline TileList() : TileList(nullptr) {}
  virtual ~TileList();

  TileList(const TileList& from);
  TileList(TileList&& from) noexcept
    : TileList() {
    *this = ::std::move(from);
  }

  inline TileList& operator=(const TileList& from) {
    CopyFrom(from);
    return *this;
  }
  inline TileList& operator=(TileList&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TileList& default_instance();

  static inline const TileList* internal_default_instance() {
    return reinterpret_cast<const TileList*>(
               &_TileList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(TileList& a, TileList& b) {
    a.Swap(&b);
  }
  inline void Swap(TileList* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TileList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TileList* New() const final {
    return CreateMaybeMessage<TileList>(nullptr);
  }

  TileList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TileList>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TileList& from);
  void MergeFrom(const TileList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TileList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Effects.TileList";
  }
  protected:
  explicit TileList(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Effects_2eproto);
    return ::descriptor_table_Effects_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTilesFieldNumber = 1,
  };
  // repeated .Types.Path Tiles = 1;
  int tiles_size() const;
  private:
  int _internal_tiles_size() const;
  public:
  void clear_tiles();
  ::Types::Path* mutable_tiles(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Types::Path >*
      mutable_tiles();
  private:
  const ::Types::Path& _internal_tiles(int index) const;
  ::Types::Path* _internal_add_tiles();
  public:
  const ::Types::Path& tiles(int index) const;
  ::Types::Path* add_tiles();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Types::Path >&
      tiles() const;

  // @@protoc_insertion_point(class_scope:Effects.TileList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Types::Path > tiles_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Effects_2eproto;
};
// -------------------------------------------------------------------

class StackVar PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Effects.StackVar) */ {
 public:
  inline StackVar() : StackVar(nullptr) {}
  virtual ~StackVar();

  StackVar(const StackVar& from);
  StackVar(StackVar&& from) noexcept
    : StackVar() {
    *this = ::std::move(from);
  }

  inline StackVar& operator=(const StackVar& from) {
    CopyFrom(from);
    return *this;
  }
  inline StackVar& operator=(StackVar&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StackVar& default_instance();

  enum EntityCase {
    kPlayers = 1,
    kCards = 2,
    kTiles = 3,
    kIntegerRef = 4,
    kVec2IRef = 5,
    kInteger = 6,
    kVec2I = 7,
    ENTITY_NOT_SET = 0,
  };

  static inline const StackVar* internal_default_instance() {
    return reinterpret_cast<const StackVar*>(
               &_StackVar_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(StackVar& a, StackVar& b) {
    a.Swap(&b);
  }
  inline void Swap(StackVar* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StackVar* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StackVar* New() const final {
    return CreateMaybeMessage<StackVar>(nullptr);
  }

  StackVar* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StackVar>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StackVar& from);
  void MergeFrom(const StackVar& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StackVar* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Effects.StackVar";
  }
  protected:
  explicit StackVar(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Effects_2eproto);
    return ::descriptor_table_Effects_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayersFieldNumber = 1,
    kCardsFieldNumber = 2,
    kTilesFieldNumber = 3,
    kIntegerRefFieldNumber = 4,
    kVec2IRefFieldNumber = 5,
    kIntegerFieldNumber = 6,
    kVec2IFieldNumber = 7,
  };
  // .Effects.PlayerList Players = 1;
  bool has_players() const;
  private:
  bool _internal_has_players() const;
  public:
  void clear_players();
  const ::Effects::PlayerList& players() const;
  ::Effects::PlayerList* release_players();
  ::Effects::PlayerList* mutable_players();
  void set_allocated_players(::Effects::PlayerList* players);
  private:
  const ::Effects::PlayerList& _internal_players() const;
  ::Effects::PlayerList* _internal_mutable_players();
  public:
  void unsafe_arena_set_allocated_players(
      ::Effects::PlayerList* players);
  ::Effects::PlayerList* unsafe_arena_release_players();

  // .Effects.CardList Cards = 2;
  bool has_cards() const;
  private:
  bool _internal_has_cards() const;
  public:
  void clear_cards();
  const ::Effects::CardList& cards() const;
  ::Effects::CardList* release_cards();
  ::Effects::CardList* mutable_cards();
  void set_allocated_cards(::Effects::CardList* cards);
  private:
  const ::Effects::CardList& _internal_cards() const;
  ::Effects::CardList* _internal_mutable_cards();
  public:
  void unsafe_arena_set_allocated_cards(
      ::Effects::CardList* cards);
  ::Effects::CardList* unsafe_arena_release_cards();

  // .Effects.TileList Tiles = 3;
  bool has_tiles() const;
  private:
  bool _internal_has_tiles() const;
  public:
  void clear_tiles();
  const ::Effects::TileList& tiles() const;
  ::Effects::TileList* release_tiles();
  ::Effects::TileList* mutable_tiles();
  void set_allocated_tiles(::Effects::TileList* tiles);
  private:
  const ::Effects::TileList& _internal_tiles() const;
  ::Effects::TileList* _internal_mutable_tiles();
  public:
  void unsafe_arena_set_allocated_tiles(
      ::Effects::TileList* tiles);
  ::Effects::TileList* unsafe_arena_release_tiles();

  // .Types.Path IntegerRef = 4;
  bool has_integerref() const;
  private:
  bool _internal_has_integerref() const;
  public:
  void clear_integerref();
  const ::Types::Path& integerref() const;
  ::Types::Path* release_integerref();
  ::Types::Path* mutable_integerref();
  void set_allocated_integerref(::Types::Path* integerref);
  private:
  const ::Types::Path& _internal_integerref() const;
  ::Types::Path* _internal_mutable_integerref();
  public:
  void unsafe_arena_set_allocated_integerref(
      ::Types::Path* integerref);
  ::Types::Path* unsafe_arena_release_integerref();

  // .Types.Path Vec2iRef = 5;
  bool has_vec2iref() const;
  private:
  bool _internal_has_vec2iref() const;
  public:
  void clear_vec2iref();
  const ::Types::Path& vec2iref() const;
  ::Types::Path* release_vec2iref();
  ::Types::Path* mutable_vec2iref();
  void set_allocated_vec2iref(::Types::Path* vec2iref);
  private:
  const ::Types::Path& _internal_vec2iref() const;
  ::Types::Path* _internal_mutable_vec2iref();
  public:
  void unsafe_arena_set_allocated_vec2iref(
      ::Types::Path* vec2iref);
  ::Types::Path* unsafe_arena_release_vec2iref();

  // .Types.IntegerValue Integer = 6;
  bool has_integer() const;
  private:
  bool _internal_has_integer() const;
  public:
  void clear_integer();
  const ::Types::IntegerValue& integer() const;
  ::Types::IntegerValue* release_integer();
  ::Types::IntegerValue* mutable_integer();
  void set_allocated_integer(::Types::IntegerValue* integer);
  private:
  const ::Types::IntegerValue& _internal_integer() const;
  ::Types::IntegerValue* _internal_mutable_integer();
  public:
  void unsafe_arena_set_allocated_integer(
      ::Types::IntegerValue* integer);
  ::Types::IntegerValue* unsafe_arena_release_integer();

  // .Types.Vec2iValue Vec2i = 7;
  bool has_vec2i() const;
  private:
  bool _internal_has_vec2i() const;
  public:
  void clear_vec2i();
  const ::Types::Vec2iValue& vec2i() const;
  ::Types::Vec2iValue* release_vec2i();
  ::Types::Vec2iValue* mutable_vec2i();
  void set_allocated_vec2i(::Types::Vec2iValue* vec2i);
  private:
  const ::Types::Vec2iValue& _internal_vec2i() const;
  ::Types::Vec2iValue* _internal_mutable_vec2i();
  public:
  void unsafe_arena_set_allocated_vec2i(
      ::Types::Vec2iValue* vec2i);
  ::Types::Vec2iValue* unsafe_arena_release_vec2i();

  void clear_entity();
  EntityCase entity_case() const;
  // @@protoc_insertion_point(class_scope:Effects.StackVar)
 private:
  class _Internal;
  void set_has_players();
  void set_has_cards();
  void set_has_tiles();
  void set_has_integerref();
  void set_has_vec2iref();
  void set_has_integer();
  void set_has_vec2i();

  inline bool has_entity() const;
  inline void clear_has_entity();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union EntityUnion {
    EntityUnion() {}
    ::Effects::PlayerList* players_;
    ::Effects::CardList* cards_;
    ::Effects::TileList* tiles_;
    ::Types::Path* integerref_;
    ::Types::Path* vec2iref_;
    ::Types::IntegerValue* integer_;
    ::Types::Vec2iValue* vec2i_;
  } entity_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_Effects_2eproto;
};
// -------------------------------------------------------------------

class Constant PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Effects.Constant) */ {
 public:
  inline Constant() : Constant(nullptr) {}
  virtual ~Constant();

  Constant(const Constant& from);
  Constant(Constant&& from) noexcept
    : Constant() {
    *this = ::std::move(from);
  }

  inline Constant& operator=(const Constant& from) {
    CopyFrom(from);
    return *this;
  }
  inline Constant& operator=(Constant&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Constant& default_instance();

  static inline const Constant* internal_default_instance() {
    return reinterpret_cast<const Constant*>(
               &_Constant_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Constant& a, Constant& b) {
    a.Swap(&b);
  }
  inline void Swap(Constant* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Constant* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Constant* New() const final {
    return CreateMaybeMessage<Constant>(nullptr);
  }

  Constant* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Constant>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Constant& from);
  void MergeFrom(const Constant& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Constant* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Effects.Constant";
  }
  protected:
  explicit Constant(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Effects_2eproto);
    return ::descriptor_table_Effects_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kResultFieldNumber = 1,
  };
  // string Name = 2;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .Effects.StackVar Result = 1;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::Effects::StackVar& result() const;
  ::Effects::StackVar* release_result();
  ::Effects::StackVar* mutable_result();
  void set_allocated_result(::Effects::StackVar* result);
  private:
  const ::Effects::StackVar& _internal_result() const;
  ::Effects::StackVar* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::Effects::StackVar* result);
  ::Effects::StackVar* unsafe_arena_release_result();

  // @@protoc_insertion_point(class_scope:Effects.Constant)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::Effects::StackVar* result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Effects_2eproto;
};
// -------------------------------------------------------------------

class Get PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Effects.Get) */ {
 public:
  inline Get() : Get(nullptr) {}
  virtual ~Get();

  Get(const Get& from);
  Get(Get&& from) noexcept
    : Get() {
    *this = ::std::move(from);
  }

  inline Get& operator=(const Get& from) {
    CopyFrom(from);
    return *this;
  }
  inline Get& operator=(Get&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Get& default_instance();

  static inline const Get* internal_default_instance() {
    return reinterpret_cast<const Get*>(
               &_Get_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Get& a, Get& b) {
    a.Swap(&b);
  }
  inline void Swap(Get* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Get* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Get* New() const final {
    return CreateMaybeMessage<Get>(nullptr);
  }

  Get* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Get>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Get& from);
  void MergeFrom(const Get& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Get* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Effects.Get";
  }
  protected:
  explicit Get(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Effects_2eproto);
    return ::descriptor_table_Effects_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 3,
    kResultFieldNumber = 1,
    kSourceFieldNumber = 2,
  };
  // string Name = 3;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .Effects.StackVar Result = 1;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::Effects::StackVar& result() const;
  ::Effects::StackVar* release_result();
  ::Effects::StackVar* mutable_result();
  void set_allocated_result(::Effects::StackVar* result);
  private:
  const ::Effects::StackVar& _internal_result() const;
  ::Effects::StackVar* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::Effects::StackVar* result);
  ::Effects::StackVar* unsafe_arena_release_result();

  // .Types.Path Source = 2;
  bool has_source() const;
  private:
  bool _internal_has_source() const;
  public:
  void clear_source();
  const ::Types::Path& source() const;
  ::Types::Path* release_source();
  ::Types::Path* mutable_source();
  void set_allocated_source(::Types::Path* source);
  private:
  const ::Types::Path& _internal_source() const;
  ::Types::Path* _internal_mutable_source();
  public:
  void unsafe_arena_set_allocated_source(
      ::Types::Path* source);
  ::Types::Path* unsafe_arena_release_source();

  // @@protoc_insertion_point(class_scope:Effects.Get)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::Effects::StackVar* result_;
  ::Types::Path* source_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Effects_2eproto;
};
// -------------------------------------------------------------------

class Filter_Distance PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Effects.Filter_Distance) */ {
 public:
  inline Filter_Distance() : Filter_Distance(nullptr) {}
  virtual ~Filter_Distance();

  Filter_Distance(const Filter_Distance& from);
  Filter_Distance(Filter_Distance&& from) noexcept
    : Filter_Distance() {
    *this = ::std::move(from);
  }

  inline Filter_Distance& operator=(const Filter_Distance& from) {
    CopyFrom(from);
    return *this;
  }
  inline Filter_Distance& operator=(Filter_Distance&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Filter_Distance& default_instance();

  static inline const Filter_Distance* internal_default_instance() {
    return reinterpret_cast<const Filter_Distance*>(
               &_Filter_Distance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Filter_Distance& a, Filter_Distance& b) {
    a.Swap(&b);
  }
  inline void Swap(Filter_Distance* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Filter_Distance* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Filter_Distance* New() const final {
    return CreateMaybeMessage<Filter_Distance>(nullptr);
  }

  Filter_Distance* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Filter_Distance>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Filter_Distance& from);
  void MergeFrom(const Filter_Distance& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Filter_Distance* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Effects.Filter_Distance";
  }
  protected:
  explicit Filter_Distance(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Effects_2eproto);
    return ::descriptor_table_Effects_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Filter_Distance_CompType CompType;
  static constexpr CompType COMP_TYPE_NONE =
    Filter_Distance_CompType_COMP_TYPE_NONE;
  static constexpr CompType COMP_TYPE_EQUAL =
    Filter_Distance_CompType_COMP_TYPE_EQUAL;
  static constexpr CompType COMP_TYPE_LESS_THAN =
    Filter_Distance_CompType_COMP_TYPE_LESS_THAN;
  static constexpr CompType COMP_TYPE_LESS_THAN_EQUAL =
    Filter_Distance_CompType_COMP_TYPE_LESS_THAN_EQUAL;
  static constexpr CompType COMP_TYPE_GREATER_THAN =
    Filter_Distance_CompType_COMP_TYPE_GREATER_THAN;
  static constexpr CompType COMP_TYPE_GREATER_THAN_EQUAL =
    Filter_Distance_CompType_COMP_TYPE_GREATER_THAN_EQUAL;
  static inline bool CompType_IsValid(int value) {
    return Filter_Distance_CompType_IsValid(value);
  }
  static constexpr CompType CompType_MIN =
    Filter_Distance_CompType_CompType_MIN;
  static constexpr CompType CompType_MAX =
    Filter_Distance_CompType_CompType_MAX;
  static constexpr int CompType_ARRAYSIZE =
    Filter_Distance_CompType_CompType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  CompType_descriptor() {
    return Filter_Distance_CompType_descriptor();
  }
  template<typename T>
  static inline const std::string& CompType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, CompType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function CompType_Name.");
    return Filter_Distance_CompType_Name(enum_t_value);
  }
  static inline bool CompType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      CompType* value) {
    return Filter_Distance_CompType_Parse(name, value);
  }

  typedef Filter_Distance_GroupType GroupType;
  static constexpr GroupType GROUP_TYPE_NONE =
    Filter_Distance_GroupType_GROUP_TYPE_NONE;
  static constexpr GroupType GROUP_TYPE_ALL =
    Filter_Distance_GroupType_GROUP_TYPE_ALL;
  static constexpr GroupType GROUP_TYPE_AT_LEAST_ONE =
    Filter_Distance_GroupType_GROUP_TYPE_AT_LEAST_ONE;
  static constexpr GroupType GROUP_TYPE_AT_MOST_NONE =
    Filter_Distance_GroupType_GROUP_TYPE_AT_MOST_NONE;
  static inline bool GroupType_IsValid(int value) {
    return Filter_Distance_GroupType_IsValid(value);
  }
  static constexpr GroupType GroupType_MIN =
    Filter_Distance_GroupType_GroupType_MIN;
  static constexpr GroupType GroupType_MAX =
    Filter_Distance_GroupType_GroupType_MAX;
  static constexpr int GroupType_ARRAYSIZE =
    Filter_Distance_GroupType_GroupType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  GroupType_descriptor() {
    return Filter_Distance_GroupType_descriptor();
  }
  template<typename T>
  static inline const std::string& GroupType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, GroupType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function GroupType_Name.");
    return Filter_Distance_GroupType_Name(enum_t_value);
  }
  static inline bool GroupType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      GroupType* value) {
    return Filter_Distance_GroupType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSourceFieldNumber = 1,
    kFromFieldNumber = 2,
    kDistanceFieldNumber = 3,
    kComparisonFieldNumber = 4,
    kLogicalUnionFieldNumber = 5,
  };
  // .Types.Path Source = 1;
  bool has_source() const;
  private:
  bool _internal_has_source() const;
  public:
  void clear_source();
  const ::Types::Path& source() const;
  ::Types::Path* release_source();
  ::Types::Path* mutable_source();
  void set_allocated_source(::Types::Path* source);
  private:
  const ::Types::Path& _internal_source() const;
  ::Types::Path* _internal_mutable_source();
  public:
  void unsafe_arena_set_allocated_source(
      ::Types::Path* source);
  ::Types::Path* unsafe_arena_release_source();

  // .Types.Path From = 2;
  bool has_from() const;
  private:
  bool _internal_has_from() const;
  public:
  void clear_from();
  const ::Types::Path& from() const;
  ::Types::Path* release_from();
  ::Types::Path* mutable_from();
  void set_allocated_from(::Types::Path* from);
  private:
  const ::Types::Path& _internal_from() const;
  ::Types::Path* _internal_mutable_from();
  public:
  void unsafe_arena_set_allocated_from(
      ::Types::Path* from);
  ::Types::Path* unsafe_arena_release_from();

  // .Types.Path Distance = 3;
  bool has_distance() const;
  private:
  bool _internal_has_distance() const;
  public:
  void clear_distance();
  const ::Types::Path& distance() const;
  ::Types::Path* release_distance();
  ::Types::Path* mutable_distance();
  void set_allocated_distance(::Types::Path* distance);
  private:
  const ::Types::Path& _internal_distance() const;
  ::Types::Path* _internal_mutable_distance();
  public:
  void unsafe_arena_set_allocated_distance(
      ::Types::Path* distance);
  ::Types::Path* unsafe_arena_release_distance();

  // .Effects.Filter_Distance.CompType Comparison = 4;
  void clear_comparison();
  ::Effects::Filter_Distance_CompType comparison() const;
  void set_comparison(::Effects::Filter_Distance_CompType value);
  private:
  ::Effects::Filter_Distance_CompType _internal_comparison() const;
  void _internal_set_comparison(::Effects::Filter_Distance_CompType value);
  public:

  // .Effects.Filter_Distance.GroupType LogicalUnion = 5;
  void clear_logicalunion();
  ::Effects::Filter_Distance_GroupType logicalunion() const;
  void set_logicalunion(::Effects::Filter_Distance_GroupType value);
  private:
  ::Effects::Filter_Distance_GroupType _internal_logicalunion() const;
  void _internal_set_logicalunion(::Effects::Filter_Distance_GroupType value);
  public:

  // @@protoc_insertion_point(class_scope:Effects.Filter_Distance)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Types::Path* source_;
  ::Types::Path* from_;
  ::Types::Path* distance_;
  int comparison_;
  int logicalunion_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Effects_2eproto;
};
// -------------------------------------------------------------------

class Select PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Effects.Select) */ {
 public:
  inline Select() : Select(nullptr) {}
  virtual ~Select();

  Select(const Select& from);
  Select(Select&& from) noexcept
    : Select() {
    *this = ::std::move(from);
  }

  inline Select& operator=(const Select& from) {
    CopyFrom(from);
    return *this;
  }
  inline Select& operator=(Select&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Select& default_instance();

  static inline const Select* internal_default_instance() {
    return reinterpret_cast<const Select*>(
               &_Select_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Select& a, Select& b) {
    a.Swap(&b);
  }
  inline void Swap(Select* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Select* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Select* New() const final {
    return CreateMaybeMessage<Select>(nullptr);
  }

  Select* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Select>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Select& from);
  void MergeFrom(const Select& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Select* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Effects.Select";
  }
  protected:
  explicit Select(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Effects_2eproto);
    return ::descriptor_table_Effects_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourceFieldNumber = 1,
    kNumberFieldNumber = 2,
    kUpToFieldNumber = 3,
    kTargetsFieldNumber = 4,
  };
  // .Types.Path Source = 1;
  bool has_source() const;
  private:
  bool _internal_has_source() const;
  public:
  void clear_source();
  const ::Types::Path& source() const;
  ::Types::Path* release_source();
  ::Types::Path* mutable_source();
  void set_allocated_source(::Types::Path* source);
  private:
  const ::Types::Path& _internal_source() const;
  ::Types::Path* _internal_mutable_source();
  public:
  void unsafe_arena_set_allocated_source(
      ::Types::Path* source);
  ::Types::Path* unsafe_arena_release_source();

  // .Types.Path Number = 2;
  bool has_number() const;
  private:
  bool _internal_has_number() const;
  public:
  void clear_number();
  const ::Types::Path& number() const;
  ::Types::Path* release_number();
  ::Types::Path* mutable_number();
  void set_allocated_number(::Types::Path* number);
  private:
  const ::Types::Path& _internal_number() const;
  ::Types::Path* _internal_mutable_number();
  public:
  void unsafe_arena_set_allocated_number(
      ::Types::Path* number);
  ::Types::Path* unsafe_arena_release_number();

  // bool UpTo = 3;
  void clear_upto();
  bool upto() const;
  void set_upto(bool value);
  private:
  bool _internal_upto() const;
  void _internal_set_upto(bool value);
  public:

  // bool Targets = 4;
  void clear_targets();
  bool targets() const;
  void set_targets(bool value);
  private:
  bool _internal_targets() const;
  void _internal_set_targets(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Effects.Select)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Types::Path* source_;
  ::Types::Path* number_;
  bool upto_;
  bool targets_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Effects_2eproto;
};
// -------------------------------------------------------------------

class Move PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Effects.Move) */ {
 public:
  inline Move() : Move(nullptr) {}
  virtual ~Move();

  Move(const Move& from);
  Move(Move&& from) noexcept
    : Move() {
    *this = ::std::move(from);
  }

  inline Move& operator=(const Move& from) {
    CopyFrom(from);
    return *this;
  }
  inline Move& operator=(Move&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Move& default_instance();

  static inline const Move* internal_default_instance() {
    return reinterpret_cast<const Move*>(
               &_Move_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Move& a, Move& b) {
    a.Swap(&b);
  }
  inline void Swap(Move* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Move* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Move* New() const final {
    return CreateMaybeMessage<Move>(nullptr);
  }

  Move* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Move>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Move& from);
  void MergeFrom(const Move& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Move* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Effects.Move";
  }
  protected:
  explicit Move(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Effects_2eproto);
    return ::descriptor_table_Effects_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDestinationFieldNumber = 1,
    kPlayerFieldNumber = 2,
  };
  // .Types.Path Destination = 1;
  bool has_destination() const;
  private:
  bool _internal_has_destination() const;
  public:
  void clear_destination();
  const ::Types::Path& destination() const;
  ::Types::Path* release_destination();
  ::Types::Path* mutable_destination();
  void set_allocated_destination(::Types::Path* destination);
  private:
  const ::Types::Path& _internal_destination() const;
  ::Types::Path* _internal_mutable_destination();
  public:
  void unsafe_arena_set_allocated_destination(
      ::Types::Path* destination);
  ::Types::Path* unsafe_arena_release_destination();

  // .Types.Path Player = 2;
  bool has_player() const;
  private:
  bool _internal_has_player() const;
  public:
  void clear_player();
  const ::Types::Path& player() const;
  ::Types::Path* release_player();
  ::Types::Path* mutable_player();
  void set_allocated_player(::Types::Path* player);
  private:
  const ::Types::Path& _internal_player() const;
  ::Types::Path* _internal_mutable_player();
  public:
  void unsafe_arena_set_allocated_player(
      ::Types::Path* player);
  ::Types::Path* unsafe_arena_release_player();

  // @@protoc_insertion_point(class_scope:Effects.Move)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Types::Path* destination_;
  ::Types::Path* player_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Effects_2eproto;
};
// -------------------------------------------------------------------

class Effect PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Effects.Effect) */ {
 public:
  inline Effect() : Effect(nullptr) {}
  virtual ~Effect();

  Effect(const Effect& from);
  Effect(Effect&& from) noexcept
    : Effect() {
    *this = ::std::move(from);
  }

  inline Effect& operator=(const Effect& from) {
    CopyFrom(from);
    return *this;
  }
  inline Effect& operator=(Effect&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Effect& default_instance();

  enum EffectCase {
    kGet = 1,
    kConstant = 2,
    kFilterDistance = 3,
    kSelect = 4,
    kMove = 5,
    EFFECT_NOT_SET = 0,
  };

  static inline const Effect* internal_default_instance() {
    return reinterpret_cast<const Effect*>(
               &_Effect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Effect& a, Effect& b) {
    a.Swap(&b);
  }
  inline void Swap(Effect* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Effect* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Effect* New() const final {
    return CreateMaybeMessage<Effect>(nullptr);
  }

  Effect* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Effect>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Effect& from);
  void MergeFrom(const Effect& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Effect* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Effects.Effect";
  }
  protected:
  explicit Effect(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Effects_2eproto);
    return ::descriptor_table_Effects_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGetFieldNumber = 1,
    kConstantFieldNumber = 2,
    kFilterDistanceFieldNumber = 3,
    kSelectFieldNumber = 4,
    kMoveFieldNumber = 5,
  };
  // .Effects.Get Get = 1;
  bool has_get() const;
  private:
  bool _internal_has_get() const;
  public:
  void clear_get();
  const ::Effects::Get& get() const;
  ::Effects::Get* release_get();
  ::Effects::Get* mutable_get();
  void set_allocated_get(::Effects::Get* get);
  private:
  const ::Effects::Get& _internal_get() const;
  ::Effects::Get* _internal_mutable_get();
  public:
  void unsafe_arena_set_allocated_get(
      ::Effects::Get* get);
  ::Effects::Get* unsafe_arena_release_get();

  // .Effects.Constant Constant = 2;
  bool has_constant() const;
  private:
  bool _internal_has_constant() const;
  public:
  void clear_constant();
  const ::Effects::Constant& constant() const;
  ::Effects::Constant* release_constant();
  ::Effects::Constant* mutable_constant();
  void set_allocated_constant(::Effects::Constant* constant);
  private:
  const ::Effects::Constant& _internal_constant() const;
  ::Effects::Constant* _internal_mutable_constant();
  public:
  void unsafe_arena_set_allocated_constant(
      ::Effects::Constant* constant);
  ::Effects::Constant* unsafe_arena_release_constant();

  // .Effects.Filter_Distance Filter_Distance = 3;
  bool has_filter_distance() const;
  private:
  bool _internal_has_filter_distance() const;
  public:
  void clear_filter_distance();
  const ::Effects::Filter_Distance& filter_distance() const;
  ::Effects::Filter_Distance* release_filter_distance();
  ::Effects::Filter_Distance* mutable_filter_distance();
  void set_allocated_filter_distance(::Effects::Filter_Distance* filter_distance);
  private:
  const ::Effects::Filter_Distance& _internal_filter_distance() const;
  ::Effects::Filter_Distance* _internal_mutable_filter_distance();
  public:
  void unsafe_arena_set_allocated_filter_distance(
      ::Effects::Filter_Distance* filter_distance);
  ::Effects::Filter_Distance* unsafe_arena_release_filter_distance();

  // .Effects.Select Select = 4;
  bool has_select() const;
  private:
  bool _internal_has_select() const;
  public:
  void clear_select();
  const ::Effects::Select& select() const;
  ::Effects::Select* release_select();
  ::Effects::Select* mutable_select();
  void set_allocated_select(::Effects::Select* select);
  private:
  const ::Effects::Select& _internal_select() const;
  ::Effects::Select* _internal_mutable_select();
  public:
  void unsafe_arena_set_allocated_select(
      ::Effects::Select* select);
  ::Effects::Select* unsafe_arena_release_select();

  // .Effects.Move Move = 5;
  bool has_move() const;
  private:
  bool _internal_has_move() const;
  public:
  void clear_move();
  const ::Effects::Move& move() const;
  ::Effects::Move* release_move();
  ::Effects::Move* mutable_move();
  void set_allocated_move(::Effects::Move* move);
  private:
  const ::Effects::Move& _internal_move() const;
  ::Effects::Move* _internal_mutable_move();
  public:
  void unsafe_arena_set_allocated_move(
      ::Effects::Move* move);
  ::Effects::Move* unsafe_arena_release_move();

  void clear_effect();
  EffectCase effect_case() const;
  // @@protoc_insertion_point(class_scope:Effects.Effect)
 private:
  class _Internal;
  void set_has_get();
  void set_has_constant();
  void set_has_filter_distance();
  void set_has_select();
  void set_has_move();

  inline bool has_effect() const;
  inline void clear_has_effect();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union EffectUnion {
    EffectUnion() {}
    ::Effects::Get* get_;
    ::Effects::Constant* constant_;
    ::Effects::Filter_Distance* filter_distance_;
    ::Effects::Select* select_;
    ::Effects::Move* move_;
  } effect_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_Effects_2eproto;
};
// -------------------------------------------------------------------

class CardEffect PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Effects.CardEffect) */ {
 public:
  inline CardEffect() : CardEffect(nullptr) {}
  virtual ~CardEffect();

  CardEffect(const CardEffect& from);
  CardEffect(CardEffect&& from) noexcept
    : CardEffect() {
    *this = ::std::move(from);
  }

  inline CardEffect& operator=(const CardEffect& from) {
    CopyFrom(from);
    return *this;
  }
  inline CardEffect& operator=(CardEffect&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CardEffect& default_instance();

  static inline const CardEffect* internal_default_instance() {
    return reinterpret_cast<const CardEffect*>(
               &_CardEffect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CardEffect& a, CardEffect& b) {
    a.Swap(&b);
  }
  inline void Swap(CardEffect* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CardEffect* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CardEffect* New() const final {
    return CreateMaybeMessage<CardEffect>(nullptr);
  }

  CardEffect* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CardEffect>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CardEffect& from);
  void MergeFrom(const CardEffect& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CardEffect* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Effects.CardEffect";
  }
  protected:
  explicit CardEffect(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Effects_2eproto);
    return ::descriptor_table_Effects_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEffectsFieldNumber = 1,
  };
  // repeated .Effects.Effect Effects = 1;
  int effects_size() const;
  private:
  int _internal_effects_size() const;
  public:
  void clear_effects();
  ::Effects::Effect* mutable_effects(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Effects::Effect >*
      mutable_effects();
  private:
  const ::Effects::Effect& _internal_effects(int index) const;
  ::Effects::Effect* _internal_add_effects();
  public:
  const ::Effects::Effect& effects(int index) const;
  ::Effects::Effect* add_effects();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Effects::Effect >&
      effects() const;

  // @@protoc_insertion_point(class_scope:Effects.CardEffect)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Effects::Effect > effects_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Effects_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PlayerList

// repeated .Types.Path Players = 1;
inline int PlayerList::_internal_players_size() const {
  return players_.size();
}
inline int PlayerList::players_size() const {
  return _internal_players_size();
}
inline ::Types::Path* PlayerList::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:Effects.PlayerList.Players)
  return players_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Types::Path >*
PlayerList::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:Effects.PlayerList.Players)
  return &players_;
}
inline const ::Types::Path& PlayerList::_internal_players(int index) const {
  return players_.Get(index);
}
inline const ::Types::Path& PlayerList::players(int index) const {
  // @@protoc_insertion_point(field_get:Effects.PlayerList.Players)
  return _internal_players(index);
}
inline ::Types::Path* PlayerList::_internal_add_players() {
  return players_.Add();
}
inline ::Types::Path* PlayerList::add_players() {
  // @@protoc_insertion_point(field_add:Effects.PlayerList.Players)
  return _internal_add_players();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Types::Path >&
PlayerList::players() const {
  // @@protoc_insertion_point(field_list:Effects.PlayerList.Players)
  return players_;
}

// -------------------------------------------------------------------

// CardList

// repeated .Types.Path Cards = 1;
inline int CardList::_internal_cards_size() const {
  return cards_.size();
}
inline int CardList::cards_size() const {
  return _internal_cards_size();
}
inline ::Types::Path* CardList::mutable_cards(int index) {
  // @@protoc_insertion_point(field_mutable:Effects.CardList.Cards)
  return cards_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Types::Path >*
CardList::mutable_cards() {
  // @@protoc_insertion_point(field_mutable_list:Effects.CardList.Cards)
  return &cards_;
}
inline const ::Types::Path& CardList::_internal_cards(int index) const {
  return cards_.Get(index);
}
inline const ::Types::Path& CardList::cards(int index) const {
  // @@protoc_insertion_point(field_get:Effects.CardList.Cards)
  return _internal_cards(index);
}
inline ::Types::Path* CardList::_internal_add_cards() {
  return cards_.Add();
}
inline ::Types::Path* CardList::add_cards() {
  // @@protoc_insertion_point(field_add:Effects.CardList.Cards)
  return _internal_add_cards();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Types::Path >&
CardList::cards() const {
  // @@protoc_insertion_point(field_list:Effects.CardList.Cards)
  return cards_;
}

// -------------------------------------------------------------------

// TileList

// repeated .Types.Path Tiles = 1;
inline int TileList::_internal_tiles_size() const {
  return tiles_.size();
}
inline int TileList::tiles_size() const {
  return _internal_tiles_size();
}
inline ::Types::Path* TileList::mutable_tiles(int index) {
  // @@protoc_insertion_point(field_mutable:Effects.TileList.Tiles)
  return tiles_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Types::Path >*
TileList::mutable_tiles() {
  // @@protoc_insertion_point(field_mutable_list:Effects.TileList.Tiles)
  return &tiles_;
}
inline const ::Types::Path& TileList::_internal_tiles(int index) const {
  return tiles_.Get(index);
}
inline const ::Types::Path& TileList::tiles(int index) const {
  // @@protoc_insertion_point(field_get:Effects.TileList.Tiles)
  return _internal_tiles(index);
}
inline ::Types::Path* TileList::_internal_add_tiles() {
  return tiles_.Add();
}
inline ::Types::Path* TileList::add_tiles() {
  // @@protoc_insertion_point(field_add:Effects.TileList.Tiles)
  return _internal_add_tiles();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Types::Path >&
TileList::tiles() const {
  // @@protoc_insertion_point(field_list:Effects.TileList.Tiles)
  return tiles_;
}

// -------------------------------------------------------------------

// StackVar

// .Effects.PlayerList Players = 1;
inline bool StackVar::_internal_has_players() const {
  return entity_case() == kPlayers;
}
inline bool StackVar::has_players() const {
  return _internal_has_players();
}
inline void StackVar::set_has_players() {
  _oneof_case_[0] = kPlayers;
}
inline void StackVar::clear_players() {
  if (_internal_has_players()) {
    if (GetArena() == nullptr) {
      delete entity_.players_;
    }
    clear_has_entity();
  }
}
inline ::Effects::PlayerList* StackVar::release_players() {
  // @@protoc_insertion_point(field_release:Effects.StackVar.Players)
  if (_internal_has_players()) {
    clear_has_entity();
      ::Effects::PlayerList* temp = entity_.players_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    entity_.players_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Effects::PlayerList& StackVar::_internal_players() const {
  return _internal_has_players()
      ? *entity_.players_
      : reinterpret_cast< ::Effects::PlayerList&>(::Effects::_PlayerList_default_instance_);
}
inline const ::Effects::PlayerList& StackVar::players() const {
  // @@protoc_insertion_point(field_get:Effects.StackVar.Players)
  return _internal_players();
}
inline ::Effects::PlayerList* StackVar::unsafe_arena_release_players() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Effects.StackVar.Players)
  if (_internal_has_players()) {
    clear_has_entity();
    ::Effects::PlayerList* temp = entity_.players_;
    entity_.players_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StackVar::unsafe_arena_set_allocated_players(::Effects::PlayerList* players) {
  clear_entity();
  if (players) {
    set_has_players();
    entity_.players_ = players;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Effects.StackVar.Players)
}
inline ::Effects::PlayerList* StackVar::_internal_mutable_players() {
  if (!_internal_has_players()) {
    clear_entity();
    set_has_players();
    entity_.players_ = CreateMaybeMessage< ::Effects::PlayerList >(GetArena());
  }
  return entity_.players_;
}
inline ::Effects::PlayerList* StackVar::mutable_players() {
  // @@protoc_insertion_point(field_mutable:Effects.StackVar.Players)
  return _internal_mutable_players();
}

// .Effects.CardList Cards = 2;
inline bool StackVar::_internal_has_cards() const {
  return entity_case() == kCards;
}
inline bool StackVar::has_cards() const {
  return _internal_has_cards();
}
inline void StackVar::set_has_cards() {
  _oneof_case_[0] = kCards;
}
inline void StackVar::clear_cards() {
  if (_internal_has_cards()) {
    if (GetArena() == nullptr) {
      delete entity_.cards_;
    }
    clear_has_entity();
  }
}
inline ::Effects::CardList* StackVar::release_cards() {
  // @@protoc_insertion_point(field_release:Effects.StackVar.Cards)
  if (_internal_has_cards()) {
    clear_has_entity();
      ::Effects::CardList* temp = entity_.cards_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    entity_.cards_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Effects::CardList& StackVar::_internal_cards() const {
  return _internal_has_cards()
      ? *entity_.cards_
      : reinterpret_cast< ::Effects::CardList&>(::Effects::_CardList_default_instance_);
}
inline const ::Effects::CardList& StackVar::cards() const {
  // @@protoc_insertion_point(field_get:Effects.StackVar.Cards)
  return _internal_cards();
}
inline ::Effects::CardList* StackVar::unsafe_arena_release_cards() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Effects.StackVar.Cards)
  if (_internal_has_cards()) {
    clear_has_entity();
    ::Effects::CardList* temp = entity_.cards_;
    entity_.cards_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StackVar::unsafe_arena_set_allocated_cards(::Effects::CardList* cards) {
  clear_entity();
  if (cards) {
    set_has_cards();
    entity_.cards_ = cards;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Effects.StackVar.Cards)
}
inline ::Effects::CardList* StackVar::_internal_mutable_cards() {
  if (!_internal_has_cards()) {
    clear_entity();
    set_has_cards();
    entity_.cards_ = CreateMaybeMessage< ::Effects::CardList >(GetArena());
  }
  return entity_.cards_;
}
inline ::Effects::CardList* StackVar::mutable_cards() {
  // @@protoc_insertion_point(field_mutable:Effects.StackVar.Cards)
  return _internal_mutable_cards();
}

// .Effects.TileList Tiles = 3;
inline bool StackVar::_internal_has_tiles() const {
  return entity_case() == kTiles;
}
inline bool StackVar::has_tiles() const {
  return _internal_has_tiles();
}
inline void StackVar::set_has_tiles() {
  _oneof_case_[0] = kTiles;
}
inline void StackVar::clear_tiles() {
  if (_internal_has_tiles()) {
    if (GetArena() == nullptr) {
      delete entity_.tiles_;
    }
    clear_has_entity();
  }
}
inline ::Effects::TileList* StackVar::release_tiles() {
  // @@protoc_insertion_point(field_release:Effects.StackVar.Tiles)
  if (_internal_has_tiles()) {
    clear_has_entity();
      ::Effects::TileList* temp = entity_.tiles_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    entity_.tiles_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Effects::TileList& StackVar::_internal_tiles() const {
  return _internal_has_tiles()
      ? *entity_.tiles_
      : reinterpret_cast< ::Effects::TileList&>(::Effects::_TileList_default_instance_);
}
inline const ::Effects::TileList& StackVar::tiles() const {
  // @@protoc_insertion_point(field_get:Effects.StackVar.Tiles)
  return _internal_tiles();
}
inline ::Effects::TileList* StackVar::unsafe_arena_release_tiles() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Effects.StackVar.Tiles)
  if (_internal_has_tiles()) {
    clear_has_entity();
    ::Effects::TileList* temp = entity_.tiles_;
    entity_.tiles_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StackVar::unsafe_arena_set_allocated_tiles(::Effects::TileList* tiles) {
  clear_entity();
  if (tiles) {
    set_has_tiles();
    entity_.tiles_ = tiles;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Effects.StackVar.Tiles)
}
inline ::Effects::TileList* StackVar::_internal_mutable_tiles() {
  if (!_internal_has_tiles()) {
    clear_entity();
    set_has_tiles();
    entity_.tiles_ = CreateMaybeMessage< ::Effects::TileList >(GetArena());
  }
  return entity_.tiles_;
}
inline ::Effects::TileList* StackVar::mutable_tiles() {
  // @@protoc_insertion_point(field_mutable:Effects.StackVar.Tiles)
  return _internal_mutable_tiles();
}

// .Types.Path IntegerRef = 4;
inline bool StackVar::_internal_has_integerref() const {
  return entity_case() == kIntegerRef;
}
inline bool StackVar::has_integerref() const {
  return _internal_has_integerref();
}
inline void StackVar::set_has_integerref() {
  _oneof_case_[0] = kIntegerRef;
}
inline ::Types::Path* StackVar::release_integerref() {
  // @@protoc_insertion_point(field_release:Effects.StackVar.IntegerRef)
  if (_internal_has_integerref()) {
    clear_has_entity();
      ::Types::Path* temp = entity_.integerref_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    entity_.integerref_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Types::Path& StackVar::_internal_integerref() const {
  return _internal_has_integerref()
      ? *entity_.integerref_
      : reinterpret_cast< ::Types::Path&>(::Types::_Path_default_instance_);
}
inline const ::Types::Path& StackVar::integerref() const {
  // @@protoc_insertion_point(field_get:Effects.StackVar.IntegerRef)
  return _internal_integerref();
}
inline ::Types::Path* StackVar::unsafe_arena_release_integerref() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Effects.StackVar.IntegerRef)
  if (_internal_has_integerref()) {
    clear_has_entity();
    ::Types::Path* temp = entity_.integerref_;
    entity_.integerref_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StackVar::unsafe_arena_set_allocated_integerref(::Types::Path* integerref) {
  clear_entity();
  if (integerref) {
    set_has_integerref();
    entity_.integerref_ = integerref;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Effects.StackVar.IntegerRef)
}
inline ::Types::Path* StackVar::_internal_mutable_integerref() {
  if (!_internal_has_integerref()) {
    clear_entity();
    set_has_integerref();
    entity_.integerref_ = CreateMaybeMessage< ::Types::Path >(GetArena());
  }
  return entity_.integerref_;
}
inline ::Types::Path* StackVar::mutable_integerref() {
  // @@protoc_insertion_point(field_mutable:Effects.StackVar.IntegerRef)
  return _internal_mutable_integerref();
}

// .Types.Path Vec2iRef = 5;
inline bool StackVar::_internal_has_vec2iref() const {
  return entity_case() == kVec2IRef;
}
inline bool StackVar::has_vec2iref() const {
  return _internal_has_vec2iref();
}
inline void StackVar::set_has_vec2iref() {
  _oneof_case_[0] = kVec2IRef;
}
inline ::Types::Path* StackVar::release_vec2iref() {
  // @@protoc_insertion_point(field_release:Effects.StackVar.Vec2iRef)
  if (_internal_has_vec2iref()) {
    clear_has_entity();
      ::Types::Path* temp = entity_.vec2iref_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    entity_.vec2iref_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Types::Path& StackVar::_internal_vec2iref() const {
  return _internal_has_vec2iref()
      ? *entity_.vec2iref_
      : reinterpret_cast< ::Types::Path&>(::Types::_Path_default_instance_);
}
inline const ::Types::Path& StackVar::vec2iref() const {
  // @@protoc_insertion_point(field_get:Effects.StackVar.Vec2iRef)
  return _internal_vec2iref();
}
inline ::Types::Path* StackVar::unsafe_arena_release_vec2iref() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Effects.StackVar.Vec2iRef)
  if (_internal_has_vec2iref()) {
    clear_has_entity();
    ::Types::Path* temp = entity_.vec2iref_;
    entity_.vec2iref_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StackVar::unsafe_arena_set_allocated_vec2iref(::Types::Path* vec2iref) {
  clear_entity();
  if (vec2iref) {
    set_has_vec2iref();
    entity_.vec2iref_ = vec2iref;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Effects.StackVar.Vec2iRef)
}
inline ::Types::Path* StackVar::_internal_mutable_vec2iref() {
  if (!_internal_has_vec2iref()) {
    clear_entity();
    set_has_vec2iref();
    entity_.vec2iref_ = CreateMaybeMessage< ::Types::Path >(GetArena());
  }
  return entity_.vec2iref_;
}
inline ::Types::Path* StackVar::mutable_vec2iref() {
  // @@protoc_insertion_point(field_mutable:Effects.StackVar.Vec2iRef)
  return _internal_mutable_vec2iref();
}

// .Types.IntegerValue Integer = 6;
inline bool StackVar::_internal_has_integer() const {
  return entity_case() == kInteger;
}
inline bool StackVar::has_integer() const {
  return _internal_has_integer();
}
inline void StackVar::set_has_integer() {
  _oneof_case_[0] = kInteger;
}
inline ::Types::IntegerValue* StackVar::release_integer() {
  // @@protoc_insertion_point(field_release:Effects.StackVar.Integer)
  if (_internal_has_integer()) {
    clear_has_entity();
      ::Types::IntegerValue* temp = entity_.integer_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    entity_.integer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Types::IntegerValue& StackVar::_internal_integer() const {
  return _internal_has_integer()
      ? *entity_.integer_
      : reinterpret_cast< ::Types::IntegerValue&>(::Types::_IntegerValue_default_instance_);
}
inline const ::Types::IntegerValue& StackVar::integer() const {
  // @@protoc_insertion_point(field_get:Effects.StackVar.Integer)
  return _internal_integer();
}
inline ::Types::IntegerValue* StackVar::unsafe_arena_release_integer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Effects.StackVar.Integer)
  if (_internal_has_integer()) {
    clear_has_entity();
    ::Types::IntegerValue* temp = entity_.integer_;
    entity_.integer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StackVar::unsafe_arena_set_allocated_integer(::Types::IntegerValue* integer) {
  clear_entity();
  if (integer) {
    set_has_integer();
    entity_.integer_ = integer;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Effects.StackVar.Integer)
}
inline ::Types::IntegerValue* StackVar::_internal_mutable_integer() {
  if (!_internal_has_integer()) {
    clear_entity();
    set_has_integer();
    entity_.integer_ = CreateMaybeMessage< ::Types::IntegerValue >(GetArena());
  }
  return entity_.integer_;
}
inline ::Types::IntegerValue* StackVar::mutable_integer() {
  // @@protoc_insertion_point(field_mutable:Effects.StackVar.Integer)
  return _internal_mutable_integer();
}

// .Types.Vec2iValue Vec2i = 7;
inline bool StackVar::_internal_has_vec2i() const {
  return entity_case() == kVec2I;
}
inline bool StackVar::has_vec2i() const {
  return _internal_has_vec2i();
}
inline void StackVar::set_has_vec2i() {
  _oneof_case_[0] = kVec2I;
}
inline ::Types::Vec2iValue* StackVar::release_vec2i() {
  // @@protoc_insertion_point(field_release:Effects.StackVar.Vec2i)
  if (_internal_has_vec2i()) {
    clear_has_entity();
      ::Types::Vec2iValue* temp = entity_.vec2i_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    entity_.vec2i_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Types::Vec2iValue& StackVar::_internal_vec2i() const {
  return _internal_has_vec2i()
      ? *entity_.vec2i_
      : reinterpret_cast< ::Types::Vec2iValue&>(::Types::_Vec2iValue_default_instance_);
}
inline const ::Types::Vec2iValue& StackVar::vec2i() const {
  // @@protoc_insertion_point(field_get:Effects.StackVar.Vec2i)
  return _internal_vec2i();
}
inline ::Types::Vec2iValue* StackVar::unsafe_arena_release_vec2i() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Effects.StackVar.Vec2i)
  if (_internal_has_vec2i()) {
    clear_has_entity();
    ::Types::Vec2iValue* temp = entity_.vec2i_;
    entity_.vec2i_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StackVar::unsafe_arena_set_allocated_vec2i(::Types::Vec2iValue* vec2i) {
  clear_entity();
  if (vec2i) {
    set_has_vec2i();
    entity_.vec2i_ = vec2i;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Effects.StackVar.Vec2i)
}
inline ::Types::Vec2iValue* StackVar::_internal_mutable_vec2i() {
  if (!_internal_has_vec2i()) {
    clear_entity();
    set_has_vec2i();
    entity_.vec2i_ = CreateMaybeMessage< ::Types::Vec2iValue >(GetArena());
  }
  return entity_.vec2i_;
}
inline ::Types::Vec2iValue* StackVar::mutable_vec2i() {
  // @@protoc_insertion_point(field_mutable:Effects.StackVar.Vec2i)
  return _internal_mutable_vec2i();
}

inline bool StackVar::has_entity() const {
  return entity_case() != ENTITY_NOT_SET;
}
inline void StackVar::clear_has_entity() {
  _oneof_case_[0] = ENTITY_NOT_SET;
}
inline StackVar::EntityCase StackVar::entity_case() const {
  return StackVar::EntityCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Constant

// .Effects.StackVar Result = 1;
inline bool Constant::_internal_has_result() const {
  return this != internal_default_instance() && result_ != nullptr;
}
inline bool Constant::has_result() const {
  return _internal_has_result();
}
inline void Constant::clear_result() {
  if (GetArena() == nullptr && result_ != nullptr) {
    delete result_;
  }
  result_ = nullptr;
}
inline const ::Effects::StackVar& Constant::_internal_result() const {
  const ::Effects::StackVar* p = result_;
  return p != nullptr ? *p : reinterpret_cast<const ::Effects::StackVar&>(
      ::Effects::_StackVar_default_instance_);
}
inline const ::Effects::StackVar& Constant::result() const {
  // @@protoc_insertion_point(field_get:Effects.Constant.Result)
  return _internal_result();
}
inline void Constant::unsafe_arena_set_allocated_result(
    ::Effects::StackVar* result) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_);
  }
  result_ = result;
  if (result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Effects.Constant.Result)
}
inline ::Effects::StackVar* Constant::release_result() {
  
  ::Effects::StackVar* temp = result_;
  result_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Effects::StackVar* Constant::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:Effects.Constant.Result)
  
  ::Effects::StackVar* temp = result_;
  result_ = nullptr;
  return temp;
}
inline ::Effects::StackVar* Constant::_internal_mutable_result() {
  
  if (result_ == nullptr) {
    auto* p = CreateMaybeMessage<::Effects::StackVar>(GetArena());
    result_ = p;
  }
  return result_;
}
inline ::Effects::StackVar* Constant::mutable_result() {
  // @@protoc_insertion_point(field_mutable:Effects.Constant.Result)
  return _internal_mutable_result();
}
inline void Constant::set_allocated_result(::Effects::StackVar* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(result);
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    
  } else {
    
  }
  result_ = result;
  // @@protoc_insertion_point(field_set_allocated:Effects.Constant.Result)
}

// string Name = 2;
inline void Constant::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Constant::name() const {
  // @@protoc_insertion_point(field_get:Effects.Constant.Name)
  return _internal_name();
}
inline void Constant::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:Effects.Constant.Name)
}
inline std::string* Constant::mutable_name() {
  // @@protoc_insertion_point(field_mutable:Effects.Constant.Name)
  return _internal_mutable_name();
}
inline const std::string& Constant::_internal_name() const {
  return name_.Get();
}
inline void Constant::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Constant::set_name(std::string&& value) {
  
  name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:Effects.Constant.Name)
}
inline void Constant::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:Effects.Constant.Name)
}
inline void Constant::set_name(const char* value,
    size_t size) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:Effects.Constant.Name)
}
inline std::string* Constant::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Constant::release_name() {
  // @@protoc_insertion_point(field_release:Effects.Constant.Name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Constant::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:Effects.Constant.Name)
}

// -------------------------------------------------------------------

// Get

// .Effects.StackVar Result = 1;
inline bool Get::_internal_has_result() const {
  return this != internal_default_instance() && result_ != nullptr;
}
inline bool Get::has_result() const {
  return _internal_has_result();
}
inline void Get::clear_result() {
  if (GetArena() == nullptr && result_ != nullptr) {
    delete result_;
  }
  result_ = nullptr;
}
inline const ::Effects::StackVar& Get::_internal_result() const {
  const ::Effects::StackVar* p = result_;
  return p != nullptr ? *p : reinterpret_cast<const ::Effects::StackVar&>(
      ::Effects::_StackVar_default_instance_);
}
inline const ::Effects::StackVar& Get::result() const {
  // @@protoc_insertion_point(field_get:Effects.Get.Result)
  return _internal_result();
}
inline void Get::unsafe_arena_set_allocated_result(
    ::Effects::StackVar* result) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_);
  }
  result_ = result;
  if (result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Effects.Get.Result)
}
inline ::Effects::StackVar* Get::release_result() {
  
  ::Effects::StackVar* temp = result_;
  result_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Effects::StackVar* Get::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:Effects.Get.Result)
  
  ::Effects::StackVar* temp = result_;
  result_ = nullptr;
  return temp;
}
inline ::Effects::StackVar* Get::_internal_mutable_result() {
  
  if (result_ == nullptr) {
    auto* p = CreateMaybeMessage<::Effects::StackVar>(GetArena());
    result_ = p;
  }
  return result_;
}
inline ::Effects::StackVar* Get::mutable_result() {
  // @@protoc_insertion_point(field_mutable:Effects.Get.Result)
  return _internal_mutable_result();
}
inline void Get::set_allocated_result(::Effects::StackVar* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(result);
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    
  } else {
    
  }
  result_ = result;
  // @@protoc_insertion_point(field_set_allocated:Effects.Get.Result)
}

// .Types.Path Source = 2;
inline bool Get::_internal_has_source() const {
  return this != internal_default_instance() && source_ != nullptr;
}
inline bool Get::has_source() const {
  return _internal_has_source();
}
inline const ::Types::Path& Get::_internal_source() const {
  const ::Types::Path* p = source_;
  return p != nullptr ? *p : reinterpret_cast<const ::Types::Path&>(
      ::Types::_Path_default_instance_);
}
inline const ::Types::Path& Get::source() const {
  // @@protoc_insertion_point(field_get:Effects.Get.Source)
  return _internal_source();
}
inline void Get::unsafe_arena_set_allocated_source(
    ::Types::Path* source) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(source_);
  }
  source_ = source;
  if (source) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Effects.Get.Source)
}
inline ::Types::Path* Get::release_source() {
  
  ::Types::Path* temp = source_;
  source_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Types::Path* Get::unsafe_arena_release_source() {
  // @@protoc_insertion_point(field_release:Effects.Get.Source)
  
  ::Types::Path* temp = source_;
  source_ = nullptr;
  return temp;
}
inline ::Types::Path* Get::_internal_mutable_source() {
  
  if (source_ == nullptr) {
    auto* p = CreateMaybeMessage<::Types::Path>(GetArena());
    source_ = p;
  }
  return source_;
}
inline ::Types::Path* Get::mutable_source() {
  // @@protoc_insertion_point(field_mutable:Effects.Get.Source)
  return _internal_mutable_source();
}
inline void Get::set_allocated_source(::Types::Path* source) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(source_);
  }
  if (source) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(source)->GetArena();
    if (message_arena != submessage_arena) {
      source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source, submessage_arena);
    }
    
  } else {
    
  }
  source_ = source;
  // @@protoc_insertion_point(field_set_allocated:Effects.Get.Source)
}

// string Name = 3;
inline void Get::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Get::name() const {
  // @@protoc_insertion_point(field_get:Effects.Get.Name)
  return _internal_name();
}
inline void Get::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:Effects.Get.Name)
}
inline std::string* Get::mutable_name() {
  // @@protoc_insertion_point(field_mutable:Effects.Get.Name)
  return _internal_mutable_name();
}
inline const std::string& Get::_internal_name() const {
  return name_.Get();
}
inline void Get::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Get::set_name(std::string&& value) {
  
  name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:Effects.Get.Name)
}
inline void Get::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:Effects.Get.Name)
}
inline void Get::set_name(const char* value,
    size_t size) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:Effects.Get.Name)
}
inline std::string* Get::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Get::release_name() {
  // @@protoc_insertion_point(field_release:Effects.Get.Name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Get::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:Effects.Get.Name)
}

// -------------------------------------------------------------------

// Filter_Distance

// .Types.Path Source = 1;
inline bool Filter_Distance::_internal_has_source() const {
  return this != internal_default_instance() && source_ != nullptr;
}
inline bool Filter_Distance::has_source() const {
  return _internal_has_source();
}
inline const ::Types::Path& Filter_Distance::_internal_source() const {
  const ::Types::Path* p = source_;
  return p != nullptr ? *p : reinterpret_cast<const ::Types::Path&>(
      ::Types::_Path_default_instance_);
}
inline const ::Types::Path& Filter_Distance::source() const {
  // @@protoc_insertion_point(field_get:Effects.Filter_Distance.Source)
  return _internal_source();
}
inline void Filter_Distance::unsafe_arena_set_allocated_source(
    ::Types::Path* source) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(source_);
  }
  source_ = source;
  if (source) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Effects.Filter_Distance.Source)
}
inline ::Types::Path* Filter_Distance::release_source() {
  
  ::Types::Path* temp = source_;
  source_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Types::Path* Filter_Distance::unsafe_arena_release_source() {
  // @@protoc_insertion_point(field_release:Effects.Filter_Distance.Source)
  
  ::Types::Path* temp = source_;
  source_ = nullptr;
  return temp;
}
inline ::Types::Path* Filter_Distance::_internal_mutable_source() {
  
  if (source_ == nullptr) {
    auto* p = CreateMaybeMessage<::Types::Path>(GetArena());
    source_ = p;
  }
  return source_;
}
inline ::Types::Path* Filter_Distance::mutable_source() {
  // @@protoc_insertion_point(field_mutable:Effects.Filter_Distance.Source)
  return _internal_mutable_source();
}
inline void Filter_Distance::set_allocated_source(::Types::Path* source) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(source_);
  }
  if (source) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(source)->GetArena();
    if (message_arena != submessage_arena) {
      source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source, submessage_arena);
    }
    
  } else {
    
  }
  source_ = source;
  // @@protoc_insertion_point(field_set_allocated:Effects.Filter_Distance.Source)
}

// .Types.Path From = 2;
inline bool Filter_Distance::_internal_has_from() const {
  return this != internal_default_instance() && from_ != nullptr;
}
inline bool Filter_Distance::has_from() const {
  return _internal_has_from();
}
inline const ::Types::Path& Filter_Distance::_internal_from() const {
  const ::Types::Path* p = from_;
  return p != nullptr ? *p : reinterpret_cast<const ::Types::Path&>(
      ::Types::_Path_default_instance_);
}
inline const ::Types::Path& Filter_Distance::from() const {
  // @@protoc_insertion_point(field_get:Effects.Filter_Distance.From)
  return _internal_from();
}
inline void Filter_Distance::unsafe_arena_set_allocated_from(
    ::Types::Path* from) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(from_);
  }
  from_ = from;
  if (from) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Effects.Filter_Distance.From)
}
inline ::Types::Path* Filter_Distance::release_from() {
  
  ::Types::Path* temp = from_;
  from_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Types::Path* Filter_Distance::unsafe_arena_release_from() {
  // @@protoc_insertion_point(field_release:Effects.Filter_Distance.From)
  
  ::Types::Path* temp = from_;
  from_ = nullptr;
  return temp;
}
inline ::Types::Path* Filter_Distance::_internal_mutable_from() {
  
  if (from_ == nullptr) {
    auto* p = CreateMaybeMessage<::Types::Path>(GetArena());
    from_ = p;
  }
  return from_;
}
inline ::Types::Path* Filter_Distance::mutable_from() {
  // @@protoc_insertion_point(field_mutable:Effects.Filter_Distance.From)
  return _internal_mutable_from();
}
inline void Filter_Distance::set_allocated_from(::Types::Path* from) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(from_);
  }
  if (from) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(from)->GetArena();
    if (message_arena != submessage_arena) {
      from = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, from, submessage_arena);
    }
    
  } else {
    
  }
  from_ = from;
  // @@protoc_insertion_point(field_set_allocated:Effects.Filter_Distance.From)
}

// .Types.Path Distance = 3;
inline bool Filter_Distance::_internal_has_distance() const {
  return this != internal_default_instance() && distance_ != nullptr;
}
inline bool Filter_Distance::has_distance() const {
  return _internal_has_distance();
}
inline const ::Types::Path& Filter_Distance::_internal_distance() const {
  const ::Types::Path* p = distance_;
  return p != nullptr ? *p : reinterpret_cast<const ::Types::Path&>(
      ::Types::_Path_default_instance_);
}
inline const ::Types::Path& Filter_Distance::distance() const {
  // @@protoc_insertion_point(field_get:Effects.Filter_Distance.Distance)
  return _internal_distance();
}
inline void Filter_Distance::unsafe_arena_set_allocated_distance(
    ::Types::Path* distance) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(distance_);
  }
  distance_ = distance;
  if (distance) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Effects.Filter_Distance.Distance)
}
inline ::Types::Path* Filter_Distance::release_distance() {
  
  ::Types::Path* temp = distance_;
  distance_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Types::Path* Filter_Distance::unsafe_arena_release_distance() {
  // @@protoc_insertion_point(field_release:Effects.Filter_Distance.Distance)
  
  ::Types::Path* temp = distance_;
  distance_ = nullptr;
  return temp;
}
inline ::Types::Path* Filter_Distance::_internal_mutable_distance() {
  
  if (distance_ == nullptr) {
    auto* p = CreateMaybeMessage<::Types::Path>(GetArena());
    distance_ = p;
  }
  return distance_;
}
inline ::Types::Path* Filter_Distance::mutable_distance() {
  // @@protoc_insertion_point(field_mutable:Effects.Filter_Distance.Distance)
  return _internal_mutable_distance();
}
inline void Filter_Distance::set_allocated_distance(::Types::Path* distance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(distance_);
  }
  if (distance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(distance)->GetArena();
    if (message_arena != submessage_arena) {
      distance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, distance, submessage_arena);
    }
    
  } else {
    
  }
  distance_ = distance;
  // @@protoc_insertion_point(field_set_allocated:Effects.Filter_Distance.Distance)
}

// .Effects.Filter_Distance.CompType Comparison = 4;
inline void Filter_Distance::clear_comparison() {
  comparison_ = 0;
}
inline ::Effects::Filter_Distance_CompType Filter_Distance::_internal_comparison() const {
  return static_cast< ::Effects::Filter_Distance_CompType >(comparison_);
}
inline ::Effects::Filter_Distance_CompType Filter_Distance::comparison() const {
  // @@protoc_insertion_point(field_get:Effects.Filter_Distance.Comparison)
  return _internal_comparison();
}
inline void Filter_Distance::_internal_set_comparison(::Effects::Filter_Distance_CompType value) {
  
  comparison_ = value;
}
inline void Filter_Distance::set_comparison(::Effects::Filter_Distance_CompType value) {
  _internal_set_comparison(value);
  // @@protoc_insertion_point(field_set:Effects.Filter_Distance.Comparison)
}

// .Effects.Filter_Distance.GroupType LogicalUnion = 5;
inline void Filter_Distance::clear_logicalunion() {
  logicalunion_ = 0;
}
inline ::Effects::Filter_Distance_GroupType Filter_Distance::_internal_logicalunion() const {
  return static_cast< ::Effects::Filter_Distance_GroupType >(logicalunion_);
}
inline ::Effects::Filter_Distance_GroupType Filter_Distance::logicalunion() const {
  // @@protoc_insertion_point(field_get:Effects.Filter_Distance.LogicalUnion)
  return _internal_logicalunion();
}
inline void Filter_Distance::_internal_set_logicalunion(::Effects::Filter_Distance_GroupType value) {
  
  logicalunion_ = value;
}
inline void Filter_Distance::set_logicalunion(::Effects::Filter_Distance_GroupType value) {
  _internal_set_logicalunion(value);
  // @@protoc_insertion_point(field_set:Effects.Filter_Distance.LogicalUnion)
}

// -------------------------------------------------------------------

// Select

// .Types.Path Source = 1;
inline bool Select::_internal_has_source() const {
  return this != internal_default_instance() && source_ != nullptr;
}
inline bool Select::has_source() const {
  return _internal_has_source();
}
inline const ::Types::Path& Select::_internal_source() const {
  const ::Types::Path* p = source_;
  return p != nullptr ? *p : reinterpret_cast<const ::Types::Path&>(
      ::Types::_Path_default_instance_);
}
inline const ::Types::Path& Select::source() const {
  // @@protoc_insertion_point(field_get:Effects.Select.Source)
  return _internal_source();
}
inline void Select::unsafe_arena_set_allocated_source(
    ::Types::Path* source) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(source_);
  }
  source_ = source;
  if (source) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Effects.Select.Source)
}
inline ::Types::Path* Select::release_source() {
  
  ::Types::Path* temp = source_;
  source_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Types::Path* Select::unsafe_arena_release_source() {
  // @@protoc_insertion_point(field_release:Effects.Select.Source)
  
  ::Types::Path* temp = source_;
  source_ = nullptr;
  return temp;
}
inline ::Types::Path* Select::_internal_mutable_source() {
  
  if (source_ == nullptr) {
    auto* p = CreateMaybeMessage<::Types::Path>(GetArena());
    source_ = p;
  }
  return source_;
}
inline ::Types::Path* Select::mutable_source() {
  // @@protoc_insertion_point(field_mutable:Effects.Select.Source)
  return _internal_mutable_source();
}
inline void Select::set_allocated_source(::Types::Path* source) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(source_);
  }
  if (source) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(source)->GetArena();
    if (message_arena != submessage_arena) {
      source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source, submessage_arena);
    }
    
  } else {
    
  }
  source_ = source;
  // @@protoc_insertion_point(field_set_allocated:Effects.Select.Source)
}

// .Types.Path Number = 2;
inline bool Select::_internal_has_number() const {
  return this != internal_default_instance() && number_ != nullptr;
}
inline bool Select::has_number() const {
  return _internal_has_number();
}
inline const ::Types::Path& Select::_internal_number() const {
  const ::Types::Path* p = number_;
  return p != nullptr ? *p : reinterpret_cast<const ::Types::Path&>(
      ::Types::_Path_default_instance_);
}
inline const ::Types::Path& Select::number() const {
  // @@protoc_insertion_point(field_get:Effects.Select.Number)
  return _internal_number();
}
inline void Select::unsafe_arena_set_allocated_number(
    ::Types::Path* number) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(number_);
  }
  number_ = number;
  if (number) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Effects.Select.Number)
}
inline ::Types::Path* Select::release_number() {
  
  ::Types::Path* temp = number_;
  number_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Types::Path* Select::unsafe_arena_release_number() {
  // @@protoc_insertion_point(field_release:Effects.Select.Number)
  
  ::Types::Path* temp = number_;
  number_ = nullptr;
  return temp;
}
inline ::Types::Path* Select::_internal_mutable_number() {
  
  if (number_ == nullptr) {
    auto* p = CreateMaybeMessage<::Types::Path>(GetArena());
    number_ = p;
  }
  return number_;
}
inline ::Types::Path* Select::mutable_number() {
  // @@protoc_insertion_point(field_mutable:Effects.Select.Number)
  return _internal_mutable_number();
}
inline void Select::set_allocated_number(::Types::Path* number) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(number_);
  }
  if (number) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(number)->GetArena();
    if (message_arena != submessage_arena) {
      number = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, number, submessage_arena);
    }
    
  } else {
    
  }
  number_ = number;
  // @@protoc_insertion_point(field_set_allocated:Effects.Select.Number)
}

// bool UpTo = 3;
inline void Select::clear_upto() {
  upto_ = false;
}
inline bool Select::_internal_upto() const {
  return upto_;
}
inline bool Select::upto() const {
  // @@protoc_insertion_point(field_get:Effects.Select.UpTo)
  return _internal_upto();
}
inline void Select::_internal_set_upto(bool value) {
  
  upto_ = value;
}
inline void Select::set_upto(bool value) {
  _internal_set_upto(value);
  // @@protoc_insertion_point(field_set:Effects.Select.UpTo)
}

// bool Targets = 4;
inline void Select::clear_targets() {
  targets_ = false;
}
inline bool Select::_internal_targets() const {
  return targets_;
}
inline bool Select::targets() const {
  // @@protoc_insertion_point(field_get:Effects.Select.Targets)
  return _internal_targets();
}
inline void Select::_internal_set_targets(bool value) {
  
  targets_ = value;
}
inline void Select::set_targets(bool value) {
  _internal_set_targets(value);
  // @@protoc_insertion_point(field_set:Effects.Select.Targets)
}

// -------------------------------------------------------------------

// Move

// .Types.Path Destination = 1;
inline bool Move::_internal_has_destination() const {
  return this != internal_default_instance() && destination_ != nullptr;
}
inline bool Move::has_destination() const {
  return _internal_has_destination();
}
inline const ::Types::Path& Move::_internal_destination() const {
  const ::Types::Path* p = destination_;
  return p != nullptr ? *p : reinterpret_cast<const ::Types::Path&>(
      ::Types::_Path_default_instance_);
}
inline const ::Types::Path& Move::destination() const {
  // @@protoc_insertion_point(field_get:Effects.Move.Destination)
  return _internal_destination();
}
inline void Move::unsafe_arena_set_allocated_destination(
    ::Types::Path* destination) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(destination_);
  }
  destination_ = destination;
  if (destination) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Effects.Move.Destination)
}
inline ::Types::Path* Move::release_destination() {
  
  ::Types::Path* temp = destination_;
  destination_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Types::Path* Move::unsafe_arena_release_destination() {
  // @@protoc_insertion_point(field_release:Effects.Move.Destination)
  
  ::Types::Path* temp = destination_;
  destination_ = nullptr;
  return temp;
}
inline ::Types::Path* Move::_internal_mutable_destination() {
  
  if (destination_ == nullptr) {
    auto* p = CreateMaybeMessage<::Types::Path>(GetArena());
    destination_ = p;
  }
  return destination_;
}
inline ::Types::Path* Move::mutable_destination() {
  // @@protoc_insertion_point(field_mutable:Effects.Move.Destination)
  return _internal_mutable_destination();
}
inline void Move::set_allocated_destination(::Types::Path* destination) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(destination_);
  }
  if (destination) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(destination)->GetArena();
    if (message_arena != submessage_arena) {
      destination = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, destination, submessage_arena);
    }
    
  } else {
    
  }
  destination_ = destination;
  // @@protoc_insertion_point(field_set_allocated:Effects.Move.Destination)
}

// .Types.Path Player = 2;
inline bool Move::_internal_has_player() const {
  return this != internal_default_instance() && player_ != nullptr;
}
inline bool Move::has_player() const {
  return _internal_has_player();
}
inline const ::Types::Path& Move::_internal_player() const {
  const ::Types::Path* p = player_;
  return p != nullptr ? *p : reinterpret_cast<const ::Types::Path&>(
      ::Types::_Path_default_instance_);
}
inline const ::Types::Path& Move::player() const {
  // @@protoc_insertion_point(field_get:Effects.Move.Player)
  return _internal_player();
}
inline void Move::unsafe_arena_set_allocated_player(
    ::Types::Path* player) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(player_);
  }
  player_ = player;
  if (player) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Effects.Move.Player)
}
inline ::Types::Path* Move::release_player() {
  
  ::Types::Path* temp = player_;
  player_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Types::Path* Move::unsafe_arena_release_player() {
  // @@protoc_insertion_point(field_release:Effects.Move.Player)
  
  ::Types::Path* temp = player_;
  player_ = nullptr;
  return temp;
}
inline ::Types::Path* Move::_internal_mutable_player() {
  
  if (player_ == nullptr) {
    auto* p = CreateMaybeMessage<::Types::Path>(GetArena());
    player_ = p;
  }
  return player_;
}
inline ::Types::Path* Move::mutable_player() {
  // @@protoc_insertion_point(field_mutable:Effects.Move.Player)
  return _internal_mutable_player();
}
inline void Move::set_allocated_player(::Types::Path* player) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(player_);
  }
  if (player) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(player)->GetArena();
    if (message_arena != submessage_arena) {
      player = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player, submessage_arena);
    }
    
  } else {
    
  }
  player_ = player;
  // @@protoc_insertion_point(field_set_allocated:Effects.Move.Player)
}

// -------------------------------------------------------------------

// Effect

// .Effects.Get Get = 1;
inline bool Effect::_internal_has_get() const {
  return effect_case() == kGet;
}
inline bool Effect::has_get() const {
  return _internal_has_get();
}
inline void Effect::set_has_get() {
  _oneof_case_[0] = kGet;
}
inline void Effect::clear_get() {
  if (_internal_has_get()) {
    if (GetArena() == nullptr) {
      delete effect_.get_;
    }
    clear_has_effect();
  }
}
inline ::Effects::Get* Effect::release_get() {
  // @@protoc_insertion_point(field_release:Effects.Effect.Get)
  if (_internal_has_get()) {
    clear_has_effect();
      ::Effects::Get* temp = effect_.get_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    effect_.get_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Effects::Get& Effect::_internal_get() const {
  return _internal_has_get()
      ? *effect_.get_
      : reinterpret_cast< ::Effects::Get&>(::Effects::_Get_default_instance_);
}
inline const ::Effects::Get& Effect::get() const {
  // @@protoc_insertion_point(field_get:Effects.Effect.Get)
  return _internal_get();
}
inline ::Effects::Get* Effect::unsafe_arena_release_get() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Effects.Effect.Get)
  if (_internal_has_get()) {
    clear_has_effect();
    ::Effects::Get* temp = effect_.get_;
    effect_.get_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Effect::unsafe_arena_set_allocated_get(::Effects::Get* get) {
  clear_effect();
  if (get) {
    set_has_get();
    effect_.get_ = get;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Effects.Effect.Get)
}
inline ::Effects::Get* Effect::_internal_mutable_get() {
  if (!_internal_has_get()) {
    clear_effect();
    set_has_get();
    effect_.get_ = CreateMaybeMessage< ::Effects::Get >(GetArena());
  }
  return effect_.get_;
}
inline ::Effects::Get* Effect::mutable_get() {
  // @@protoc_insertion_point(field_mutable:Effects.Effect.Get)
  return _internal_mutable_get();
}

// .Effects.Constant Constant = 2;
inline bool Effect::_internal_has_constant() const {
  return effect_case() == kConstant;
}
inline bool Effect::has_constant() const {
  return _internal_has_constant();
}
inline void Effect::set_has_constant() {
  _oneof_case_[0] = kConstant;
}
inline void Effect::clear_constant() {
  if (_internal_has_constant()) {
    if (GetArena() == nullptr) {
      delete effect_.constant_;
    }
    clear_has_effect();
  }
}
inline ::Effects::Constant* Effect::release_constant() {
  // @@protoc_insertion_point(field_release:Effects.Effect.Constant)
  if (_internal_has_constant()) {
    clear_has_effect();
      ::Effects::Constant* temp = effect_.constant_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    effect_.constant_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Effects::Constant& Effect::_internal_constant() const {
  return _internal_has_constant()
      ? *effect_.constant_
      : reinterpret_cast< ::Effects::Constant&>(::Effects::_Constant_default_instance_);
}
inline const ::Effects::Constant& Effect::constant() const {
  // @@protoc_insertion_point(field_get:Effects.Effect.Constant)
  return _internal_constant();
}
inline ::Effects::Constant* Effect::unsafe_arena_release_constant() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Effects.Effect.Constant)
  if (_internal_has_constant()) {
    clear_has_effect();
    ::Effects::Constant* temp = effect_.constant_;
    effect_.constant_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Effect::unsafe_arena_set_allocated_constant(::Effects::Constant* constant) {
  clear_effect();
  if (constant) {
    set_has_constant();
    effect_.constant_ = constant;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Effects.Effect.Constant)
}
inline ::Effects::Constant* Effect::_internal_mutable_constant() {
  if (!_internal_has_constant()) {
    clear_effect();
    set_has_constant();
    effect_.constant_ = CreateMaybeMessage< ::Effects::Constant >(GetArena());
  }
  return effect_.constant_;
}
inline ::Effects::Constant* Effect::mutable_constant() {
  // @@protoc_insertion_point(field_mutable:Effects.Effect.Constant)
  return _internal_mutable_constant();
}

// .Effects.Filter_Distance Filter_Distance = 3;
inline bool Effect::_internal_has_filter_distance() const {
  return effect_case() == kFilterDistance;
}
inline bool Effect::has_filter_distance() const {
  return _internal_has_filter_distance();
}
inline void Effect::set_has_filter_distance() {
  _oneof_case_[0] = kFilterDistance;
}
inline void Effect::clear_filter_distance() {
  if (_internal_has_filter_distance()) {
    if (GetArena() == nullptr) {
      delete effect_.filter_distance_;
    }
    clear_has_effect();
  }
}
inline ::Effects::Filter_Distance* Effect::release_filter_distance() {
  // @@protoc_insertion_point(field_release:Effects.Effect.Filter_Distance)
  if (_internal_has_filter_distance()) {
    clear_has_effect();
      ::Effects::Filter_Distance* temp = effect_.filter_distance_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    effect_.filter_distance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Effects::Filter_Distance& Effect::_internal_filter_distance() const {
  return _internal_has_filter_distance()
      ? *effect_.filter_distance_
      : reinterpret_cast< ::Effects::Filter_Distance&>(::Effects::_Filter_Distance_default_instance_);
}
inline const ::Effects::Filter_Distance& Effect::filter_distance() const {
  // @@protoc_insertion_point(field_get:Effects.Effect.Filter_Distance)
  return _internal_filter_distance();
}
inline ::Effects::Filter_Distance* Effect::unsafe_arena_release_filter_distance() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Effects.Effect.Filter_Distance)
  if (_internal_has_filter_distance()) {
    clear_has_effect();
    ::Effects::Filter_Distance* temp = effect_.filter_distance_;
    effect_.filter_distance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Effect::unsafe_arena_set_allocated_filter_distance(::Effects::Filter_Distance* filter_distance) {
  clear_effect();
  if (filter_distance) {
    set_has_filter_distance();
    effect_.filter_distance_ = filter_distance;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Effects.Effect.Filter_Distance)
}
inline ::Effects::Filter_Distance* Effect::_internal_mutable_filter_distance() {
  if (!_internal_has_filter_distance()) {
    clear_effect();
    set_has_filter_distance();
    effect_.filter_distance_ = CreateMaybeMessage< ::Effects::Filter_Distance >(GetArena());
  }
  return effect_.filter_distance_;
}
inline ::Effects::Filter_Distance* Effect::mutable_filter_distance() {
  // @@protoc_insertion_point(field_mutable:Effects.Effect.Filter_Distance)
  return _internal_mutable_filter_distance();
}

// .Effects.Select Select = 4;
inline bool Effect::_internal_has_select() const {
  return effect_case() == kSelect;
}
inline bool Effect::has_select() const {
  return _internal_has_select();
}
inline void Effect::set_has_select() {
  _oneof_case_[0] = kSelect;
}
inline void Effect::clear_select() {
  if (_internal_has_select()) {
    if (GetArena() == nullptr) {
      delete effect_.select_;
    }
    clear_has_effect();
  }
}
inline ::Effects::Select* Effect::release_select() {
  // @@protoc_insertion_point(field_release:Effects.Effect.Select)
  if (_internal_has_select()) {
    clear_has_effect();
      ::Effects::Select* temp = effect_.select_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    effect_.select_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Effects::Select& Effect::_internal_select() const {
  return _internal_has_select()
      ? *effect_.select_
      : reinterpret_cast< ::Effects::Select&>(::Effects::_Select_default_instance_);
}
inline const ::Effects::Select& Effect::select() const {
  // @@protoc_insertion_point(field_get:Effects.Effect.Select)
  return _internal_select();
}
inline ::Effects::Select* Effect::unsafe_arena_release_select() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Effects.Effect.Select)
  if (_internal_has_select()) {
    clear_has_effect();
    ::Effects::Select* temp = effect_.select_;
    effect_.select_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Effect::unsafe_arena_set_allocated_select(::Effects::Select* select) {
  clear_effect();
  if (select) {
    set_has_select();
    effect_.select_ = select;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Effects.Effect.Select)
}
inline ::Effects::Select* Effect::_internal_mutable_select() {
  if (!_internal_has_select()) {
    clear_effect();
    set_has_select();
    effect_.select_ = CreateMaybeMessage< ::Effects::Select >(GetArena());
  }
  return effect_.select_;
}
inline ::Effects::Select* Effect::mutable_select() {
  // @@protoc_insertion_point(field_mutable:Effects.Effect.Select)
  return _internal_mutable_select();
}

// .Effects.Move Move = 5;
inline bool Effect::_internal_has_move() const {
  return effect_case() == kMove;
}
inline bool Effect::has_move() const {
  return _internal_has_move();
}
inline void Effect::set_has_move() {
  _oneof_case_[0] = kMove;
}
inline void Effect::clear_move() {
  if (_internal_has_move()) {
    if (GetArena() == nullptr) {
      delete effect_.move_;
    }
    clear_has_effect();
  }
}
inline ::Effects::Move* Effect::release_move() {
  // @@protoc_insertion_point(field_release:Effects.Effect.Move)
  if (_internal_has_move()) {
    clear_has_effect();
      ::Effects::Move* temp = effect_.move_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    effect_.move_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Effects::Move& Effect::_internal_move() const {
  return _internal_has_move()
      ? *effect_.move_
      : reinterpret_cast< ::Effects::Move&>(::Effects::_Move_default_instance_);
}
inline const ::Effects::Move& Effect::move() const {
  // @@protoc_insertion_point(field_get:Effects.Effect.Move)
  return _internal_move();
}
inline ::Effects::Move* Effect::unsafe_arena_release_move() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Effects.Effect.Move)
  if (_internal_has_move()) {
    clear_has_effect();
    ::Effects::Move* temp = effect_.move_;
    effect_.move_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Effect::unsafe_arena_set_allocated_move(::Effects::Move* move) {
  clear_effect();
  if (move) {
    set_has_move();
    effect_.move_ = move;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Effects.Effect.Move)
}
inline ::Effects::Move* Effect::_internal_mutable_move() {
  if (!_internal_has_move()) {
    clear_effect();
    set_has_move();
    effect_.move_ = CreateMaybeMessage< ::Effects::Move >(GetArena());
  }
  return effect_.move_;
}
inline ::Effects::Move* Effect::mutable_move() {
  // @@protoc_insertion_point(field_mutable:Effects.Effect.Move)
  return _internal_mutable_move();
}

inline bool Effect::has_effect() const {
  return effect_case() != EFFECT_NOT_SET;
}
inline void Effect::clear_has_effect() {
  _oneof_case_[0] = EFFECT_NOT_SET;
}
inline Effect::EffectCase Effect::effect_case() const {
  return Effect::EffectCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// CardEffect

// repeated .Effects.Effect Effects = 1;
inline int CardEffect::_internal_effects_size() const {
  return effects_.size();
}
inline int CardEffect::effects_size() const {
  return _internal_effects_size();
}
inline void CardEffect::clear_effects() {
  effects_.Clear();
}
inline ::Effects::Effect* CardEffect::mutable_effects(int index) {
  // @@protoc_insertion_point(field_mutable:Effects.CardEffect.Effects)
  return effects_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Effects::Effect >*
CardEffect::mutable_effects() {
  // @@protoc_insertion_point(field_mutable_list:Effects.CardEffect.Effects)
  return &effects_;
}
inline const ::Effects::Effect& CardEffect::_internal_effects(int index) const {
  return effects_.Get(index);
}
inline const ::Effects::Effect& CardEffect::effects(int index) const {
  // @@protoc_insertion_point(field_get:Effects.CardEffect.Effects)
  return _internal_effects(index);
}
inline ::Effects::Effect* CardEffect::_internal_add_effects() {
  return effects_.Add();
}
inline ::Effects::Effect* CardEffect::add_effects() {
  // @@protoc_insertion_point(field_add:Effects.CardEffect.Effects)
  return _internal_add_effects();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Effects::Effect >&
CardEffect::effects() const {
  // @@protoc_insertion_point(field_list:Effects.CardEffect.Effects)
  return effects_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Effects

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::Effects::Filter_Distance_CompType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Effects::Filter_Distance_CompType>() {
  return ::Effects::Filter_Distance_CompType_descriptor();
}
template <> struct is_proto_enum< ::Effects::Filter_Distance_GroupType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Effects::Filter_Distance_GroupType>() {
  return ::Effects::Filter_Distance_GroupType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Effects_2eproto
